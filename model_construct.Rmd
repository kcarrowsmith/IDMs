---
title: "IDM Model Construction"
author: "Kaysee Arrowsmith"
output: html_document
---

# Load Packages

```{r packages, message = F}
options(java.parameters = "- Xmx1024m")
library(knitr)
library(tidyverse)
library(raster)
library(geodata)
library(ENMTools)
library(ggthemes)
library(viridis)
library(predicts)
library(rJava)
library(modEvA)

theme_set(theme_light() +
            theme(text = element_text(size = 20)))
```

# Main Bumble Bee Data
I'm using the Bumble Bees of North America data from 2018--2022, which includes data collected for the Pacific Northwest Bumble Bee Atlas.

```{r bumble bee data}
# pnwbba <- read.csv("pnwbba_raw.csv", stringsAsFactors = F) # BBNA data is more recent
bbna <- read.csv("bbna_pnwbba.csv", stringsAsFactors = F)

top.bees <- bbna %>% 
  group_by(species) %>% 
  tally() %>%
  slice_max(order_by = n, n = 4)

top.floralpartners <- bbna %>% 
  filter(plant.host.genus != "") %>%
  group_by(plant.host.genus) %>% 
  tally() %>%
  slice_max(order_by = n, n = 5)

top.ints <- bbna %>%
  # filter(species %in% top.bees$species,
         # plant.host.genus %in% top.floralpartners$plant.host.genus) %>%
  group_by(species, plant.host.genus) %>%
  tally()

ints.by.year <- bbna %>%
  filter(species %in% top.bees$species,
         plant.host.genus %in% top.floralpartners$plant.host.genus) %>%
  group_by(year, species, plant.host.genus) %>%
  tally()
```

# Plant Data
From GBIF.org (16 January 2024) GBIF Occurrence Download  https://doi.org/10.15468/dl.ymhzyy

```{r gbif}
gbif <- read_tsv("gbif-top5.csv") %>%
  filter(year >= 2018)
```

# WorldClim Data

I'm cropping all of these predictor rasters to the extreme points of my GBIF data.

```{r worldclim, message = F}
bioclim <- crop(worldclim_global(var = "bio", 
                               res = 2.5, 
                               path = getwd()),
                ext(-130, -110, 40, 50))
# 
# elev.rast <- crop(elevation_global(res = 2.5,
#                        path = getwd()), 
#                        ext(-130, -110, 40, 50))
# 
# bioclim.elev <- c(bioclim, elev.rast)
```

Per [Feng et al. (2019)](https://onlinelibrary.wiley.com/doi/pdf/10.1002/ece3.5555), collinearity in predictors is not a major problem for MaxEnt.


# Bifarius
## Chamaenerion

```{r bif cham data, message = F}
gbif.cham <- gbif %>%
  filter(genus == "Chamaenerion")

bifcham <- bbna %>%
  filter(species == "bifarius",
         plant.host.genus == "Chamaenerion") %>%
  dplyr::select(latitude, longitude, plant.host.genus, date, month, day, year)
```

```{r bifcham maxent for loop, message = F, eval = T, results = "hide"}
bifcham.overlaplist <- vector(mode = "list", length = 100)
bifcham.idmlist <- vector(mode = "list", length = 100)
bifcham.overlapthresh <- vector(mode = "list", length = 100)
bifcham.idmthresh <- vector(mode = "list", length = 100)

bifcham.thresholddf <- data.frame()
bifcham.evaldf <- data.frame()
bifcham.allthresh <- data.frame()
# bifcham.varimpdf <- data.frame()

set.seed(121023)
for(i in 1:100){
  # Step 1: separate all data into training and testing datasets
  bg <- as.data.frame(spatSample(x = bioclim, size = 10000, method = "random", na.rm = T, xy = T)) %>%
    dplyr::select(x, y) %>%
    rename(longitude = x,
           latitude = y)
  bgfold <- kfold(bg, k = 5)
  bg.test <- bg[bgfold == 1,]
  bg.train <- bg[bgfold != 1,]
  
  bif.longlat <- bbna %>%
    filter(species == "bifarius",
           plant.host.genus != "Chamaenerion") %>%
    slice_sample(by = BBNA.code, n = 1) %>%
    dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  bif.fold <- kfold(bif.longlat, k = 5)
  bif.test <- bif.longlat[bif.fold == 1,]
  bif.train <- bif.longlat[bif.fold != 1,]
  
  cham.longlat <- gbif.cham %>%
  dplyr::select(decimalLongitude, decimalLatitude) %>%
  as.data.frame(.) %>%
  rename(longitude = decimalLongitude,
         latitude = decimalLatitude)
  cham.fold <- kfold(cham.longlat, k = 5)
  cham.test <- cham.longlat[cham.fold == 1,]
  cham.train <- cham.longlat[cham.fold != 1,]
  
  bifcham.longlat <- bifcham %>%
  dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  bifcham.fold <- kfold(bifcham.longlat, k = 5)
  bifcham.test <- bifcham.longlat[bifcham.fold == 1,]
  bifcham.train <- bifcham.longlat[bifcham.fold != 1,]
  
  
  
  # Step 2: Calculate overlaps
  ## Step 2a: Individual models
  bif.maxent <- maxent(x = stack(bioclim),
                       p = bif.train, 
                       a = bg.train)
  bif.predict <- dismo::predict(bif.maxent,
                                stack(bioclim))
  
  cham.maxent <- maxent(x = stack(bioclim), 
                       p = cham.train, 
                       a = bg.train)
  cham.predict <- dismo::predict(cham.maxent,
                                stack(bioclim))
  
  ## Step 2b: Multiply bee and plant habitat suitability to get a joint probability
  bifcham.overlap <- as(bif.predict * cham.predict, "SpatRaster")
  bifcham.overlaplist[[i]] = bifcham.overlap
  
  
  
  # Step 3: Calculate IDM
  bifcham.maxent <- maxent(x = stack(bioclim), 
                          p = bifcham.train, 
                          a = bg.train)
  
  bifcham.idm <- as(dismo::predict(bifcham.maxent, stack(bioclim)), "SpatRaster")
  bifcham.idmlist[[i]] = bifcham.idm
  
  
  # Step 4: Evaluate overlap model and IDM with the same interaction test data
  ## Step 4a: Normalize rasters
  bifcham.idmnorm = (bifcham.idm - minmax(bifcham.idm)[1,])/(minmax(bifcham.idm)[2,] - minmax(bifcham.idm)[1,])
  bifcham.overlapnorm = (bifcham.overlap - minmax(bifcham.overlap)[1,])/(minmax(bifcham.overlap)[2,] - minmax(bifcham.overlap)[1,])
  
  ## Step 4b: Use modEvA::AUC to get AUC
  bifcham.overlap.auc <- AUC(obs = bifcham.test, pred = bifcham.overlapnorm)
  bifcham.idm.auc <- AUC(obs = bifcham.test, pred = bifcham.idmnorm)
  
  ## Step 4c: Calculate TSS and tstar
  bifcham.overlap.tssdf <- bifcham.overlap.auc$thresholds %>%
    mutate(TSS = sensitivity + specificity - 1)
  bifcham.overlap.tstar <- which.max(bifcham.overlap.tssdf$TSS)
  bifcham.idm.tssdf <- bifcham.idm.auc$thresholds %>%
    mutate(TSS = sensitivity + specificity - 1)
  bifcham.idm.tstar <- which.max(bifcham.idm.tssdf$TSS)
  
  ## Step 4d: Save evaluation scores
  ### Note: RMSE is the same for both so it is only noted under the overlap
  bifcham.overlap.eval = data.frame(run = i,
                        model = "overlap",
                        AUC = bifcham.overlap.auc$AUC,
                        TSS = max(bifcham.overlap.tssdf$TSS),
                        tstar = bifcham.overlap.tssdf[bifcham.overlap.tstar, 1],
                        sens_star = bifcham.overlap.tssdf[bifcham.overlap.tstar, 4],
                        spec_star = bifcham.overlap.tssdf[bifcham.overlap.tstar, 5],
                        RMSE = predicts::RMSE(na.omit(values(bifcham.idmnorm)), na.omit(values(bifcham.overlapnorm)), na.rm = T))

  bifcham.idm.eval = data.frame(run = i,
                        model = "IDM",
                        AUC = bifcham.idm.auc$AUC,
                        TSS = max(bifcham.idm.tssdf$TSS),
                        tstar = bifcham.idm.tssdf[bifcham.idm.tstar, 1],
                        sens_star = bifcham.idm.tssdf[bifcham.idm.tstar, 4],
                        spec_star = bifcham.idm.tssdf[bifcham.idm.tstar, 5])
  
  bifcham.evaldf = bind_rows(bifcham.evaldf, bifcham.overlap.eval, bifcham.idm.eval)
  
  # Step 5: Calculate threshold overlap
  ## Step 5a: Threshold creations
  tstar.overlap = (bifcham.evaldf %>%
    filter(run == i,
           model == "overlap"))$tstar
  overlap.thresh = clamp(bifcham.overlapnorm, lower = tstar.overlap, upper = 1, values = T)
  overlap.thresh[overlap.thresh > tstar.overlap] = 1
  overlap.thresh[overlap.thresh <= tstar.overlap] = 0
  bifcham.overlapthresh[[i]] = overlap.thresh
  
  tstar.idm = (bifcham.evaldf %>%
    filter(run == i,
           model == "IDM"))$tstar
  idm.thresh = clamp(bifcham.idmnorm, lower = tstar.idm, upper = 1, values = T)
  idm.thresh[idm.thresh > tstar.idm] = 1
  idm.thresh[idm.thresh <= tstar.idm] = 0
  bifcham.idmthresh[[i]] = idm.thresh
  
  shared = overlap.thresh + idm.thresh
  diff = idm.thresh - overlap.thresh
  
  ## Step 5b: Threshold summary
  shared.df = data.frame(run = i,
                         n_shared = length(shared[shared == 2]),
                         n_IDM = length(diff[diff == 1]),
                         n_overlap = length(diff[diff == -1])) %>%
    mutate(prop.shared = n_shared/(n_shared + n_IDM + n_overlap),
           prop.idm = n_IDM/(n_shared + n_IDM + n_overlap),
           prop.overlap = n_overlap/(n_shared + n_IDM + n_overlap))
  
    bifcham.thresholddf = bind_rows(bifcham.thresholddf, shared.df)

  
  # # Step 5: Save Variable Importance
  # idm.vars = data.frame(run = rep(i, 20),
  #                       model = rep("IDM", 20),
  #                       variable = names(bifcham.maxent@results[7:26,]),
  #                       percent = bifcham.maxent@results[7:26],
  #                       permutation = bifcham.maxent@results[27:46])
  # 
  # bifcham.varimpdf = bind_rows(bifcham.varimpdf, idm.vars)
}

write.csv(bifcham.evaldf, file = "completed-evals/bifcham-eval.csv")
write.csv(bifcham.thresholddf, file = "completed-evals/bifcham-threshold.csv")
write.csv(bifcham.allthresh, file = "completed-evals/bifcham-allthresh.csv")
# write.csv(bifcham.varimpdf, file = "completed-evals/bifcham-varimport.csv")
save(bifcham.overlaplist, file = "bifcham-overlaps.RData")
save(bifcham.idmlist, file = "bifcham-idms.RData")
```

Here, we will build an ensemble of the 100 runs of the overlap and IDM, so I can look at them next to each other.

```{r bifcham ensemble}
bifcham.overlap.ensemble <- raster(mean(rast(bifcham.overlaplist[c(1:100)])))
bifcham.overlap.spdf <- as(bifcham.overlap.ensemble, "SpatialPixelsDataFrame")
bifcham.overlap.df <- as.data.frame(bifcham.overlap.spdf)

bifcham.overlap.plot <- ggplot() +
  geom_tile(data = bifcham.overlap.df, aes(x = x, y = y, fill = mean)) +
  coord_cartesian(xlim = c(-130, -110), ylim = c(40, 50)) +
  theme_map() +
  scale_fill_viridis(option = "magma", 
                     limits = c(0, 1))
ggsave("figures/bifcham-overlap.png", bifcham.overlap.plot, width = 6, height = 4, units = "in")

bifcham.idm.ensemble <- raster(mean(rast(bifcham.idmlist[c(1:100)])))
bifcham.idm.spdf <- as(bifcham.idm.ensemble, "SpatialPixelsDataFrame")
bifcham.idm.df <- as.data.frame(bifcham.idm.spdf)

bifcham.idm.plot <- ggplot() +
  geom_tile(data = bifcham.idm.df, aes(x = x, y = y, fill = mean)) +
  coord_cartesian(xlim = c(-130, -110), ylim = c(40, 50)) +
  theme_map() +
  scale_fill_viridis(option = "magma", 
                     limits = c(0, 1))
ggsave("figures/bifcham-idm.png", bifcham.idm.plot, width = 6, height = 4, units = "in")
```


## Cirsium

```{r bif cir data, message = F}
gbif.cir <- gbif %>%
  filter(genus == "Cirsium")

bifcir <- bbna %>% 
  filter(species == "bifarius",
         plant.host.genus == "Cirsium") %>%
  dplyr::select(latitude, longitude, plant.host.genus, date, month, day, year)
```

```{r bifcir maxent for loop, message = F, eval = T, results = "hide"}
bifcir.overlaplist <- vector(mode = "list", length = 100)
bifcir.idmlist <- vector(mode = "list", length = 100)
bifcir.overlapthresh <- vector(mode = "list", length = 100)
bifcir.idmthresh <- vector(mode = "list", length = 100)

bifcir.evaldf <- data.frame()
bifcir.thresholddf <- data.frame()
# bifcir.varimpdf <- data.frame()

set.seed(7840126)
for(i in 1:100){
  # Step 1: separate all data into training and testing datasets
  bg <- as.data.frame(spatSample(x = bioclim, size = 10000, method = "random", na.rm = T, xy = T)) %>%
    dplyr::select(x, y) %>%
    rename(longitude = x,
           latitude = y)
  bgfold <- kfold(bg, k = 5)
  bg.test <- bg[bgfold == 1,]
  bg.train <- bg[bgfold != 1,]
  
  bif.longlat <- bbna %>%
    filter(species == "bifarius",
           plant.host.genus != "Cirsium") %>%
    slice_sample(by = BBNA.code, n = 1) %>%
    dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  bif.fold <- kfold(bif.longlat, k = 5)
  bif.test <- bif.longlat[bif.fold == 1,]
  bif.train <- bif.longlat[bif.fold != 1,]
  
  cir.longlat <- gbif.cir %>%
  dplyr::select(decimalLongitude, decimalLatitude) %>%
  as.data.frame(.) %>%
  rename(longitude = decimalLongitude,
         latitude = decimalLatitude)
  cir.fold <- kfold(cir.longlat, k = 5)
  cir.test <- cir.longlat[cir.fold == 1,]
  cir.train <- cir.longlat[cir.fold != 1,]
  
  bifcir.longlat <- bifcir %>%
  dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  bifcir.fold <- kfold(bifcir.longlat, k = 5)
  bifcir.test <- bifcir.longlat[bifcir.fold == 1,]
  bifcir.train <- bifcir.longlat[bifcir.fold != 1,]

  
  
  # Step 2: Calculate overlaps
  ## Step 2a: Individual models
  bif.maxent <- maxent(x = stack(bioclim),
                       p = bif.train, 
                       a = bg.train)
  bif.predict <- dismo::predict(bif.maxent,
                                stack(bioclim))
  
  cir.maxent <- maxent(x = stack(bioclim), 
                       p = cir.train, 
                       a = bg.train)
  cir.predict <- dismo::predict(cir.maxent,
                                stack(bioclim))
  
  ## Step 2b: Multiply bee and plant habitat suitability to get a joint probability
  bifcir.overlap <- as(bif.predict * cir.predict, "SpatRaster")
  bifcir.overlaplist[[i]] = bifcir.overlap
  
  
  
  # Step 3: Calculate IDM
  bifcir.maxent <- maxent(x = stack(bioclim), 
                          p = bifcir.train, 
                          a = bg.train)
  
  bifcir.idm <- as(dismo::predict(bifcir.maxent, stack(bioclim)), "SpatRaster")
  bifcir.idmlist[[i]] = bifcir.idm
  
  
  
  # Step 4: Evaluate overlap model and IDM with the same interaction test data
    ## Step 4a: Normalize rasters
  bifcir.idmnorm = (bifcir.idm - minmax(bifcir.idm)[1,])/(minmax(bifcir.idm)[2,] - minmax(bifcir.idm)[1,])
  bifcir.overlapnorm = (bifcir.overlap - minmax(bifcir.overlap)[1,])/(minmax(bifcir.overlap)[2,] - minmax(bifcir.overlap)[1,])
  
  ## Step 4b: Use modEvA::AUC to get AUC
  bifcir.overlap.auc <- AUC(obs = bifcir.test, pred = bifcir.overlapnorm)
  bifcir.idm.auc <- AUC(obs = bifcir.test, pred = bifcir.idmnorm)
  
  ## Step 4c: Calculate TSS and tstar
  bifcir.overlap.tssdf <- bifcir.overlap.auc$thresholds %>%
    mutate(TSS = sensitivity + specificity - 1)
  bifcir.overlap.tstar <- which.max(bifcir.overlap.tssdf$TSS)
  bifcir.idm.tssdf <- bifcir.idm.auc$thresholds %>%
    mutate(TSS = sensitivity + specificity - 1)
  bifcir.idm.tstar <- which.max(bifcir.idm.tssdf$TSS)
  
  ## Step 4d: Save evaluation scores
  ### Note: RMSE is the same for both so it is only noted under the overlap
  bifcir.overlap.eval = data.frame(run = i,
                        model = "overlap",
                        AUC = bifcir.overlap.auc$AUC,
                        TSS = max(bifcir.overlap.tssdf$TSS),
                        tstar = bifcir.overlap.tssdf[bifcir.overlap.tstar, 1],
                        sens_star = bifcir.overlap.tssdf[bifcir.overlap.tstar, 4],
                        spec_star = bifcir.overlap.tssdf[bifcir.overlap.tstar, 5],
                        RMSE = predicts::RMSE(na.omit(values(bifcir.idmnorm)), na.omit(values(bifcir.overlapnorm)), na.rm = T))

  bifcir.idm.eval = data.frame(run = i,
                        model = "IDM",
                        AUC = bifcir.idm.auc$AUC,
                        TSS = max(bifcir.idm.tssdf$TSS),
                        tstar = bifcir.idm.tssdf[bifcir.idm.tstar, 1],
                        sens_star = bifcir.idm.tssdf[bifcir.idm.tstar, 4],
                        spec_star = bifcir.idm.tssdf[bifcir.idm.tstar, 5])
  
  bifcir.evaldf = bind_rows(bifcir.evaldf, bifcir.overlap.eval, bifcir.idm.eval)
  
  # Step 5: Calculate threshold overlap
  tstar.overlap = (bifcir.evaldf %>%
    filter(run == i,
           model == "overlap"))$tstar
  overlap.thresh = clamp(bifcir.overlapnorm, lower = tstar.overlap, upper = 1, values = T)
  overlap.thresh[overlap.thresh > tstar.overlap] = 1
  overlap.thresh[overlap.thresh <= tstar.overlap] = 0
  bifcir.overlapthresh[[i]] = overlap.thresh
  
  tstar.idm = (bifcir.evaldf %>%
    filter(run == i,
           model == "IDM"))$tstar
  idm.thresh = clamp(bifcir.idmnorm, lower = tstar.idm, upper = 1, values = T)
  idm.thresh[idm.thresh > tstar.idm] = 1
  idm.thresh[idm.thresh <= tstar.idm] = 0
  bifcir.idmthresh[[i]] = idm.thresh
  
  shared = overlap.thresh + idm.thresh
  diff = idm.thresh - overlap.thresh
  
  shared.df = data.frame(run = i,
                         n_shared = length(shared[shared == 2]),
                         n_IDM = length(diff[diff == 1]),
                         n_overlap = length(diff[diff == -1])) %>%
    mutate(prop.shared = n_shared/(n_shared + n_IDM + n_overlap),
           prop.idm = n_IDM/(n_shared + n_IDM + n_overlap),
           prop.overlap = n_overlap/(n_shared + n_IDM + n_overlap))
  
  bifcir.thresholddf = bind_rows(bifcir.thresholddf, shared.df)
  
  #   # Step 5: Save Variable Importance
  # idm.vars = data.frame(run = rep(i, 20),
  #                       model = rep("IDM", 20),
  #                       variable = names(bifcir.maxent@results[7:26,]),
  #                       percent = bifcir.maxent@results[7:26],
  #                       permutation = bifcir.maxent@results[27:46])
  # 
  # bifcir.varimpdf = bind_rows(bifcir.varimpdf, idm.vars)
}

write.csv(bifcir.thresholddf, file = "completed-evals/bifcir-threshold.csv")
write.csv(bifcir.evaldf, file = "completed-evals/bifcir-eval.csv")
# write.csv(bifcir.varimpdf, file = "completed-evals/bifcir-varimport.csv")
save(bifcir.overlaplist, file = "bifcir-overlaps.RData")
save(bifcir.idmlist, file = "bifcir-idms.RData")
```


```{r bifcir ensemble}
bifcir.overlap.ensemble <- raster(mean(rast(bifcir.overlaplist[c(1:100)])))
bifcir.overlap.spdf <- as(bifcir.overlap.ensemble, "SpatialPixelsDataFrame")
bifcir.overlap.df <- as.data.frame(bifcir.overlap.spdf)

bifcir.overlap.plot <- ggplot() +
  geom_tile(data = bifcir.overlap.df, aes(x = x, y = y, fill = mean)) +
  coord_cartesian(xlim = c(-130, -110), ylim = c(40, 50)) +
  theme_map() +
  scale_fill_viridis(option = "magma", 
                     limits = c(0, 1))
ggsave("figures/bifcir-overlap.png", bifcir.overlap.plot, width = 6, height = 4, units = "in")

bifcir.idm.ensemble <- raster(mean(rast(bifcir.idmlist[c(1:100)])))
bifcir.idm.spdf <- as(bifcir.idm.ensemble, "SpatialPixelsDataFrame")
bifcir.idm.df <- as.data.frame(bifcir.idm.spdf)

bifcir.idm.plot <- ggplot() +
  geom_tile(data = bifcir.idm.df, aes(x = x, y = y, fill = mean)) +
  coord_cartesian(xlim = c(-130, -110), ylim = c(40, 50)) +
  theme_map() +
  scale_fill_viridis(option = "magma", 
                     limits = c(0, 1))
ggsave("figures/bifcir-idm.png", bifcir.idm.plot, width = 6, height = 4, units = "in")
```

## Lupinus

We will first run this with the most common bumble bee species/plant genus pairing -- *B. bifarius* visiting *Lupinus* sp.

```{r bif lup data, message = F}
gbif.lup <- gbif %>%
  filter(genus == "Lupinus")

biflup <- bbna %>% 
  filter(species == "bifarius",
         plant.host.genus == "Lupinus") %>%
  dplyr::select(latitude, longitude, plant.host.genus, date, month, day, year)
```

Here we have a for-loop running MaxEnt models 100 times. For each run, we will select new training and test data, calculate overlaps, and calculate an IDM. We then save the evaluation metrics (AUC, TSS) in a dataframe to assess the performance of the different methods.

```{r biflup maxent for loop, message = F, eval = T, results = "hide"}
biflup.overlaplist <- vector(mode = "list", length = 100)
biflup.idmlist <- vector(mode = "list", length = 100)
biflup.overlapthresh <- vector(mode = "list", length = 100)
biflup.idmthresh <- vector(mode = "list", length = 100)

biflup.evaldf <- data.frame()
biflup.thresholddf <- data.frame()
# biflup.varimpdf <- data.frame()

set.seed(122223)

for(i in 1:100){
  # Step 1: separate all data into training and testing datasets
  bg <- as.data.frame(spatSample(x = bioclim, size = 10000, method = "random", na.rm = T, xy = T)) %>%
    dplyr::select(x, y) %>%
    rename(longitude = x,
           latitude = y)
  bgfold <- kfold(bg, k = 5)
  bg.test <- bg[bgfold == 1,]
  bg.train <- bg[bgfold != 1,]
  
  bif.longlat <- bbna %>%
    filter(species == "bifarius",
           plant.host.genus != "Lupinus") %>%
    slice_sample(by = BBNA.code, n = 1) %>%
    dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  bif.fold <- kfold(bif.longlat, k = 5)
  bif.test <- bif.longlat[bif.fold == 1,]
  bif.train <- bif.longlat[bif.fold != 1,]
  
  lup.longlat <- gbif.lup %>%
  dplyr::select(decimalLongitude, decimalLatitude) %>%
  as.data.frame(.) %>%
  rename(longitude = decimalLongitude,
         latitude = decimalLatitude)
  lup.fold <- kfold(lup.longlat, k = 5)
  lup.test <- lup.longlat[lup.fold == 1,]
  lup.train <- lup.longlat[lup.fold != 1,]
  
  biflup.longlat <- biflup %>%
  dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  biflup.fold <- kfold(biflup.longlat, k = 5)
  biflup.test <- biflup.longlat[biflup.fold == 1,]
  biflup.train <- biflup.longlat[biflup.fold != 1,]

  # biflup.test <- biflup %>%
  #   filter(year == "2020") %>%
  # dplyr::select(longitude, latitude) %>%
  # as.data.frame(.)
  # biflup.train <- biflup %>%
  #   filter(year != "2020") %>%
  # dplyr::select(longitude, latitude) %>%
  # as.data.frame(.)

  
  
  # Step 2: Calculate overlaps
  ## Step 2a: Individual models
  bif.maxent <- maxent(x = stack(bioclim),
                       p = bif.train, 
                       a = bg.train)
  bif.predict <- dismo::predict(bif.maxent,
                                stack(bioclim))
  
  lup.maxent <- maxent(x = stack(bioclim), 
                       p = lup.train, 
                       a = bg.train)
  lup.predict <- dismo::predict(lup.maxent,
                                stack(bioclim))
  
  ## Step 2b: Multiply bee and plant habitat suitability to get a joint probability
  biflup.overlap <- as(bif.predict * lup.predict, "SpatRaster")
  biflup.overlaplist[[i]] = biflup.overlap
  
  
  
  # Step 3: Calculate IDM
  biflup.maxent <- maxent(x = stack(bioclim), 
                          p = biflup.train, 
                          a = bg.train)
  
  biflup.idm <- as(dismo::predict(biflup.maxent, stack(bioclim)), "SpatRaster")
  biflup.idmlist[[i]] = biflup.idm
  
  
  
  # Step 4: Evaluate overlap model and IDM with the same interaction test data
  ## Step 4a: Normalize rasters
  biflup.idmnorm = (biflup.idm - minmax(biflup.idm)[1,])/(minmax(biflup.idm)[2,] - minmax(biflup.idm)[1,])
  biflup.overlapnorm = (biflup.overlap - minmax(biflup.overlap)[1,])/(minmax(biflup.overlap)[2,] - minmax(biflup.overlap)[1,])
  
  ## Step 4a: Use modEvA::AUC to get AUC
  biflup.overlap.auc <- AUC(obs = biflup.test, pred = biflup.overlapnorm)
  biflup.idm.auc <- AUC(obs = biflup.test, pred = biflup.idmnorm)
  
  ## Step 4b: Calculate TSS and tstar
  biflup.overlap.tssdf <- biflup.overlap.auc$thresholds %>%
    mutate(TSS = sensitivity + specificity - 1)
  biflup.overlap.tstar <- which.max(biflup.overlap.tssdf$TSS)
  biflup.idm.tssdf <- biflup.idm.auc$thresholds %>%
    mutate(TSS = sensitivity + specificity - 1)
  biflup.idm.tstar <- which.max(biflup.idm.tssdf$TSS)
  
  ## Step 4d: Save evaluation scores
  ### Note: RMSE is the same for both so it is only noted under the overlap
  biflup.overlap.eval = data.frame(run = i,
                        model = "overlap",
                        AUC = biflup.overlap.auc$AUC,
                        TSS = max(biflup.overlap.tssdf$TSS),
                        tstar = biflup.overlap.tssdf[biflup.overlap.tstar, 1],
                        sens_star = biflup.overlap.tssdf[biflup.overlap.tstar, 4],
                        spec_star = biflup.overlap.tssdf[biflup.overlap.tstar, 5],
                        RMSE = predicts::RMSE(na.omit(values(biflup.idmnorm)), na.omit(values(biflup.overlapnorm)), na.rm = T))

  biflup.idm.eval = data.frame(run = i,
                        model = "IDM",
                        AUC = biflup.idm.auc$AUC,
                        TSS = max(biflup.idm.tssdf$TSS),
                        tstar = biflup.idm.tssdf[biflup.idm.tstar, 1],
                        sens_star = biflup.idm.tssdf[biflup.idm.tstar, 4],
                        spec_star = biflup.idm.tssdf[biflup.idm.tstar, 5])
  
  biflup.evaldf = bind_rows(biflup.evaldf, biflup.overlap.eval, biflup.idm.eval)
  
  # Step 5: Compare threshold values
  tstar.overlap = (biflup.evaldf %>%
    filter(run == i,
           model == "overlap"))$tstar
  overlap.thresh = clamp(biflup.overlapnorm, lower = tstar.overlap, upper = 1, values = T)
  overlap.thresh[overlap.thresh > tstar.overlap] = 1
  overlap.thresh[overlap.thresh <= tstar.overlap] = 0
  biflup.overlapthresh[[i]] = overlap.thresh
  
  tstar.idm = (biflup.evaldf %>%
    filter(run == i,
           model == "IDM"))$tstar
  idm.thresh = clamp(biflup.idmnorm, lower = tstar.idm, upper = 1, values = T)
  idm.thresh[idm.thresh > tstar.idm] = 1
  idm.thresh[idm.thresh <= tstar.idm] = 0
  biflup.idmthresh[[i]] = idm.thresh
  
  shared = overlap.thresh + idm.thresh
  diff = idm.thresh - overlap.thresh
  
  shared.df = data.frame(run = i,
                         n_shared = length(shared[shared == 2]),
                         n_IDM = length(diff[diff == 1]),
                         n_overlap = length(diff[diff == -1])) %>%
    mutate(prop.shared = n_shared/(n_shared + n_IDM + n_overlap),
           prop.idm = n_IDM/(n_shared + n_IDM + n_overlap),
           prop.overlap = n_overlap/(n_shared + n_IDM + n_overlap))
  
  biflup.thresholddf = bind_rows(biflup.thresholddf, shared.df)
  
  #   # Step 5: Save variable importance
  # idm.vars = data.frame(run = rep(i, 20),
  #                       model = rep("IDM", 20),
  #                       variable = names(biflup.maxent@results[7:26,]),
  #                       percent = biflup.maxent@results[7:26],
  #                       permutation = biflup.maxent@results[27:46])
  # 
  # biflup.varimpdf = bind_rows(biflup.varimpdf, idm.vars)
}

write.csv(biflup.thresholddf, file = "completed-evals/biflup-threshold.csv")
write.csv(biflup.evaldf, file = "completed-evals/biflup-eval.csv")
# write.csv(biflup.varimpdf, file = "completed-evals/biflup-varimport.csv")
save(biflup.overlaplist, file = "biflup-overlaps.RData")
save(biflup.idmlist, file = "biflup-idms.RData")
```

```{r biflup ensemble}
biflup.overlap.ensemble <- raster(mean(rast(biflup.overlaplist[c(1:100)])))
biflup.overlap.spdf <- as(biflup.overlap.ensemble, "SpatialPixelsDataFrame")
biflup.overlap.df <- as.data.frame(biflup.overlap.spdf)

biflup.overlap.plot <- ggplot() +
  geom_tile(data = biflup.overlap.df, aes(x = x, y = y, fill = mean)) +
  coord_cartesian(xlim = c(-130, -110), ylim = c(40, 50)) +
  theme_map() +
  scale_fill_viridis(option = "magma", 
                     limits = c(0, 1))
ggsave("figures/biflup-overlap.png", biflup.overlap.plot, width = 6, height = 4, units = "in")

biflup.idm.ensemble <- raster(mean(rast(biflup.idmlist[c(1:100)])))
biflup.idm.spdf <- as(biflup.idm.ensemble, "SpatialPixelsDataFrame")
biflup.idm.df <- as.data.frame(biflup.idm.spdf)

biflup.idm.plot <- ggplot() +
  geom_tile(data = biflup.idm.df, aes(x = x, y = y, fill = mean)) +
  coord_cartesian(xlim = c(-130, -110), ylim = c(40, 50)) +
  theme_map() +
  scale_fill_viridis(option = "magma", 
                     limits = c(0, 1))
ggsave("figures/biflup-idm.png", biflup.idm.plot, width = 6, height = 4, units = "in")
```

## Penstemon

```{r bif pen data, message = F}
gbif.pen <- gbif %>%
  filter(genus == "Penstemon")

bifpen <- bbna %>% 
  filter(species == "bifarius",
         plant.host.genus == "Penstemon") %>%
  dplyr::select(latitude, longitude, plant.host.genus, date, month, day, year)
```

```{r bifpen maxent for loop, message = F, eval = T, results = "hide"}
bifpen.overlaplist <- vector(mode = "list", length = 100)
bifpen.idmlist <- vector(mode = "list", length = 100)
bifpen.overlapthresh <- vector(mode = "list", length = 100)
bifpen.idmthresh <- vector(mode = "list", length = 100)

bifpen.evaldf <- data.frame()
bifpen.thresholddf <- data.frame()
# bifpen.varimpdf <- data.frame()

set.seed(122323)
for(i in 1:100){
  # Step 1: separate all data into training and testing datasets
  bg <- as.data.frame(spatSample(x = bioclim, size = 10000, method = "random", na.rm = T, xy = T)) %>%
    dplyr::select(x, y) %>%
    rename(longitude = x,
           latitude = y)
  bgfold <- kfold(bg, k = 5)
  bg.test <- bg[bgfold == 1,]
  bg.train <- bg[bgfold != 1,]
  
  bif.longlat <- bbna %>%
    filter(species == "bifarius",
           plant.host.genus != "Penstemon") %>%
    slice_sample(by = BBNA.code, n = 1) %>%
    dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  bif.fold <- kfold(bif.longlat, k = 5)
  bif.test <- bif.longlat[bif.fold == 1,]
  bif.train <- bif.longlat[bif.fold != 1,]
  
  pen.longlat <- gbif.pen %>%
  dplyr::select(decimalLongitude, decimalLatitude) %>%
  as.data.frame(.) %>%
  rename(longitude = decimalLongitude,
         latitude = decimalLatitude)
  pen.fold <- kfold(pen.longlat, k = 5)
  pen.test <- pen.longlat[pen.fold == 1,]
  pen.train <- pen.longlat[pen.fold != 1,]
  
  bifpen.longlat <- bifpen %>%
  dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  bifpen.fold <- kfold(bifpen.longlat, k = 5)
  bifpen.test <- bifpen.longlat[bifpen.fold == 1,]
  bifpen.train <- bifpen.longlat[bifpen.fold != 1,]

  
  
  # Step 2: Calculate overlaps
  ## Step 2a: Individual models
  bif.maxent <- maxent(x = stack(bioclim),
                       p = bif.train, 
                       a = bg.train)
  bif.predict <- dismo::predict(bif.maxent,
                                stack(bioclim))
  
  pen.maxent <- maxent(x = stack(bioclim), 
                       p = pen.train, 
                       a = bg.train)
  pen.predict <- dismo::predict(pen.maxent,
                                stack(bioclim))
  
  ## Step 2b: Multiply bee and plant habitat suitability to get a joint probability
  bifpen.overlap <- as(bif.predict * pen.predict, "SpatRaster")
  bifpen.overlaplist[[i]] = bifpen.overlap
  
  
  
  # Step 3: Calculate IDM
  bifpen.maxent <- maxent(x = stack(bioclim), 
                          p = bifpen.train, 
                          a = bg.train)
  
  bifpen.idm <- as(dismo::predict(bifpen.maxent, stack(bioclim)), "SpatRaster")
  bifpen.idmlist[[i]] = bifpen.idm
  
  
  
  # Step 4: Evaluate overlap model and IDM with the same interaction test data
  ## Step 4a: Normalize rasters
  bifpen.idmnorm = (bifpen.idm - minmax(bifpen.idm)[1,])/(minmax(bifpen.idm)[2,] - minmax(bifpen.idm)[1,])
  bifpen.overlapnorm = (bifpen.overlap - minmax(bifpen.overlap)[1,])/(minmax(bifpen.overlap)[2,] - minmax(bifpen.overlap)[1,])
  
  ## Step 4b: Use modEvA::AUC to get AUC
  bifpen.overlap.auc <- AUC(obs = bifpen.test, pred = bifpen.overlapnorm)
  bifpen.idm.auc <- AUC(obs = bifpen.test, pred = bifpen.idmnorm)
  
  ## Step 4c: Calculate TSS and tstar
  bifpen.overlap.tssdf <- bifpen.overlap.auc$thresholds %>%
    mutate(TSS = sensitivity + specificity - 1)
  bifpen.overlap.tstar <- which.max(bifpen.overlap.tssdf$TSS)
  bifpen.idm.tssdf <- bifpen.idm.auc$thresholds %>%
    mutate(TSS = sensitivity + specificity - 1)
  bifpen.idm.tstar <- which.max(bifpen.idm.tssdf$TSS)
  
  ## Step 4d: Save evaluation scores
  ### Note: RMSE is the same for both so it is only noted under the overlap
  bifpen.overlap.eval = data.frame(run = i,
                        model = "overlap",
                        AUC = bifpen.overlap.auc$AUC,
                        TSS = max(bifpen.overlap.tssdf$TSS),
                        tstar = bifpen.overlap.tssdf[bifpen.overlap.tstar, 1],
                        sens_star = bifpen.overlap.tssdf[bifpen.overlap.tstar, 4],
                        spec_star = bifpen.overlap.tssdf[bifpen.overlap.tstar, 5],
                        RMSE = predicts::RMSE(na.omit(values(bifpen.idmnorm)), na.omit(values(bifpen.overlapnorm)), na.rm = T))

  bifpen.idm.eval = data.frame(run = i,
                        model = "IDM",
                        AUC = bifpen.idm.auc$AUC,
                        TSS = max(bifpen.idm.tssdf$TSS),
                        tstar = bifpen.idm.tssdf[bifpen.idm.tstar, 1],
                        sens_star = bifpen.idm.tssdf[bifpen.idm.tstar, 4],
                        spec_star = bifpen.idm.tssdf[bifpen.idm.tstar, 5])
  
  bifpen.evaldf = bind_rows(bifpen.evaldf, bifpen.overlap.eval, bifpen.idm.eval)
  
  # Step 5: Calculate threshold difference
  tstar.overlap = (bifpen.evaldf %>%
    filter(run == i,
           model == "overlap"))$tstar
  overlap.thresh = clamp(bifpen.overlapnorm, lower = tstar.overlap, upper = 1, values = T)
  overlap.thresh[overlap.thresh > tstar.overlap] = 1
  overlap.thresh[overlap.thresh <= tstar.overlap] = 0
  bifpen.overlapthresh[[i]] = overlap.thresh
  
  tstar.idm = (bifpen.evaldf %>%
    filter(run == i,
           model == "IDM"))$tstar
  idm.thresh = clamp(bifpen.idmnorm, lower = tstar.idm, upper = 1, values = T)
  idm.thresh[idm.thresh > tstar.idm] = 1
  idm.thresh[idm.thresh <= tstar.idm] = 0
  bifpen.idmthresh[[i]] = idm.thresh
  
  shared = overlap.thresh + idm.thresh
  diff = idm.thresh - overlap.thresh
  
  shared.df = data.frame(run = i,
                         n_shared = length(shared[shared == 2]),
                         n_IDM = length(diff[diff == 1]),
                         n_overlap = length(diff[diff == -1])) %>%
    mutate(prop.shared = n_shared/(n_shared + n_IDM + n_overlap),
           prop.idm = n_IDM/(n_shared + n_IDM + n_overlap),
           prop.overlap = n_overlap/(n_shared + n_IDM + n_overlap))
  
  bifpen.thresholddf = bind_rows(bifpen.thresholddf, shared.df)
  
  #   # Step 5: Save variable importance
  # idm.vars = data.frame(run = rep(i, 20),
  #                       model = rep("IDM", 20),
  #                       variable = names(bifpen.maxent@results[7:26,]),
  #                       percent = bifpen.maxent@results[7:26],
  #                       permutation = bifpen.maxent@results[27:46])
  # 
  # bifpen.varimpdf = bind_rows(bifpen.varimpdf, idm.vars)
}

write.csv(bifpen.thresholddf, file = "completed-evals/bifpen-threshold.csv")
write.csv(bifpen.evaldf, file = "completed-evals/bifpen-eval.csv")
# write.csv(bifpen.varimpdf, file = "completed-evals/bifpen-varimport.csv")
save(biflup.overlaplist, file = "biflup-overlaps.RData")
save(biflup.idmlist, file = "biflup-idms.RData")
```

```{r bifpen ensemble}
bifpen.overlap.ensemble <- raster(mean(rast(bifpen.overlaplist[c(1:100)])))
bifpen.overlap.spdf <- as(bifpen.overlap.ensemble, "SpatialPixelsDataFrame")
bifpen.overlap.df <- as.data.frame(bifpen.overlap.spdf)

bifpen.overlap.plot <- ggplot() +
  geom_tile(data = bifpen.overlap.df, aes(x = x, y = y, fill = mean)) +
  coord_cartesian(xlim = c(-130, -110), ylim = c(40, 50)) +
  theme_map() +
  scale_fill_viridis(option = "magma", 
                     limits = c(0, 1))
ggsave("figures/bifpen-overlap.png", bifpen.overlap.plot, width = 6, height = 4, units = "in")

bifpen.idm.ensemble <- raster(mean(rast(bifpen.idmlist[c(1:100)])))
bifpen.idm.spdf <- as(bifpen.idm.ensemble, "SpatialPixelsDataFrame")
bifpen.idm.df <- as.data.frame(bifpen.idm.spdf)

bifpen.idm.plot <- ggplot() +
  geom_tile(data = bifpen.idm.df, aes(x = x, y = y, fill = mean)) +
  coord_cartesian(xlim = c(-130, -110), ylim = c(40, 50)) +
  theme_map() +
  scale_fill_viridis(option = "magma", 
                     limits = c(0, 1))
ggsave("figures/bifpen-idm.png", bifpen.idm.plot, width = 6, height = 4, units = "in")
```

## Rubus
```{r bif rub data, message = F}
gbif.rub <- gbif %>%
  filter(genus == "Rubus")

bifrub <- bbna %>%
  filter(species == "bifarius",
         plant.host.genus == "Rubus") %>%
  dplyr::select(latitude, longitude, plant.host.genus, date, month, day, year)
```

```{r bifrub maxent for loop, message = F, eval = T, results = "hide"}
bifrub.overlaplist <- vector(mode = "list", length = 100)
bifrub.idmlist <- vector(mode = "list", length = 100)
bifrub.overlapthresh <- vector(mode = "list", length = 100)
bifrub.idmthresh <- vector(mode = "list", length = 100)

bifrub.evaldf <- data.frame()
bifrub.thresholddf <- data.frame()
# bifrub.varimpdf <- data.frame()

set.seed(429024)
for(i in 1:100){
  # Step 1: separate all data into training and testing datasets
  bg <- as.data.frame(spatSample(x = bioclim, size = 10000, method = "random", na.rm = T, xy = T)) %>%
    dplyr::select(x, y) %>%
    rename(longitude = x,
           latitude = y)
  bgfold <- kfold(bg, k = 5)
  bg.test <- bg[bgfold == 1,]
  bg.train <- bg[bgfold != 1,]
  
  bif.longlat <- bbna %>%
    filter(species == "bifarius",
           plant.host.genus != "Rubus") %>%
    slice_sample(by = BBNA.code, n = 1) %>%
    dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  bif.fold <- kfold(bif.longlat, k = 5)
  bif.test <- bif.longlat[bif.fold == 1,]
  bif.train <- bif.longlat[bif.fold != 1,]
  
  rub.longlat <- gbif.rub %>%
  dplyr::select(decimalLongitude, decimalLatitude) %>%
  as.data.frame(.) %>%
  rename(longitude = decimalLongitude,
         latitude = decimalLatitude)
  rub.fold <- kfold(rub.longlat, k = 5)
  rub.test <- rub.longlat[rub.fold == 1,]
  rub.train <- rub.longlat[rub.fold != 1,]
  
  bifrub.longlat <- bifrub %>%
  dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  bifrub.fold <- kfold(bifrub.longlat, k = 5)
  bifrub.test <- bifrub.longlat[bifrub.fold == 1,]
  bifrub.train <- bifrub.longlat[bifrub.fold != 1,]
  
  
  
  # Step 2: Calculate overlaps
  ## Step 2a: Individual models
  bif.maxent <- maxent(x = stack(bioclim),
                       p = bif.train, 
                       a = bg.train)
  bif.predict <- dismo::predict(bif.maxent,
                                stack(bioclim))
  
  rub.maxent <- maxent(x = stack(bioclim), 
                       p = rub.train, 
                       a = bg.train)
  rub.predict <- dismo::predict(rub.maxent,
                                stack(bioclim))
  
  ## Step 2b: Multiply bee and plant habitat suitability to get a joint probability
  bifrub.overlap <- as(bif.predict * rub.predict, "SpatRaster")
  bifrub.overlaplist[[i]] = bifrub.overlap
  
  
  
  # Step 3: Calculate IDM
  bifrub.maxent <- maxent(x = stack(bioclim), 
                          p = bifrub.train, 
                          a = bg.train)
  
  bifrub.idm <- as(dismo::predict(bifcir.maxent, stack(bioclim)), "SpatRaster")
  bifrub.idmlist[[i]] = bifrub.idm
  
  
  
  # Step 4: Evaluate overlap model and IDM with the same interaction test data
  ## Step 4a: Normalize rasters
  bifrub.idmnorm = (bifrub.idm - minmax(bifrub.idm)[1,])/(minmax(bifrub.idm)[2,] - minmax(bifrub.idm)[1,])
  bifrub.overlapnorm = (bifrub.overlap - minmax(bifrub.overlap)[1,])/(minmax(bifrub.overlap)[2,] - minmax(bifrub.overlap)[1,])
  
  ## Step 4b: Use modEvA::AUC to get AUC
  bifrub.overlap.auc <- AUC(obs = bifrub.test, pred = bifrub.overlapnorm)
  bifrub.idm.auc <- AUC(obs = bifrub.test, pred = bifrub.idmnorm)
  
  ## Step 4c: Calculate TSS and tstar
  bifrub.overlap.tssdf <- bifrub.overlap.auc$thresholds %>%
    mutate(TSS = sensitivity + specificity - 1)
  bifrub.overlap.tstar <- which.max(bifrub.overlap.tssdf$TSS)
  bifrub.idm.tssdf <- bifrub.idm.auc$thresholds %>%
    mutate(TSS = sensitivity + specificity - 1)
  bifrub.idm.tstar <- which.max(bifrub.idm.tssdf$TSS)
  
  ## Step 4d: Save evaluation scores
  ### Note: RMSE is the same for both so it is only noted under the overlap
  bifrub.overlap.eval = data.frame(run = i,
                        model = "overlap",
                        AUC = bifrub.overlap.auc$AUC,
                        TSS = max(bifrub.overlap.tssdf$TSS),
                        tstar = bifrub.overlap.tssdf[bifrub.overlap.tstar, 1],
                        sens_star = bifrub.overlap.tssdf[bifrub.overlap.tstar, 4],
                        spec_star = bifrub.overlap.tssdf[bifrub.overlap.tstar, 5],
                        RMSE = predicts::RMSE(na.omit(values(bifrub.idmnorm)), na.omit(values(bifrub.overlapnorm)), na.rm = T))

  bifrub.idm.eval = data.frame(run = i,
                        model = "IDM",
                        AUC = bifcir.idm.auc$AUC,
                        TSS = max(bifrub.idm.tssdf$TSS),
                        tstar = bifrub.idm.tssdf[bifrub.idm.tstar, 1],
                        sens_star = bifrub.idm.tssdf[bifrub.idm.tstar, 4],
                        spec_star = bifrub.idm.tssdf[bifrub.idm.tstar, 5])
  
  bifrub.evaldf = bind_rows(bifrub.evaldf, bifrub.overlap.eval, bifrub.idm.eval)
  
  # Step 5: Calculate threshold difference
  tstar.overlap = (bifrub.evaldf %>%
    filter(run == i,
           model == "overlap"))$tstar
  overlap.thresh = clamp(bifrub.overlapnorm, lower = tstar.overlap, upper = 1, values = T)
  overlap.thresh[overlap.thresh > tstar.overlap] = 1
  overlap.thresh[overlap.thresh <= tstar.overlap] = 0
  bifrub.overlapthresh[[i]] = overlap.thresh
  
  tstar.idm = (bifrub.evaldf %>%
    filter(run == i,
           model == "IDM"))$tstar
  idm.thresh = clamp(bifrub.idmnorm, lower = tstar.idm, upper = 1, values = T)
  idm.thresh[idm.thresh > tstar.idm] = 1
  idm.thresh[idm.thresh <= tstar.idm] = 0
  bifrub.idmthresh[[i]] = idm.thresh
  
  shared = overlap.thresh + idm.thresh
  diff = idm.thresh - overlap.thresh
  
  shared.df = data.frame(run = i,
                         n_shared = length(shared[shared == 2]),
                         n_IDM = length(diff[diff == 1]),
                         n_overlap = length(diff[diff == -1])) %>%
    mutate(prop.shared = n_shared/(n_shared + n_IDM + n_overlap),
           prop.idm = n_IDM/(n_shared + n_IDM + n_overlap),
           prop.overlap = n_overlap/(n_shared + n_IDM + n_overlap))
  
  bifrub.thresholddf = bind_rows(bifrub.thresholddf, shared.df)
  
  #   # Step 5: Save Variable Importance
  # idm.vars = data.frame(run = rep(i, 20),
  #                       model = rep("IDM", 20),
  #                       variable = names(bifrub.maxent@results[7:26,]),
  #                       percent = bifrub.maxent@results[7:26],
  #                       permutation = bifrub.maxent@results[27:46])
  # 
  # bifrub.varimpdf = bind_rows(bifrub.varimpdf, idm.vars)
}

write.csv(bifrub.evaldf, file = "completed-evals/bifrub-eval.csv")
write.csv(bifrub.thresholddf, file = "completed-evals/bifrub-threshold.csv")
# write.csv(bifrub.varimpdf, file = "completed-evals/bifrub-varimport.csv")
save(bifrub.overlaplist, file = "bifrub-overlaps.RData")
save(bifrub.idmlist, file = "bifrub-idms.RData")
```

```{r bifrub ensemble}
bifrub.overlap.ensemble <- raster(mean(rast(bifrub.overlaplist[c(1:100)])))
bifrub.overlap.spdf <- as(bifrub.overlap.ensemble, "SpatialPixelsDataFrame")
bifrub.overlap.df <- as.data.frame(bifrub.overlap.spdf)

bifrub.overlap.plot <- ggplot() +
  geom_tile(data = bifrub.overlap.df, aes(x = x, y = y, fill = mean)) +
  coord_cartesian(xlim = c(-130, -110), ylim = c(40, 50)) +
  theme_map() +
  scale_fill_viridis(option = "magma", 
                     limits = c(0, 1))
ggsave("figures/bifrub-overlap.png", bifrub.overlap.plot, width = 6, height = 4, units = "in")

bifrub.idm.ensemble <- raster(mean(rast(bifrub.idmlist[c(1:100)])))
bifrub.idm.spdf <- as(bifrub.idm.ensemble, "SpatialPixelsDataFrame")
bifrub.idm.df <- as.data.frame(bifrub.idm.spdf)

bifrub.idm.plot <- ggplot() +
  geom_tile(data = bifrub.idm.df, aes(x = x, y = y, fill = mean)) +
  coord_cartesian(xlim = c(-130, -110), ylim = c(40, 50)) +
  theme_map() +
  scale_fill_viridis(option = "magma", 
                     limits = c(0, 1))
ggsave("figures/bifrub-idm.png", bifrub.idm.plot, width = 6, height = 4, units = "in")
```

# Flavifrons
## Chamaenerion
```{r flav cham data, message = F}
gbif.cham <- gbif %>%
  filter(genus == "Chamaenerion")

flavcham <- bbna %>%
  filter(species == "flavifrons",
         plant.host.genus == "Chamaenerion") %>%
  dplyr::select(latitude, longitude, plant.host.genus, date, month, day, year)
```

```{r flavcham maxent for loop, message = F, eval = T, results = "hide"}
flavcham.overlaplist <- vector(mode = "list", length = 100)
flavcham.idmlist <- vector(mode = "list", length = 100)
flavcham.overlapthresh <- vector(mode = "list", length = 100)
flavcham.idmthresh <- vector(mode = "list", length = 100)

flavcham.evaldf <- data.frame()
flavcham.thresholddf <- data.frame()
# flavcham.varimpdf <- data.frame()

set.seed(15124)
for(i in 1:100){
  # Step 1: separate all data into training and testing datasets
  bg <- as.data.frame(spatSample(x = bioclim, size = 10000, method = "random", na.rm = T, xy = T)) %>%
    dplyr::select(x, y) %>%
    rename(longitude = x,
           latitude = y)
  bgfold <- kfold(bg, k = 5)
  bg.test <- bg[bgfold == 1,]
  bg.train <- bg[bgfold != 1,]
  
  flav.longlat <- bbna %>%
    filter(species == "flavifrons",
           plant.host.genus != "Chamaenerion") %>%
    slice_sample(by = BBNA.code, n = 1) %>%
    dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  flav.fold <- kfold(flav.longlat, k = 5)
  flav.test <- flav.longlat[flav.fold == 1,]
  flav.train <- flav.longlat[flav.fold != 1,]
  
  cham.longlat <- gbif.cham %>%
  dplyr::select(decimalLongitude, decimalLatitude) %>%
  as.data.frame(.) %>%
  rename(longitude = decimalLongitude,
         latitude = decimalLatitude)
  cham.fold <- kfold(cham.longlat, k = 5)
  cham.test <- cham.longlat[cham.fold == 1,]
  cham.train <- cham.longlat[cham.fold != 1,]
  
  flavcham.longlat <- flavcham %>%
  dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  flavcham.fold <- kfold(flavcham.longlat, k = 5)
  flavcham.test <- flavcham.longlat[flavcham.fold == 1,]
  flavcham.train <- flavcham.longlat[flavcham.fold != 1,]
  
  
  
  # Step 2: Calculate overlaps
  ## Step 2a: Individual models
  flav.maxent <- maxent(x = stack(bioclim),
                       p = flav.train, 
                       a = bg.train)
  flav.predict <- dismo::predict(flav.maxent,
                                stack(bioclim))
  
  cham.maxent <- maxent(x = stack(bioclim), 
                       p = cham.train, 
                       a = bg.train)
  cham.predict <- dismo::predict(cham.maxent,
                                stack(bioclim))
  
  ## Step 2b: Multiply bee and plant habitat suitability to get a joint probability
  flavcham.overlap <- as(flav.predict * cham.predict, "SpatRaster")
  flavcham.overlaplist[[i]] = flavcham.overlap
  
  
  
  # Step 3: Calculate IDM
  flavcham.maxent <- maxent(x = stack(bioclim), 
                          p = flavcham.train, 
                          a = bg.train)
  
  flavcham.idm <- as(dismo::predict(flavcham.maxent, stack(bioclim)), "SpatRaster")
  flavcham.idmlist[[i]] = flavcham.idm
  
  
  
  # Step 4: Evaluate overlap model and IDM with the same interaction test data
  ## Step 4a: Normalize rasters
  flavcham.idmnorm = (flavcham.idm - minmax(flavcham.idm)[1,])/(minmax(flavcham.idm)[2,] - minmax(flavcham.idm)[1,])
  flavcham.overlapnorm = (flavcham.overlap - minmax(flavcham.overlap)[1,])/(minmax(flavcham.overlap)[2,] - minmax(flavcham.overlap)[1,])
  
  ## Step 4b: Use modEvA::AUC to get AUC
  flavcham.overlap.auc <- AUC(obs = flavcham.test, pred = flavcham.overlapnorm)
  flavcham.idm.auc <- AUC(obs = flavcham.test, pred = flavcham.idmnorm)
  
  ## Step 4v: Calculate TSS and tstar
  flavcham.overlap.tssdf <- flavcham.overlap.auc$thresholds %>%
    mutate(TSS = sensitivity + specificity - 1)
  flavcham.overlap.tstar <- which.max(flavcham.overlap.tssdf$TSS)
  flavcham.idm.tssdf <- flavcham.idm.auc$thresholds %>%
    mutate(TSS = sensitivity + specificity - 1)
  flavcham.idm.tstar <- which.max(flavcham.idm.tssdf$TSS)
  
  ## Step 4d: Save evaluation scores
  ### Note: RMSE is the same for both so it is only noted under the overlap
  flavcham.overlap.eval = data.frame(run = i,
                        model = "overlap",
                        AUC = flavcham.overlap.auc$AUC,
                        TSS = max(flavcham.overlap.tssdf$TSS),
                        tstar = flavcham.overlap.tssdf[flavcham.overlap.tstar, 1],
                        sens_star = flavcham.overlap.tssdf[flavcham.overlap.tstar, 4],
                        spec_star = flavcham.overlap.tssdf[flavcham.overlap.tstar, 5],
                        RMSE = predicts::RMSE(na.omit(values(flavcham.idmnorm)), na.omit(values(flavcham.overlapnorm)), na.rm = T))

  flavcham.idm.eval = data.frame(run = i,
                        model = "IDM",
                        AUC = flavcham.idm.auc$AUC,
                        TSS = max(flavcham.idm.tssdf$TSS),
                        tstar = flavcham.idm.tssdf[flavcham.idm.tstar, 1],
                        sens_star = flavcham.idm.tssdf[flavcham.idm.tstar, 4],
                        spec_star = flavcham.idm.tssdf[flavcham.idm.tstar, 5])
  
  flavcham.evaldf = bind_rows(flavcham.evaldf, flavcham.overlap.eval, flavcham.idm.eval)
  
  # Step 5: Calculate threshold difference
  tstar.overlap = (flavcham.evaldf %>%
    filter(run == i,
           model == "overlap"))$tstar
  overlap.thresh = clamp(flavcham.overlapnorm, lower = tstar.overlap, upper = 1, values = T)
  overlap.thresh[overlap.thresh > tstar.overlap] = 1
  overlap.thresh[overlap.thresh <= tstar.overlap] = 0
  flavcham.overlapthresh[[i]] = overlap.thresh

  tstar.idm = (flavcham.evaldf %>%
    filter(run == i,
           model == "IDM"))$tstar
  idm.thresh = clamp(flavcham.idmnorm, lower = tstar.idm, upper = 1, values = T)
  idm.thresh[idm.thresh > tstar.idm] = 1
  idm.thresh[idm.thresh <= tstar.idm] = 0
  flavcham.idmthresh[[i]] = idm.thresh
  
  shared = overlap.thresh + idm.thresh
  diff = idm.thresh - overlap.thresh
  
  shared.df = data.frame(run = i,
                         n_shared = length(shared[shared == 2]),
                         n_IDM = length(diff[diff == 1]),
                         n_overlap = length(diff[diff == -1])) %>%
    mutate(prop.shared = n_shared/(n_shared + n_IDM + n_overlap),
           prop.idm = n_IDM/(n_shared + n_IDM + n_overlap),
           prop.overlap = n_overlap/(n_shared + n_IDM + n_overlap))
  
  flavcham.thresholddf = bind_rows(flavcham.thresholddf, shared.df)
  
  #   # Step 5: Save Variable Importance
  # idm.vars = data.frame(run = rep(i, 20),
  #                       model = rep("IDM", 20),
  #                       variable = names(flavcham.maxent@results[7:26,]),
  #                       percent = flavcham.maxent@results[7:26],
  #                       permutation = flavcham.maxent@results[27:46])
  # 
  # flavcham.varimpdf = bind_rows(flavcham.varimpdf, idm.vars)
}

write.csv(flavcham.evaldf, file = "completed-evals/flavcham-eval.csv")
write.csv(flavcham.thresholddf, file = "completed-evals/flavcham-threshold.csv")
# write.csv(flavcham.varimpdf, file = "completed-evals/flavcham-varimport.csv")
save(flavcham.overlaplist, file = "flavcham-overlaps.RData")
save(flavcham.idmlist, file = "flavcham-idms.RData")
```

```{r flavrub ensemble}
flavcham.overlap.ensemble <- raster(mean(rast(flavcham.overlaplist[c(1:100)])))
flavcham.overlap.spdf <- as(flavcham.overlap.ensemble, "SpatialPixelsDataFrame")
flavcham.overlap.df <- as.data.frame(flavcham.overlap.spdf)

flavcham.overlap.plot <- ggplot() +
  geom_tile(data = flavcham.overlap.df, aes(x = x, y = y, fill = mean)) +
  coord_cartesian(xlim = c(-130, -110), ylim = c(40, 50)) +
  theme_map() +
  scale_fill_viridis(option = "magma", 
                     limits = c(0, 1))
ggsave("figures/flavcham-overlap.png", flavcham.overlap.plot, width = 6, height = 4, units = "in")

flavcham.idm.ensemble <- raster(mean(rast(flavcham.idmlist[c(1:100)])))
flavcham.idm.spdf <- as(flavcham.idm.ensemble, "SpatialPixelsDataFrame")
flavcham.idm.df <- as.data.frame(flavcham.idm.spdf)

flavcham.idm.plot <- ggplot() +
  geom_tile(data = flavcham.idm.df, aes(x = x, y = y, fill = mean)) +
  coord_cartesian(xlim = c(-130, -110), ylim = c(40, 50)) +
  theme_map() +
  scale_fill_viridis(option = "magma", 
                     limits = c(0, 1))
ggsave("figures/flavcham-idm.png", flavcham.idm.plot, width = 6, height = 4, units = "in")
```

## Cirsium
```{r flav cir data, message = F}
gbif.cir <- gbif %>%
  filter(genus == "Cirsium")

flavcir <- bbna %>%
  filter(species == "flavifrons",
         plant.host.genus == "Cirsium") %>%
  dplyr::select(latitude, longitude, plant.host.genus, date, month, day, year)
```

```{r flavcir maxent for loop, message = F, eval = T, results = "hide"}
flavcir.overlaplist <- vector(mode = "list", length = 100)
flavcir.idmlist <- vector(mode = "list", length = 100)
flavcir.overlapthresh <- vector(mode = "list", length = 100)
flavcir.idmthresh <- vector(mode = "list", length = 100)

flavcir.evaldf <- data.frame()
flavcir.thresholddf <- data.frame()
# flavcir.varimpdf <- data.frame()

set.seed(163190)
for(i in 1:100){
  # Step 1: separate all data into training and testing datasets
  bg <- as.data.frame(spatSample(x = bioclim, size = 10000, method = "random", na.rm = T, xy = T)) %>%
    dplyr::select(x, y) %>%
    rename(longitude = x,
           latitude = y)
  bgfold <- kfold(bg, k = 5)
  bg.test <- bg[bgfold == 1,]
  bg.train <- bg[bgfold != 1,]
  
  flav.longlat <- bbna %>%
    filter(species == "flavifrons",
           plant.host.genus != "Cirsium") %>%
    slice_sample(by = BBNA.code, n = 1) %>%
    dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  flav.fold <- kfold(flav.longlat, k = 5)
  flav.test <- flav.longlat[flav.fold == 1,]
  flav.train <- flav.longlat[flav.fold != 1,]
  
  cir.longlat <- gbif.cir %>%
  dplyr::select(decimalLongitude, decimalLatitude) %>%
  as.data.frame(.) %>%
  rename(longitude = decimalLongitude,
         latitude = decimalLatitude)
  cir.fold <- kfold(cir.longlat, k = 5)
  cir.test <- cir.longlat[cir.fold == 1,]
  cir.train <- cir.longlat[cir.fold != 1,]
  
  flavcir.longlat <- flavcir %>%
  dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  flavcir.fold <- kfold(flavcir.longlat, k = 5)
  flavcir.test <- flavcir.longlat[flavcir.fold == 1,]
  flavcir.train <- flavcir.longlat[flavcir.fold != 1,]
  
  
  
  # Step 2: Calculate overlaps
  ## Step 2a: Individual models
  flav.maxent <- maxent(x = stack(bioclim),
                       p = flav.train, 
                       a = bg.train)
  flav.predict <- dismo::predict(flav.maxent,
                                stack(bioclim))
  
  cir.maxent <- maxent(x = stack(bioclim), 
                       p = cir.train, 
                       a = bg.train)
  cir.predict <- dismo::predict(cir.maxent,
                                stack(bioclim))
  
  ## Step 2b: Multiply bee and plant habitat suitability to get a joint probability
  flavcir.overlap <- as(flav.predict * cir.predict, "SpatRaster")
  flavcir.overlaplist[[i]] = flavcir.overlap
  
  
  
  # Step 3: Calculate IDM
  flavcir.maxent <- maxent(x = stack(bioclim), 
                          p = flavcir.train, 
                          a = bg.train)
  
  flavcir.idm <- as(dismo::predict(flavcir.maxent, stack(bioclim)), "SpatRaster")
  flavcir.idmlist[[i]] = flavcir.idm
  
  
  
  # Step 4: Evaluate overlap model and IDM with the same interaction test data
  ## Step 4a: Normalize rasters
  flavcir.idmnorm = (flavcir.idm - minmax(flavcir.idm)[1,])/(minmax(flavcir.idm)[2,] - minmax(flavcir.idm)[1,])
  flavcir.overlapnorm = (flavcir.overlap - minmax(flavcir.overlap)[1,])/(minmax(flavcir.overlap)[2,] - minmax(flavcir.overlap)[1,])
  
  ## Step 4b: Use modEvA::AUC to get AUC
  flavcir.overlap.auc <- AUC(obs = flavcir.test, pred = flavcir.overlapnorm)
  flavcir.idm.auc <- AUC(obs = flavcir.test, pred = flavcir.idmnorm)
  
  ## Step 4v: Calculate TSS and tstar
  flavcir.overlap.tssdf <- flavcir.overlap.auc$thresholds %>%
    mutate(TSS = sensitivity + specificity - 1)
  flavcir.overlap.tstar <- which.max(flavcir.overlap.tssdf$TSS)
  flavcir.idm.tssdf <- flavcir.idm.auc$thresholds %>%
    mutate(TSS = sensitivity + specificity - 1)
  flavcir.idm.tstar <- which.max(flavcir.idm.tssdf$TSS)
  
  ## Step 4d: Save evaluation scores
  ### Note: RMSE is the same for both so it is only noted under the overlap
  flavcir.overlap.eval = data.frame(run = i,
                        model = "overlap",
                        AUC = flavcir.overlap.auc$AUC,
                        TSS = max(flavcir.overlap.tssdf$TSS),
                        tstar = flavcir.overlap.tssdf[flavcir.overlap.tstar, 1],
                        sens_star = flavcir.overlap.tssdf[flavcir.overlap.tstar, 4],
                        spec_star = flavcir.overlap.tssdf[flavcir.overlap.tstar, 5],
                        RMSE = predicts::RMSE(na.omit(values(flavcir.idmnorm)), na.omit(values(flavcir.overlapnorm)), na.rm = T))

  flavcir.idm.eval = data.frame(run = i,
                        model = "IDM",
                        AUC = flavcir.idm.auc$AUC,
                        TSS = max(flavcir.idm.tssdf$TSS),
                        tstar = flavcir.idm.tssdf[flavcir.idm.tstar, 1],
                        sens_star = flavcir.idm.tssdf[flavcir.idm.tstar, 4],
                        spec_star = flavcir.idm.tssdf[flavcir.idm.tstar, 5])
  
  flavcir.evaldf = bind_rows(flavcir.evaldf, flavcir.overlap.eval, flavcir.idm.eval)
  
  # Step 5: Calculate threshold difference
  tstar.overlap = (flavcir.evaldf %>%
    filter(run == i,
           model == "overlap"))$tstar
  overlap.thresh = clamp(flavcir.overlapnorm, lower = tstar.overlap, upper = 1, values = T)
  overlap.thresh[overlap.thresh > tstar.overlap] = 1
  overlap.thresh[overlap.thresh <= tstar.overlap] = 0
  flavcir.overlapthresh[[i]] = overlap.thresh
  
  tstar.idm = (flavcir.evaldf %>%
    filter(run == i,
           model == "IDM"))$tstar
  idm.thresh = clamp(flavcir.idmnorm, lower = tstar.idm, upper = 1, values = T)
  idm.thresh[idm.thresh > tstar.idm] = 1
  idm.thresh[idm.thresh <= tstar.idm] = 0
  flavcir.idmthresh[[i]] = idm.thresh
  
  shared = overlap.thresh + idm.thresh
  diff = idm.thresh - overlap.thresh
  
  shared.df = data.frame(run = i,
                         n_shared = length(shared[shared == 2]),
                         n_IDM = length(diff[diff == 1]),
                         n_overlap = length(diff[diff == -1])) %>%
    mutate(prop.shared = n_shared/(n_shared + n_IDM + n_overlap),
           prop.idm = n_IDM/(n_shared + n_IDM + n_overlap),
           prop.overlap = n_overlap/(n_shared + n_IDM + n_overlap))
  
  flavcir.thresholddf = bind_rows(flavcir.thresholddf, shared.df)
  
  #   # Step 5: Save Variable Importance
  # idm.vars = data.frame(run = rep(i, 20),
  #                       model = rep("IDM", 20),
  #                       variable = names(flavcir.maxent@results[7:26,]),
  #                       percent = flavcir.maxent@results[7:26],
  #                       permutation = flavcir.maxent@results[27:46])
  # 
  # flavcir.varimpdf = bind_rows(flavcir.varimpdf, idm.vars)
}

write.csv(flavcir.evaldf, file = "completed-evals/flavcir-eval.csv")
write.csv(flavcir.thresholddf, file = "completed-evals/flavcir-threshold.csv")
# write.csv(flavcir.varimpdf, file = "completed-evals/flavcir-varimport.csv")
save(flavcir.overlaplist, file = "flavcir-overlaps.RData")
save(flavcir.idmlist, file = "flavcir-idms.RData")
```

```{r flavcir ensemble}
flavcir.overlap.ensemble <- raster(mean(rast(flavcir.overlaplist[c(1:100)])))
flavcir.overlap.spdf <- as(flavcir.overlap.ensemble, "SpatialPixelsDataFrame")
flavcir.overlap.df <- as.data.frame(flavcir.overlap.spdf)

flavcir.overlap.plot <- ggplot() +
  geom_tile(data = flavcir.overlap.df, aes(x = x, y = y, fill = mean)) +
  coord_cartesian(xlim = c(-130, -110), ylim = c(40, 50)) +
  theme_map() +
  scale_fill_viridis(option = "magma", 
                     limits = c(0, 1))
ggsave("figures/flavcir-overlap.png", flavcir.overlap.plot, width = 6, height = 4, units = "in")

flavcir.idm.ensemble <- raster(mean(rast(flavcir.idmlist[c(1:100)])))
flavcir.idm.spdf <- as(flavcir.idm.ensemble, "SpatialPixelsDataFrame")
flavcir.idm.df <- as.data.frame(flavcir.idm.spdf)

flavcir.idm.plot <- ggplot() +
  geom_tile(data = flavcir.idm.df, aes(x = x, y = y, fill = mean)) +
  coord_cartesian(xlim = c(-130, -110), ylim = c(40, 50)) +
  theme_map() +
  scale_fill_viridis(option = "magma", 
                     limits = c(0, 1))
ggsave("figures/flavcir-idm.png", flavcir.idm.plot, width = 6, height = 4, units = "in")
```

## Lupinus

```{r flav lup data, message = F}
gbif.lup <- gbif %>%
  filter(genus == "Lupinus")

flavlup <- bbna %>% 
  filter(species == "flavifrons",
         plant.host.genus == "Lupinus") %>%
  dplyr::select(latitude, longitude, plant.host.genus, date, month, day, year)
```

```{r flavlup maxent for loop, message = F, eval = T, results = "hide"}
flavlup.overlaplist <- vector(mode = "list", length = 100)
flavlup.idmlist <- vector(mode = "list", length = 100)
flavlup.overlapthresh <- vector(mode = "list", length = 100)
flavlup.idmthresh <- vector(mode = "list", length = 100)

flavlup.evaldf <- data.frame()
flavlup.thresholddf <- data.frame()
# flavlup.varimpdf <- data.frame()

set.seed(11624)
for(i in 1:100){
  # Step 1: separate all data into training and testing datasets
  bg <- as.data.frame(spatSample(x = bioclim, size = 10000, method = "random", na.rm = T, xy = T)) %>%
    dplyr::select(x, y) %>%
    rename(longitude = x,
           latitude = y)
  bgfold <- kfold(bg, k = 5)
  bg.test <- bg[bgfold == 1,]
  bg.train <- bg[bgfold != 1,]
  
  flav.longlat <- bbna %>%
    filter(species == "flavifrons",
           plant.host.genus != "Lupinus") %>%
    slice_sample(by = BBNA.code, n = 1) %>%
    dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  flav.fold <- kfold(flav.longlat, k = 5)
  flav.test <- flav.longlat[flav.fold == 1,]
  flav.train <- flav.longlat[flav.fold != 1,]
  
  lup.longlat <- gbif.lup %>%
  dplyr::select(decimalLongitude, decimalLatitude) %>%
  as.data.frame(.) %>%
  rename(longitude = decimalLongitude,
         latitude = decimalLatitude)
  lup.fold <- kfold(lup.longlat, k = 5)
  lup.test <- lup.longlat[lup.fold == 1,]
  lup.train <- lup.longlat[lup.fold != 1,]
  
  flavlup.longlat <- flavlup %>%
  dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  flavlup.fold <- kfold(flavlup.longlat, k = 5)
  flavlup.test <- flavlup.longlat[flavlup.fold == 1,]
  flavlup.train <- flavlup.longlat[flavlup.fold != 1,]

  
  
  # Step 2: Calculate overlaps
  ## Step 2a: Individual models
  flav.maxent <- maxent(x = stack(bioclim),
                       p = flav.train, 
                       a = bg.train)
  flav.predict <- dismo::predict(flav.maxent,
                                stack(bioclim))
  
  lup.maxent <- maxent(x = stack(bioclim), 
                       p = lup.train, 
                       a = bg.train)
  lup.predict <- dismo::predict(lup.maxent,
                                stack(bioclim))
  
  ## Step 2b: Multiply bee and plant habitat suitability to get a joint probability
  flavlup.overlap <- as(flav.predict * lup.predict, "SpatRaster")
  flavlup.overlaplist[[i]] = flavlup.overlap
  
  
  
  # Step 3: Calculate IDM
  flavlup.maxent <- maxent(x = stack(bioclim), 
                          p = flavlup.train, 
                          a = bg.train)
  
  flavlup.idm <- as(dismo::predict(flavlup.maxent, stack(bioclim)), "SpatRaster")
  flavlup.idmlist[[i]] = flavlup.idm
  
  
  
  # Step 4: Evaluate overlap model and IDM with the same interaction test data
  ## Step 4a: Normalize rasters
  flavlup.idmnorm = (flavlup.idm - minmax(flavlup.idm)[1,])/(minmax(flavlup.idm)[2,] - minmax(flavlup.idm)[1,])
  flavlup.overlapnorm = (flavlup.overlap - minmax(flavlup.overlap)[1,])/(minmax(flavlup.overlap)[2,] - minmax(flavlup.overlap)[1,])
  
    ## Step 4b: Use modEvA::AUC to get AUC
  flavlup.overlap.auc <- AUC(obs = flavlup.test, pred = flavlup.overlapnorm)
  flavlup.idm.auc <- AUC(obs = flavlup.test, pred = flavlup.idmnorm)
  
  ## Step 4c: Calculate TSS and tstar
  flavlup.overlap.tssdf <- flavlup.overlap.auc$thresholds %>%
    mutate(TSS = sensitivity + specificity - 1)
  flavlup.overlap.tstar <- which.max(flavlup.overlap.tssdf$TSS)
  flavlup.idm.tssdf <- flavlup.idm.auc$thresholds %>%
    mutate(TSS = sensitivity + specificity - 1)
  flavlup.idm.tstar <- which.max(flavlup.idm.tssdf$TSS)
  
  ## Step 4d: Save evaluation scores
  ### Note: RMSE is the same for both so it is only noted under the overlap
  flavlup.overlap.eval = data.frame(run = i,
                        model = "overlap",
                        AUC = flavlup.overlap.auc$AUC,
                        TSS = max(flavlup.overlap.tssdf$TSS),
                        tstar = flavcham.overlap.tssdf[flavlup.overlap.tstar, 1],
                        sens_star = flavlup.overlap.tssdf[flavlup.overlap.tstar, 4],
                        spec_star = flavlup.overlap.tssdf[flavlup.overlap.tstar, 5],
                        RMSE = predicts::RMSE(na.omit(values(flavlup.idmnorm)), na.omit(values(flavlup.overlapnorm)), na.rm = T))

  flavlup.idm.eval = data.frame(run = i,
                        model = "IDM",
                        AUC = flavlup.idm.auc$AUC,
                        TSS = max(flavlup.idm.tssdf$TSS),
                        tstar = flavlup.idm.tssdf[flavlup.idm.tstar, 1],
                        sens_star = flavlup.idm.tssdf[flavlup.idm.tstar, 4],
                        spec_star = flavlup.idm.tssdf[flavlup.idm.tstar, 5])
  
  flavlup.evaldf = bind_rows(flavlup.evaldf, flavlup.overlap.eval, flavlup.idm.eval)
  
  # Step 5: Calculate threshold difference
  tstar.overlap = (flavlup.evaldf %>%
    filter(run == i,
           model == "overlap"))$tstar
  overlap.thresh = clamp(flavlup.overlapnorm, lower = tstar.overlap, upper = 1, values = T)
  overlap.thresh[overlap.thresh > tstar.overlap] = 1
  overlap.thresh[overlap.thresh <= tstar.overlap] = 0
  flavlup.overlapthresh[[i]] = overlap.thresh
  
  tstar.idm = (flavlup.evaldf %>%
    filter(run == i,
           model == "IDM"))$tstar
  idm.thresh = clamp(flavlup.idmnorm, lower = tstar.idm, upper = 1, values = T)
  idm.thresh[idm.thresh > tstar.idm] = 1
  idm.thresh[idm.thresh <= tstar.idm] = 0
  flavlup.idmthresh[[i]] = idm.thresh
  
  shared = overlap.thresh + idm.thresh
  diff = idm.thresh - overlap.thresh
  
  shared.df = data.frame(run = i,
                         n_shared = length(shared[shared == 2]),
                         n_IDM = length(diff[diff == 1]),
                         n_overlap = length(diff[diff == -1])) %>%
    mutate(prop.shared = n_shared/(n_shared + n_IDM + n_overlap),
           prop.idm = n_IDM/(n_shared + n_IDM + n_overlap),
           prop.overlap = n_overlap/(n_shared + n_IDM + n_overlap))
  
  flavlup.thresholddf = bind_rows(flavlup.thresholddf, shared.df)
  
  #   # Step 5: Save Variable Importance
  # idm.vars = data.frame(run = rep(i, 20),
  #                       model = rep("IDM", 20),
  #                       variable = names(flavlup.maxent@results[7:26,]),
  #                       percent = flavlup.maxent@results[7:26],
  #                       permutation = flavlup.maxent@results[27:46])
  # 
  # flavlup.varimpdf = bind_rows(flavlup.varimpdf, idm.vars)
}

write.csv(flavlup.evaldf, file = "completed-evals/flavlup-eval.csv")
write.csv(flavlup.thresholddf, file = "completed-evals/flavlup-threshold.csv")
# write.csv(flavlup.varimpdf, file = "completed-evals/flavlup-varimport.csv")
save(flavlup.overlaplist, file = "flavlup-overlaps.RData")
save(flavlup.idmlist, file = "flavlup-idms.RData")
```

```{r flavlup ensemble}
flavlup.overlap.ensemble <- raster(mean(rast(flavlup.overlaplist[c(1:100)])))
flavlup.overlap.spdf <- as(flavlup.overlap.ensemble, "SpatialPixelsDataFrame")
flavlup.overlap.df <- as.data.frame(flavlup.overlap.spdf)

flavlup.overlap.plot <- ggplot() +
  geom_tile(data = flavlup.overlap.df, aes(x = x, y = y, fill = mean)) +
  coord_cartesian(xlim = c(-130, -110), ylim = c(40, 50)) +
  theme_map() +
  scale_fill_viridis(option = "magma", 
                     limits = c(0, 1))
ggsave("figures/flavlup-overlap.png", flavlup.overlap.plot, width = 6, height = 4, units = "in")

flavlup.idm.ensemble <- raster(mean(rast(flavlup.idmlist[c(1:100)])))
flavlup.idm.spdf <- as(flavlup.idm.ensemble, "SpatialPixelsDataFrame")
flavlup.idm.df <- as.data.frame(flavlup.idm.spdf)

flavlup.idm.plot <- ggplot() +
  geom_tile(data = flavlup.idm.df, aes(x = x, y = y, fill = mean)) +
  coord_cartesian(xlim = c(-130, -110), ylim = c(40, 50)) +
  theme_map() +
  scale_fill_viridis(option = "magma", 
                     limits = c(0, 1))
ggsave("figures/flavlup-idm.png", flavlup.idm.plot, width = 6, height = 4, units = "in")
```

## Penstemon
```{r flav pen data, message = F}
gbif.pen <- gbif %>%
  filter(genus == "Penstemon")

flavpen <- bbna %>% 
  filter(species == "flavifrons",
         plant.host.genus == "Penstemon") %>%
  dplyr::select(latitude, longitude, plant.host.genus, date, month, day, year)
```

```{r flavpen maxent for loop, message = F, eval = T, results = "hide"}
flavpen.overlaplist <- vector(mode = "list", length = 100)
flavpen.idmlist <- vector(mode = "list", length = 100)
flavpen.overlapthresh <- vector(mode = "list", length = 100)
flavpen.idmthresh <- vector(mode = "list", length = 100)

flavpen.evaldf <- data.frame()
flavpen.thresholddf <- data.frame()
# flavpen.varimpdf <- data.frame()

set.seed(11124)
for(i in 1:100){
  # Step 1: separate all data into training and testing datasets
  bg <- as.data.frame(spatSample(x = bioclim, size = 10000, method = "random", na.rm = T, xy = T)) %>%
    dplyr::select(x, y) %>%
    rename(longitude = x,
           latitude = y)
  bgfold <- kfold(bg, k = 5)
  bg.test <- bg[bgfold == 1,]
  bg.train <- bg[bgfold != 1,]
  
  flav.longlat <- bbna %>%
    filter(species == "flavifrons",
           plant.host.genus != "Penstemon") %>%
    slice_sample(by = BBNA.code, n = 1) %>%
    dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  flav.fold <- kfold(flav.longlat, k = 5)
  flav.test <- flav.longlat[flav.fold == 1,]
  flav.train <- flav.longlat[flav.fold != 1,]
  
  pen.longlat <- gbif.pen %>%
  dplyr::select(decimalLongitude, decimalLatitude) %>%
  as.data.frame(.) %>%
  rename(longitude = decimalLongitude,
         latitude = decimalLatitude)
  pen.fold <- kfold(pen.longlat, k = 5)
  pen.test <- pen.longlat[pen.fold == 1,]
  pen.train <- pen.longlat[pen.fold != 1,]
  
  flavpen.longlat <- flavpen %>%
  dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  flavpen.fold <- kfold(flavpen.longlat, k = 5)
  flavpen.test <- flavpen.longlat[flavpen.fold == 1,]
  flavpen.train <- flavpen.longlat[flavpen.fold != 1,]

  
  
  # Step 2: Calculate overlaps
  ## Step 2a: Individual models
  flav.maxent <- maxent(x = stack(bioclim),
                       p = flav.train, 
                       a = bg.train)
  flav.predict <- dismo::predict(flav.maxent,
                                stack(bioclim))
  
  pen.maxent <- maxent(x = stack(bioclim), 
                       p = pen.train, 
                       a = bg.train)
  pen.predict <- dismo::predict(pen.maxent,
                                stack(bioclim))
  
  ## Step 2b: Multiply bee and plant habitat suitability to get a joint probability
  flavpen.overlap <- as(flav.predict * pen.predict, "SpatRaster")
  flavpen.overlaplist[[i]] = flavpen.overlap
  
  
  
  # Step 3: Calculate IDM
  flavpen.maxent <- maxent(x = stack(bioclim), 
                          p = flavpen.train, 
                          a = bg.train)
  
  flavpen.idm <- as(dismo::predict(flavpen.maxent, stack(bioclim)), "SpatRaster")
  flavpen.idmlist[[i]] = flavpen.idm
  
  
  
  # Step 4: Evaluate overlap model and IDM with the same interaction test data
  ## Step 4a: Normalize rasters for RMSE calculation
  flavpen.idmnorm = (flavpen.idm - minmax(flavpen.idm)[1,])/(minmax(flavpen.idm)[2,] - minmax(flavpen.idm)[1,])
  flavpen.overlapnorm = (flavpen.overlap - minmax(flavpen.overlap)[1,])/(minmax(flavpen.overlap)[2,] - minmax(flavpen.overlap)[1,])
  
  ## Step 4b: Use modEvA::AUC to get AUC
  flavpen.overlap.auc <- AUC(obs = flavpen.test, pred = flavpen.overlapnorm)
  flavpen.idm.auc <- AUC(obs = flavpen.test, pred = flavpen.idmnorm)
  
  ## Step 4c: Calculate TSS and tstar
  flavpen.overlap.tssdf <- flavpen.overlap.auc$thresholds %>%
    mutate(TSS = sensitivity + specificity - 1)
  flavpen.overlap.tstar <- which.max(flavpen.overlap.tssdf$TSS)
  flavpen.idm.tssdf <- flavpen.idm.auc$thresholds %>%
    mutate(TSS = sensitivity + specificity - 1)
  flavpen.idm.tstar <- which.max(flavpen.idm.tssdf$TSS)
  
  ## Step 4d: Save evaluation scores
  ### Note: RMSE is the same for both so it is only noted under the overlap
  flavpen.overlap.eval = data.frame(run = i,
                        model = "overlap",
                        AUC = flavpen.overlap.auc$AUC,
                        TSS = max(flavpen.overlap.tssdf$TSS),
                        tstar = flavpen.overlap.tssdf[flavpen.overlap.tstar, 1],
                        sens_star = flavpen.overlap.tssdf[flavpen.overlap.tstar, 4],
                        spec_star = flavpen.overlap.tssdf[flavpen.overlap.tstar, 5],
                        RMSE = predicts::RMSE(na.omit(values(flavpen.idmnorm)), na.omit(values(flavpen.overlapnorm)), na.rm = T))

  flavpen.idm.eval = data.frame(run = i,
                        model = "IDM",
                        AUC = flavpen.idm.auc$AUC,
                        TSS = max(flavpen.idm.tssdf$TSS),
                        tstar = flavpen.idm.tssdf[flavpen.idm.tstar, 1],
                        sens_star = flavpen.idm.tssdf[flavpen.idm.tstar, 4],
                        spec_star = flavpen.idm.tssdf[flavpen.idm.tstar, 5])
  
  flavpen.evaldf = bind_rows(flavpen.evaldf, flavpen.overlap.eval, flavpen.idm.eval)
  
  # Step 5: Calculate threshold difference
  tstar.overlap = (flavpen.evaldf %>%
    filter(run == i,
           model == "overlap"))$tstar
  overlap.thresh = clamp(flavpen.overlapnorm, lower = tstar.overlap, upper = 1, values = T)
  overlap.thresh[overlap.thresh > tstar.overlap] = 1
  overlap.thresh[overlap.thresh <= tstar.overlap] = 0
  flavpen.overlapthresh[[i]] = overlap.thresh
  
  tstar.idm = (flavpen.evaldf %>%
    filter(run == i,
           model == "IDM"))$tstar
  idm.thresh = clamp(flavpen.idmnorm, lower = tstar.idm, upper = 1, values = T)
  idm.thresh[idm.thresh > tstar.idm] = 1
  idm.thresh[idm.thresh <= tstar.idm] = 0
  flavpen.idmthresh[[i]] = idm.thresh
  
  shared = overlap.thresh + idm.thresh
  diff = idm.thresh - overlap.thresh
  
  shared.df = data.frame(run = i,
                         n_shared = length(shared[shared == 2]),
                         n_IDM = length(diff[diff == 1]),
                         n_overlap = length(diff[diff == -1])) %>%
    mutate(prop.shared = n_shared/(n_shared + n_IDM + n_overlap),
           prop.idm = n_IDM/(n_shared + n_IDM + n_overlap),
           prop.overlap = n_overlap/(n_shared + n_IDM + n_overlap))
  
  flavpen.thresholddf = bind_rows(flavpen.thresholddf, shared.df)
  
  #   # Step 5: Save Variable Importance
  # idm.vars = data.frame(run = rep(i, 20),
  #                       model = rep("IDM", 20),
  #                       variable = names(flavpen.maxent@results[7:26,]),
  #                       percent = flavpen.maxent@results[7:26],
  #                       permutation = flavpen.maxent@results[27:46])
  # 
  # flavpen.varimpdf = bind_rows(flavpen.varimpdf, idm.vars)
}

write.csv(flavpen.evaldf, file = "completed-evals/flavpen-eval.csv")
write.csv(flavpen.thresholddf, file = "completed-evals/flavpen-threshold.csv")
# write.csv(flavpen.varimpdf, file = "completed-evals/flavpen-varimport.csv")
save(flavpen.overlaplist, file = "flavpen-overlaps.RData")
save(flavpen.idmlist, file = "flavpen-idms.RData")
```

```{r flavpen ensemble}
flavpen.overlap.ensemble <- raster(mean(rast(flavpen.overlaplist[c(1:100)])))
flavpen.overlap.spdf <- as(flavpen.overlap.ensemble, "SpatialPixelsDataFrame")
flavpen.overlap.df <- as.data.frame(flavpen.overlap.spdf)

flavpen.overlap.plot <- ggplot() +
  geom_tile(data = flavpen.overlap.df, aes(x = x, y = y, fill = mean)) +
  coord_cartesian(xlim = c(-130, -110), ylim = c(40, 50)) +
  theme_map() +
  scale_fill_viridis(option = "magma", 
                     limits = c(0, 1))
ggsave("figures/flavpen-overlap.png", flavpen.overlap.plot, width = 6, height = 4, units = "in")

flavpen.idm.ensemble <- raster(mean(rast(flavpen.idmlist[c(1:100)])))
flavpen.idm.spdf <- as(flavpen.idm.ensemble, "SpatialPixelsDataFrame")
flavpen.idm.df <- as.data.frame(flavpen.idm.spdf)

flavpen.idm.plot <- ggplot() +
  geom_tile(data = flavpen.idm.df, aes(x = x, y = y, fill = mean)) +
  coord_cartesian(xlim = c(-130, -110), ylim = c(40, 50)) +
  theme_map() +
  scale_fill_viridis(option = "magma", 
                     limits = c(0, 1))
ggsave("figures/flavpen-idm.png", flavpen.idm.plot, width = 6, height = 4, units = "in")
```

## Rubus
```{r flav rub data, message = F}
gbif.rub <- gbif %>%
  filter(genus == "Rubus")

flavrub <- bbna %>%
  filter(species == "flavifrons",
         plant.host.genus == "Rubus") %>%
  dplyr::select(latitude, longitude, plant.host.genus, date, month, day, year)
```

```{r flavrub maxent for loop, message = F}
flavrub.overlaplist <- vector(mode = "list", length = 100)
flavrub.idmlist <- vector(mode = "list", length = 100)
flavrub.overlapthresh <- vector(mode = "list", length = 100)
flavrub.idmthresh <- vector(mode = "list", length = 100)

flavrub.evaldf <- data.frame()
flavrub.thresholddf <- data.frame()
# flavrub.varimpdf <- data.frame()

set.seed(160124)
for(i in 1:100){
  # Step 1: separate all data into training and testing datasets
  bg <- as.data.frame(spatSample(x = bioclim, size = 10000, method = "random", na.rm = T, xy = T)) %>%
    dplyr::select(x, y) %>%
    rename(longitude = x,
           latitude = y)
  bgfold <- kfold(bg, k = 5)
  bg.test <- bg[bgfold == 1,]
  bg.train <- bg[bgfold != 1,]
  
  flav.longlat <- bbna %>%
    filter(species == "flavifrons",
           plant.host.genus != "Rubus") %>%
    slice_sample(by = BBNA.code, n = 1) %>%
    dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  flav.fold <- kfold(flav.longlat, k = 5)
  flav.test <- flav.longlat[flav.fold == 1,]
  flav.train <- flav.longlat[flav.fold != 1,]
  
  rub.longlat <- gbif.rub %>%
  dplyr::select(decimalLongitude, decimalLatitude) %>%
  as.data.frame(.) %>%
  rename(longitude = decimalLongitude,
         latitude = decimalLatitude)
  rub.fold <- kfold(rub.longlat, k = 5)
  rub.test <- rub.longlat[rub.fold == 1,]
  rub.train <- rub.longlat[rub.fold != 1,]
  
  flavrub.longlat <- flavrub %>%
  dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  flavrub.fold <- kfold(flavrub.longlat, k = 5)
  flavrub.test <- flavrub.longlat[flavrub.fold == 1,]
  flavrub.train <- flavrub.longlat[flavrub.fold != 1,]
  
  
  
  # Step 2: Calculate overlaps
  ## Step 2a: Individual models
  flav.maxent <- maxent(x = stack(bioclim),
                       p = flav.train, 
                       a = bg.train)
  flav.predict <- dismo::predict(flav.maxent,
                                stack(bioclim))
  
  rub.maxent <- maxent(x = stack(bioclim), 
                       p = rub.train, 
                       a = bg.train)
  rub.predict <- dismo::predict(rub.maxent,
                                stack(bioclim))
  
  ## Step 2b: Multiply bee and plant habitat suitability to get a joint probability
  flavrub.overlap <- as(flav.predict * rub.predict, "SpatRaster")
  flavrub.overlaplist[[i]] = flavrub.overlap
  
  
  
  # Step 3: Calculate IDM
  flavrub.maxent <- maxent(x = stack(bioclim), 
                          p = flavrub.train, 
                          a = bg.train)
  
  flavrub.idm <- as(dismo::predict(flavrub.maxent, stack(bioclim)), "SpatRaster")
  flavrub.idmlist[[i]] = flavrub.idm
  
  
  
  # Step 4: Evaluate overlap model and IDM with the same interaction test data
  ## Step 4a: Normalize rasters
  flavrub.idmnorm = (flavrub.idm - minmax(flavrub.idm)[1,])/(minmax(flavrub.idm)[2,] - minmax(flavrub.idm)[1,])
  flavrub.overlapnorm = (flavrub.overlap - minmax(flavrub.overlap)[1,])/(minmax(flavrub.overlap)[2,] - minmax(flavrub.overlap)[1,])
  
  ## Step 4b: Use modEvA::AUC to get AUC
  flavrub.overlap.auc <- AUC(obs = flavrub.test, pred = flavrub.overlapnorm)
  flavrub.idm.auc <- AUC(obs = flavrub.test, pred = flavrub.idmnorm)
  
  ## Step 4c: Calculate TSS and tstar
  flavrub.overlap.tssdf <- flavrub.overlap.auc$thresholds %>%
    mutate(TSS = sensitivity + specificity - 1)
  flavrub.overlap.tstar <- which.max(flavrub.overlap.tssdf$TSS)
  flavrub.idm.tssdf <- flavrub.idm.auc$thresholds %>%
    mutate(TSS = sensitivity + specificity - 1)
  flavrub.idm.tstar <- which.max(flavrub.idm.tssdf$TSS)
  
  ## Step 4d: Save evaluation scores
  ### Note: RMSE is the same for both so it is only noted under the overlap
  flavrub.overlap.eval = data.frame(run = i,
                        model = "overlap",
                        AUC = flavrub.overlap.auc$AUC,
                        TSS = max(flavrub.overlap.tssdf$TSS),
                        tstar = flavrub.overlap.tssdf[flavrub.overlap.tstar, 1],
                        sens_star = flavrub.overlap.tssdf[flavrub.overlap.tstar, 4],
                        spec_star = flavrub.overlap.tssdf[flavrub.overlap.tstar, 5],
                        RMSE = predicts::RMSE(na.omit(values(flavrub.idmnorm)), na.omit(values(flavrub.overlapnorm)), na.rm = T))

  flavrub.idm.eval = data.frame(run = i,
                        model = "IDM",
                        AUC = flavrub.idm.auc$AUC,
                        TSS = max(flavrub.idm.tssdf$TSS),
                        tstar = flavrub.idm.tssdf[flavrub.idm.tstar, 1],
                        sens_star = flavrub.idm.tssdf[flavrub.idm.tstar, 4],
                        spec_star = flavrub.idm.tssdf[flavrub.idm.tstar, 5])
  
  flavrub.evaldf = bind_rows(flavrub.evaldf, flavrub.overlap.eval, flavrub.idm.eval)

  # Step 5: Calculate threshold difference
  tstar.overlap = (flavrub.evaldf %>%
    filter(run == i,
           model == "overlap"))$tstar
  overlap.thresh = clamp(flavrub.overlapnorm, lower = tstar.overlap, upper = 1, values = T)
  overlap.thresh[overlap.thresh > tstar.overlap] = 1
  overlap.thresh[overlap.thresh <= tstar.overlap] = 0
  flavrub.overlapthresh[[i]] = overlap.thresh
  
  tstar.idm = (flavrub.evaldf %>%
    filter(run == i,
           model == "IDM"))$tstar
  idm.thresh = clamp(flavrub.idmnorm, lower = tstar.idm, upper = 1, values = T)
  idm.thresh[idm.thresh > tstar.idm] = 1
  idm.thresh[idm.thresh <= tstar.idm] = 0
  flavrub.idmthresh[[i]] = idm.thresh
  
  shared = overlap.thresh + idm.thresh
  diff = idm.thresh - overlap.thresh
  
  shared.df = data.frame(run = i,
                         n_shared = length(shared[shared == 2]),
                         n_IDM = length(diff[diff == 1]),
                         n_overlap = length(diff[diff == -1])) %>%
    mutate(prop.shared = n_shared/(n_shared + n_IDM + n_overlap),
           prop.idm = n_IDM/(n_shared + n_IDM + n_overlap),
           prop.overlap = n_overlap/(n_shared + n_IDM + n_overlap))
  
  flavrub.thresholddf = bind_rows(flavrub.thresholddf, shared.df)
    
  #   # Step 5: Save Variable Importance
  # idm.vars = data.frame(run = rep(i, 20),
  #                       model = rep("IDM", 20),
  #                       variable = names(flavrub.maxent@results[7:26,]),
  #                       percent = flavrub.maxent@results[7:26],
  #                       permutation = flavrub.maxent@results[27:46])
  # 
  # flavrub.varimpdf = bind_rows(flavrub.varimpdf, idm.vars)
}

write.csv(flavrub.evaldf, file = "completed-evals/flavrub-eval.csv")
write.csv(flavrub.thresholddf, file = "completed-evals/flavrub-threshold.csv")
# write.csv(flavrub.varimpdf, file = "completed-evals/flavrub-varimport.csv")
save(flavrub.overlaplist, file = "flavrub-overlaps.RData")
save(flavrub.idmlist, file = "flavrub-idms.RData")
```

```{r flavrub ensemble}
flavrub.overlap.ensemble <- raster(mean(rast(flavrub.overlaplist[c(1:100)])))
flavrub.overlap.spdf <- as(flavrub.overlap.ensemble, "SpatialPixelsDataFrame")
flavrub.overlap.df <- as.data.frame(flavrub.overlap.spdf)

flavrub.overlap.plot <- ggplot() +
  geom_tile(data = flavrub.overlap.df, aes(x = x, y = y, fill = mean)) +
  coord_cartesian(xlim = c(-130, -110), ylim = c(40, 50)) +
  theme_map() +
  scale_fill_viridis(option = "magma", 
                     limits = c(0, 1))
ggsave("figures/flavrub-overlap.png", flavrub.overlap.plot, width = 6, height = 4, units = "in")

flavrub.idm.ensemble <- raster(mean(rast(flavrub.idmlist[c(1:100)])))
flavrub.idm.spdf <- as(flavrub.idm.ensemble, "SpatialPixelsDataFrame")
flavrub.idm.df <- as.data.frame(flavrub.idm.spdf)

flavrub.idm.plot <- ggplot() +
  geom_tile(data = flavrub.idm.df, aes(x = x, y = y, fill = mean)) +
  coord_cartesian(xlim = c(-130, -110), ylim = c(40, 50)) +
  theme_map() +
  scale_fill_viridis(option = "magma", 
                     limits = c(0, 1))
ggsave("figures/flavrub-idm.png", flavrub.idm.plot, width = 6, height = 4, units = "in")
```

# Mixtus
## Chamaenerion

```{r mix cham data, message = F}
gbif.cham <- gbif %>%
  filter(genus == "Chamaenerion")

mixcham <- bbna %>%
  filter(species == "mixtus",
         plant.host.genus == "Chamaenerion") %>%
  dplyr::select(latitude, longitude, plant.host.genus, date, month, day, year)
```

```{r mixcham maxent for loop, message = F}
mixcham.overlaplist <- vector(mode = "list", length = 100)
mixcham.idmlist <- vector(mode = "list", length = 100)
mixcham.overlapthresh <- vector(mode = "list", length = 100)
mixcham.idmthresh <- vector(mode = "list", length = 100)

mixcham.evaldf <- data.frame()
mixcham.thresholddf <- data.frame()
# mixcham.varimpdf <- data.frame()

set.seed(51445)
for(i in 1:100){
  # Step 1: separate all data into training and testing datasets
  bg <- as.data.frame(spatSample(x = bioclim, size = 10000, method = "random", na.rm = T, xy = T)) %>%
    dplyr::select(x, y) %>%
    rename(longitude = x,
           latitude = y)
  bgfold <- kfold(bg, k = 5)
  bg.test <- bg[bgfold == 1,]
  bg.train <- bg[bgfold != 1,]
  
  mix.longlat <- bbna %>%
    filter(species == "mixtus",
           plant.host.genus != "Chamaenerion") %>%
    slice_sample(by = BBNA.code, n = 1) %>%
    dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  mix.fold <- kfold(mix.longlat, k = 5)
  mix.test <- mix.longlat[mix.fold == 1,]
  mix.train <- mix.longlat[mix.fold != 1,]
  
  cham.longlat <- gbif.cham %>%
  dplyr::select(decimalLongitude, decimalLatitude) %>%
  as.data.frame(.) %>%
  rename(longitude = decimalLongitude,
         latitude = decimalLatitude)
  cham.fold <- kfold(cham.longlat, k = 5)
  cham.test <- cham.longlat[cham.fold == 1,]
  cham.train <- cham.longlat[cham.fold != 1,]
  
  mixcham.longlat <- mixcham %>%
  dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  mixcham.fold <- kfold(mixcham.longlat, k = 5)
  mixcham.test <- mixcham.longlat[mixcham.fold == 1,]
  mixcham.train <- mixcham.longlat[mixcham.fold != 1,]
  
  
  
  # Step 2: Calculate overlaps
  ## Step 2a: Individual models
  mix.maxent <- maxent(x = stack(bioclim),
                       p = mix.train, 
                       a = bg.train)
  mix.predict <- dismo::predict(mix.maxent,
                                stack(bioclim))
  
  cham.maxent <- maxent(x = stack(bioclim), 
                       p = cham.train, 
                       a = bg.train)
  cham.predict <- dismo::predict(cham.maxent,
                                stack(bioclim))
  
  ## Step 2b: Multiply bee and plant habitat suitability to get a joint probability
  mixcham.overlap <- as(mix.predict * cham.predict, "SpatRaster")
  mixcham.overlaplist[[i]] = mixcham.overlap
  
  
  
  # Step 3: Calculate IDM
  mixcham.maxent <- maxent(x = stack(bioclim), 
                          p = mixcham.train, 
                          a = bg.train)
  
  mixcham.idm <- as(dismo::predict(mixcham.maxent, stack(bioclim)), "SpatRaster")
  mixcham.idmlist[[i]] = mixcham.idm
  
  
  
  # Step 4: Evaluate overlap model and IDM with the same interaction test data
  ## Step 4a: Normalize rasters
  mixcham.idmnorm = (mixcham.idm - minmax(mixcham.idm)[1,])/(minmax(mixcham.idm)[2,] - minmax(mixcham.idm)[1,])
  mixcham.overlapnorm = (mixcham.overlap - minmax(mixcham.overlap)[1,])/(minmax(mixcham.overlap)[2,] - minmax(mixcham.overlap)[1,])
  
  ## Step 4b: Use modEvA::AUC to get AUC
  mixcham.overlap.auc <- AUC(obs = mixcham.test, pred = mixcham.overlapnorm)
  mixcham.idm.auc <- AUC(obs = mixcham.test, pred = mixcham.idmnorm)
  
  ## Step 4c: Calculate TSS and tstar
  mixcham.overlap.tssdf <- mixcham.overlap.auc$thresholds %>%
    mutate(TSS = sensitivity + specificity - 1)
  mixcham.overlap.tstar <- which.max(mixcham.overlap.tssdf$TSS)
  mixcham.idm.tssdf <- mixcham.idm.auc$thresholds %>%
    mutate(TSS = sensitivity + specificity - 1)
  mixcham.idm.tstar <- which.max(mixcham.idm.tssdf$TSS)
  
  ## Step 4d: Save evaluation scores
  ### Note: RMSE is the same for both so it is only noted under the overlap
  mixcham.overlap.eval = data.frame(run = i,
                        model = "overlap",
                        AUC = mixcham.overlap.auc$AUC,
                        TSS = max(mixcham.overlap.tssdf$TSS),
                        tstar = mixcham.overlap.tssdf[mixcham.overlap.tstar, 1],
                        sens_star = mixcham.overlap.tssdf[mixcham.overlap.tstar, 4],
                        spec_star = mixcham.overlap.tssdf[mixcham.overlap.tstar, 5],
                        RMSE = predicts::RMSE(na.omit(values(mixcham.idmnorm)), na.omit(values(mixcham.overlapnorm)), na.rm = T))

  mixcham.idm.eval = data.frame(run = i,
                        model = "IDM",
                        AUC = mixcham.idm.auc$AUC,
                        TSS = max(mixcham.idm.tssdf$TSS),
                        tstar = mixcham.idm.tssdf[mixcham.idm.tstar, 1],
                        sens_star = mixcham.idm.tssdf[mixcham.idm.tstar, 4],
                        spec_star = mixcham.idm.tssdf[mixcham.idm.tstar, 5])
  
  mixcham.evaldf = bind_rows(mixcham.evaldf, mixcham.overlap.eval, mixcham.idm.eval)
  
  # Step 5: Calculate threshold difference
  tstar.overlap = (mixcham.evaldf %>%
    filter(run == i,
           model == "overlap"))$tstar
  overlap.thresh = clamp(mixcham.overlapnorm, lower = tstar.overlap, upper = 1, values = T)
  overlap.thresh[overlap.thresh > tstar.overlap] = 1
  overlap.thresh[overlap.thresh <= tstar.overlap] = 0
  mixcham.overlapthresh[[i]] = overlap.thresh
  
  tstar.idm = (mixcham.evaldf %>%
    filter(run == i,
           model == "IDM"))$tstar
  idm.thresh = clamp(mixcham.idmnorm, lower = tstar.idm, upper = 1, values = T)
  idm.thresh[idm.thresh > tstar.idm] = 1
  idm.thresh[idm.thresh <= tstar.idm] = 0
  mixcham.idmthresh[[i]] = idm.thresh
  
  shared = overlap.thresh + idm.thresh
  diff = idm.thresh - overlap.thresh
  
  shared.df = data.frame(run = i,
                         n_shared = length(shared[shared == 2]),
                         n_IDM = length(diff[diff == 1]),
                         n_overlap = length(diff[diff == -1])) %>%
    mutate(prop.shared = n_shared/(n_shared + n_IDM + n_overlap),
           prop.idm = n_IDM/(n_shared + n_IDM + n_overlap),
           prop.overlap = n_overlap/(n_shared + n_IDM + n_overlap))
  
  mixcham.thresholddf = bind_rows(mixcham.thresholddf, shared.df)
  
  #   # Step 5: Save Variable Importance
  # idm.vars = data.frame(run = rep(i, 20),
  #                       model = rep("IDM", 20),
  #                       variable = names(mixcham.maxent@results[7:26,]),
  #                       percent = mixcham.maxent@results[7:26],
  #                       permutation = mixcham.maxent@results[27:46])
  # 
  # mixcham.varimpdf = bind_rows(mixcham.varimpdf, idm.vars)
}

write.csv(mixcham.evaldf, file = "completed-evals/mixcham-eval.csv")
write.csv(mixcham.thresholddf, file = "completed-evals/mixcham-threshold.csv")
# write.csv(mixcham.varimpdf, file = "completed-evals/mixcham-varimport.csv")
save(mixcham.overlaplist, file = "mixcham-overlaps.RData")
save(mixcham.idmlist, file = "mixcham-idms.RData")
```

```{r mixcham ensemble}
mixcham.overlap.ensemble <- raster(mean(rast(mixcham.overlaplist[c(1:100)])))
mixcham.overlap.spdf <- as(mixcham.overlap.ensemble, "SpatialPixelsDataFrame")
mixcham.overlap.df <- as.data.frame(mixcham.overlap.spdf)

mixcham.overlap.plot <- ggplot() +
  geom_tile(data = mixcham.overlap.df, aes(x = x, y = y, fill = mean)) +
  coord_cartesian(xlim = c(-130, -110), ylim = c(40, 50)) +
  theme_map() +
  scale_fill_viridis(option = "magma", 
                     limits = c(0, 1))
ggsave("figures/mixcham-overlap.png", mixcham.overlap.plot, width = 6, height = 4, units = "in")

mixcham.idm.ensemble <- raster(mean(rast(mixcham.idmlist[c(1:100)])))
mixcham.idm.spdf <- as(mixcham.idm.ensemble, "SpatialPixelsDataFrame")
mixcham.idm.df <- as.data.frame(mixcham.idm.spdf)

mixcham.idm.plot <- ggplot() +
  geom_tile(data = mixcham.idm.df, aes(x = x, y = y, fill = mean)) +
  coord_cartesian(xlim = c(-130, -110), ylim = c(40, 50)) +
  theme_map() +
  scale_fill_viridis(option = "magma", 
                     limits = c(0, 1))
ggsave("figures/mixcham-idm.png", mixcham.idm.plot, width = 6, height = 4, units = "in")
```

## Cirsium

```{r mix cham data, message = F}
gbif.cir <- gbif %>%
  filter(genus == "Cirsium")

mixcir <- bbna %>%
  filter(species == "mixtus",
         plant.host.genus == "Cirsium") %>%
  dplyr::select(latitude, longitude, plant.host.genus, date, month, day, year)
```

```{r mixcir maxent for loop, message = F, eval = T, results = "hide"}
mixcir.overlaplist <- vector(mode = "list", length = 100)
mixcir.idmlist <- vector(mode = "list", length = 100)
mixcir.overlapthresh <- vector(mode = "list", length = 100)
mixcir.idmthresh <- vector(mode = "list", length = 100)

mixcir.evaldf <- data.frame()
mixcir.thresholddf <- data.frame()
# mixcir.varimpdf <- data.frame()

set.seed(290424)
for(i in 1:100){
  # Step 1: separate all data into training and testing datasets
  bg <- as.data.frame(spatSample(x = bioclim, size = 10000, method = "random", na.rm = T, xy = T)) %>%
    dplyr::select(x, y) %>%
    rename(longitude = x,
           latitude = y)
  bgfold <- kfold(bg, k = 5)
  bg.test <- bg[bgfold == 1,]
  bg.train <- bg[bgfold != 1,]
  
  mix.longlat <- bbna %>%
    filter(species == "mixtus",
           plant.host.genus != "Cirsium") %>%
    slice_sample(by = BBNA.code, n = 1) %>%
    dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  mix.fold <- kfold(mix.longlat, k = 5)
  mix.test <- mix.longlat[mix.fold == 1,]
  mix.train <- mix.longlat[mix.fold != 1,]
  
  cir.longlat <- gbif.cir %>%
  dplyr::select(decimalLongitude, decimalLatitude) %>%
  as.data.frame(.) %>%
  rename(longitude = decimalLongitude,
         latitude = decimalLatitude)
  cir.fold <- kfold(cir.longlat, k = 5)
  cir.test <- cir.longlat[cir.fold == 1,]
  cir.train <- cir.longlat[cir.fold != 1,]
  
  mixcir.longlat <- mixcham %>%
  dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  mixcir.fold <- kfold(mixcir.longlat, k = 5)
  mixcir.test <- mixcir.longlat[mixcir.fold == 1,]
  mixcir.train <- mixcir.longlat[mixcir.fold != 1,]
  
  
  
  # Step 2: Calculate overlaps
  ## Step 2a: Individual models
  mix.maxent <- maxent(x = stack(bioclim),
                       p = mix.train, 
                       a = bg.train)
  mix.predict <- dismo::predict(mix.maxent,
                                stack(bioclim))
  
  cir.maxent <- maxent(x = stack(bioclim), 
                       p = cir.train, 
                       a = bg.train)
  cir.predict <- dismo::predict(cir.maxent,
                                stack(bioclim))
  
  ## Step 2b: Multiply bee and plant habitat suitability to get a joint probability
  mixcir.overlap <- as(mix.predict * cir.predict, "SpatRaster")
  mixcir.overlaplist[[i]] = mixcir.overlap
  
  
  
  # Step 3: Calculate IDM
  mixcir.maxent <- maxent(x = stack(bioclim), 
                          p = mixcir.train, 
                          a = bg.train)
  
  mixcir.idm <- as(dismo::predict(mixcir.maxent, stack(bioclim)), "SpatRaster")
  mixcir.idmlist[[i]] = mixcir.idm
  
  
  
  # Step 4: Evaluate overlap model and IDM with the same interaction test data
  ## Step 4a: Normalize rasters
  mixcir.idmnorm = (mixcir.idm - minmax(mixcir.idm)[1,])/(minmax(mixcir.idm)[2,] - minmax(mixcir.idm)[1,])
  mixcir.overlapnorm = (mixcir.overlap - minmax(mixcir.overlap)[1,])/(minmax(mixcir.overlap)[2,] - minmax(mixcir.overlap)[1,])
  
  ## Step 4b: Use modEvA::AUC to get AUC
  mixcir.overlap.auc <- AUC(obs = mixcir.test, pred = mixcir.overlapnorm)
  mixcir.idm.auc <- AUC(obs = mixcir.test, pred = mixcir.idmnorm)
  
  ## Step 4c: Calculate TSS and tstar
  mixcir.overlap.tssdf <- mixcir.overlap.auc$thresholds %>%
    mutate(TSS = sensitivity + specificity - 1)
  mixcir.overlap.tstar <- which.max(mixcir.overlap.tssdf$TSS)
  mixcir.idm.tssdf <- mixcir.idm.auc$thresholds %>%
    mutate(TSS = sensitivity + specificity - 1)
  mixcir.idm.tstar <- which.max(mixcir.idm.tssdf$TSS)
  
  ## Step 4d: Save evaluation scores
  ### Note: RMSE is the same for both so it is only noted under the overlap
  mixcir.overlap.eval = data.frame(run = i,
                        model = "overlap",
                        AUC = mixcir.overlap.auc$AUC,
                        TSS = max(mixcir.overlap.tssdf$TSS),
                        tstar = mixcir.overlap.tssdf[mixcir.overlap.tstar, 1],
                        sens_star = mixcir.overlap.tssdf[mixcir.overlap.tstar, 4],
                        spec_star = mixcir.overlap.tssdf[mixcir.overlap.tstar, 5],
                        RMSE = predicts::RMSE(na.omit(values(mixcir.idmnorm)), na.omit(values(mixcir.overlapnorm)), na.rm = T))

  mixcir.idm.eval = data.frame(run = i,
                        model = "IDM",
                        AUC = mixcir.idm.auc$AUC,
                        TSS = max(mixcir.idm.tssdf$TSS),
                        tstar = mixcir.idm.tssdf[mixcir.idm.tstar, 1],
                        sens_star = mixcir.idm.tssdf[mixcir.idm.tstar, 4],
                        spec_star = mixcir.idm.tssdf[mixcir.idm.tstar, 5])
  
  mixcir.evaldf = bind_rows(mixcir.evaldf, mixcir.overlap.eval, mixcir.idm.eval)
  
  # Step 5: Calculate threshold difference
  tstar.overlap = (mixcir.evaldf %>%
    filter(run == i,
           model == "overlap"))$tstar
  overlap.thresh = clamp(mixcir.overlapnorm, lower = tstar.overlap, upper = 1, values = T)
  overlap.thresh[overlap.thresh > tstar.overlap] = 1
  overlap.thresh[overlap.thresh <= tstar.overlap] = 0
  mixcir.overlapthresh[[i]] = overlap.thresh
  
  tstar.idm = (mixcir.evaldf %>%
    filter(run == i,
           model == "IDM"))$tstar
  idm.thresh = clamp(mixcir.idmnorm, lower = tstar.idm, upper = 1, values = T)
  idm.thresh[idm.thresh > tstar.idm] = 1
  idm.thresh[idm.thresh <= tstar.idm] = 0
  mixcir.idmthresh[[i]] = idm.thresh
  
  shared = overlap.thresh + idm.thresh
  diff = idm.thresh - overlap.thresh
  
  shared.df = data.frame(run = i,
                         n_shared = length(shared[shared == 2]),
                         n_IDM = length(diff[diff == 1]),
                         n_overlap = length(diff[diff == -1])) %>%
    mutate(prop.shared = n_shared/(n_shared + n_IDM + n_overlap),
           prop.idm = n_IDM/(n_shared + n_IDM + n_overlap),
           prop.overlap = n_overlap/(n_shared + n_IDM + n_overlap))
  
  mixcir.thresholddf = bind_rows(mixcir.thresholddf, shared.df)
  
  #   # Step 5: Save Variable Importance
  # idm.vars = data.frame(run = rep(i, 20),
  #                       model = rep("IDM", 20),
  #                       variable = names(mixcir.maxent@results[7:26,]),
  #                       percent = mixcir.maxent@results[7:26],
  #                       permutation = mixcir.maxent@results[27:46])
  # 
  # mixcir.varimpdf = bind_rows(mixcir.varimpdf, idm.vars)
}

write.csv(mixcir.evaldf, file = "completed-evals/mixcir-eval.csv")
write.csv(mixcir.thresholddf, file = "completed-evals/mixcir-threshold.csv")
# write.csv(mixcir.varimpdf, file = "completed-evals/mixcir-varimport.csv")
save(mixcir.overlaplist, file = "mixcir-overlaps.RData")
save(mixcir.idmlist, file = "mixcir-idms.RData")

```

```{r mixcir ensemble}
mixcir.overlap.ensemble <- raster(mean(rast(mixcir.overlaplist[c(1:100)])))
mixcir.overlap.spdf <- as(mixcir.overlap.ensemble, "SpatialPixelsDataFrame")
mixcir.overlap.df <- as.data.frame(mixcir.overlap.spdf)

mixcir.overlap.plot <- ggplot() +
  geom_tile(data = mixcir.overlap.df, aes(x = x, y = y, fill = mean)) +
  coord_cartesian(xlim = c(-130, -110), ylim = c(40, 50)) +
  theme_map() +
  scale_fill_viridis(option = "magma", 
                     limits = c(0, 1))
ggsave("figures/mixcir-overlap.png", mixcir.overlap.plot, width = 6, height = 4, units = "in")

mixcir.idm.ensemble <- raster(mean(rast(mixcir.idmlist[c(1:100)])))
mixcir.idm.spdf <- as(mixcir.idm.ensemble, "SpatialPixelsDataFrame")
mixcir.idm.df <- as.data.frame(mixcir.idm.spdf)

mixcir.idm.plot <- ggplot() +
  geom_tile(data = mixcir.idm.df, aes(x = x, y = y, fill = mean)) +
  coord_cartesian(xlim = c(-130, -110), ylim = c(40, 50)) +
  theme_map() +
  scale_fill_viridis(option = "magma", 
                     limits = c(0, 1))
ggsave("figures/mixcir-idm.png", mixcir.idm.plot, width = 6, height = 4, units = "in")
```

## Lupinus

```{r mix lup data, message = F}
gbif.lup <- gbif %>%
  filter(genus == "Lupinus")

mixlup <- bbna %>%
  filter(species == "mixtus",
         plant.host.genus == "Lupinus") %>%
  dplyr::select(latitude, longitude, plant.host.genus, date, month, day, year)
```

```{r mixlup maxent for loop, message = F, eval = T, results = "hide"}
mixlup.overlaplist <- vector(mode = "list", length = 100)
mixlup.idmlist <- vector(mode = "list", length = 100)
mixlup.overlapthresh <- vector(mode = "list", length = 100)
mixlup.idmthresh <- vector(mode = "list", length = 100)

mixlup.evaldf <- data.frame()
mixlup.thresholddf <- data.frame()
# mixlup.varimpdf <- data.frame()

set.seed(232024)
for(i in 1:100){
  # Step 1: separate all data into training and testing datasets
  bg <- as.data.frame(spatSample(x = bioclim, size = 10000, method = "random", na.rm = T, xy = T)) %>%
    dplyr::select(x, y) %>%
    rename(longitude = x,
           latitude = y)
  bgfold <- kfold(bg, k = 5)
  bg.test <- bg[bgfold == 1,]
  bg.train <- bg[bgfold != 1,]
  
  mix.longlat <- bbna %>%
    filter(species == "mixtus",
           plant.host.genus != "Lupinus") %>%
    slice_sample(by = BBNA.code, n = 1) %>%
    dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  mix.fold <- kfold(mix.longlat, k = 5)
  mix.test <- mix.longlat[mix.fold == 1,]
  mix.train <- mix.longlat[mix.fold != 1,]
  
  lup.longlat <- gbif.lup %>%
  dplyr::select(decimalLongitude, decimalLatitude) %>%
  as.data.frame(.) %>%
  rename(longitude = decimalLongitude,
         latitude = decimalLatitude)
  lup.fold <- kfold(lup.longlat, k = 5)
  lup.test <- lup.longlat[lup.fold == 1,]
  lup.train <- lup.longlat[lup.fold != 1,]
  
  mixlup.longlat <- mixlup %>%
  dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  mixlup.fold <- kfold(mixlup.longlat, k = 5)
  mixlup.test <- mixlup.longlat[mixlup.fold == 1,]
  mixlup.train <- mixlup.longlat[mixlup.fold != 1,]
  
  
  
  # Step 2: Calculate overlaps
  ## Step 2a: Individual models
  mix.maxent <- maxent(x = stack(bioclim),
                       p = mix.train, 
                       a = bg.train)
  mix.predict <- dismo::predict(mix.maxent,
                                stack(bioclim))
  
  lup.maxent <- maxent(x = stack(bioclim), 
                       p = lup.train, 
                       a = bg.train)
  lup.predict <- dismo::predict(lup.maxent,
                                stack(bioclim))
  
  ## Step 2b: Multiply bee and plant habitat suitability to get a joint probability
  mixlup.overlap <- as(mix.predict * lup.predict, "SpatRaster")
  mixlup.overlaplist[[i]] = mixlup.overlap
  
  
  
  # Step 3: Calculate IDM
  mixlup.maxent <- maxent(x = stack(bioclim), 
                          p = mixlup.train, 
                          a = bg.train)
  
  mixlup.idm <- as(dismo::predict(mixlup.maxent, stack(bioclim)), "SpatRaster")
  mixlup.idmlist[[i]] = mixlup.idm
  
  
  
  # Step 4: Evaluate overlap model and IDM with the same interaction test data
  ## Step 4a: Normalize rasters
  mixlup.idmnorm = (mixlup.idm - minmax(mixlup.idm)[1,])/(minmax(mixlup.idm)[2,] - minmax(mixlup.idm)[1,])
  mixlup.overlapnorm = (mixlup.overlap - minmax(mixlup.overlap)[1,])/(minmax(mixlup.overlap)[2,] - minmax(mixlup.overlap)[1,])
  
  ## Step 4b: Use modEvA::AUC to get AUC
  mixlup.overlap.auc <- AUC(obs = mixlup.test, pred = mixlup.overlapnorm)
  mixlup.idm.auc <- AUC(obs = mixlup.test, pred = mixlup.idmnorm)
  
  ## Step 4c: Calculate TSS and tstar
  mixlup.overlap.tssdf <- mixlup.overlap.auc$thresholds %>%
    mutate(TSS = sensitivity + specificity - 1)
  mixlup.overlap.tstar <- which.max(mixlup.overlap.tssdf$TSS)
  mixlup.idm.tssdf <- mixlup.idm.auc$thresholds %>%
    mutate(TSS = sensitivity + specificity - 1)
  mixlup.idm.tstar <- which.max(mixlup.idm.tssdf$TSS)
  
  ## Step 4d: Save evaluation scores
  ### Note: RMSE is the same for both so it is only noted under the overlap
  mixlup.overlap.eval = data.frame(run = i,
                        model = "overlap",
                        AUC = mixlup.overlap.auc$AUC,
                        TSS = max(mixlup.overlap.tssdf$TSS),
                        tstar = mixlup.overlap.tssdf[mixlup.overlap.tstar, 1],
                        sens_star = mixlup.overlap.tssdf[mixlup.overlap.tstar, 4],
                        spec_star = mixlup.overlap.tssdf[mixlup.overlap.tstar, 5],
                        RMSE = predicts::RMSE(na.omit(values(mixlup.idmnorm)), na.omit(values(mixlup.overlapnorm)), na.rm = T))

  mixlup.idm.eval = data.frame(run = i,
                        model = "IDM",
                        AUC = mixlup.idm.auc$AUC,
                        TSS = max(mixlup.idm.tssdf$TSS),
                        tstar = mixlup.idm.tssdf[mixlup.idm.tstar, 1],
                        sens_star = mixlup.idm.tssdf[mixlup.idm.tstar, 4],
                        spec_star = mixlup.idm.tssdf[mixlup.idm.tstar, 5])
  
  mixlup.evaldf = bind_rows(mixlup.evaldf, mixlup.overlap.eval, mixlup.idm.eval)
  
  # Step 5: Calculate threshold difference
  tstar.overlap = (mixlup.evaldf %>%
    filter(run == i,
           model == "overlap"))$tstar
  overlap.thresh = clamp(mixlup.overlapnorm, lower = tstar.overlap, upper = 1, values = T)
  overlap.thresh[overlap.thresh > tstar.overlap] = 1
  overlap.thresh[overlap.thresh <= tstar.overlap] = 0
  mixlup.overlapthresh[[i]] = overlap.thresh
  
  tstar.idm = (mixlup.evaldf %>%
    filter(run == i,
           model == "IDM"))$tstar
  idm.thresh = clamp(mixlup.idmnorm, lower = tstar.idm, upper = 1, values = T)
  idm.thresh[idm.thresh > tstar.idm] = 1
  idm.thresh[idm.thresh <= tstar.idm] = 0
  mixlup.idmthresh[[i]] = idm.thresh
  
  shared = overlap.thresh + idm.thresh
  diff = idm.thresh - overlap.thresh
  
  shared.df = data.frame(run = i,
                         n_shared = length(shared[shared == 2]),
                         n_IDM = length(diff[diff == 1]),
                         n_overlap = length(diff[diff == -1])) %>%
    mutate(prop.shared = n_shared/(n_shared + n_IDM + n_overlap),
           prop.idm = n_IDM/(n_shared + n_IDM + n_overlap),
           prop.overlap = n_overlap/(n_shared + n_IDM + n_overlap))
  
  mixlup.thresholddf = bind_rows(mixlup.thresholddf, shared.df)
  
  #   # Step 5: Save Variable Importance
  # idm.vars = data.frame(run = rep(i, 20),
  #                       model = rep("IDM", 20),
  #                       variable = names(mixlup.maxent@results[7:26,]),
  #                       percent = mixlup.maxent@results[7:26],
  #                       permutation = mixlup.maxent@results[27:46])
  # 
  # mixlup.varimpdf = bind_rows(mixlup.varimpdf, idm.vars)
}

write.csv(mixlup.evaldf, file = "completed-evals/mixlup-eval.csv")
write.csv(mixlup.thresholddf, file = "completed-evals/mixlup-threshold.csv")
# write.csv(mixlup.varimpdf, file = "completed-evals/mixlup-varimport.csv")
save(mixlup.overlaplist, file = "mixlup-overlaps.RData")
save(mixlup.idmlist, file = "mixlup-idms.RData")
```

```{r mixlup ensemble}
mixlup.overlap.ensemble <- raster(mean(rast(mixlup.overlaplist[c(1:100)])))
mixlup.overlap.spdf <- as(mixlup.overlap.ensemble, "SpatialPixelsDataFrame")
mixlup.overlap.df <- as.data.frame(mixlup.overlap.spdf)

mixlup.overlap.plot <- ggplot() +
  geom_tile(data = mixlup.overlap.df, aes(x = x, y = y, fill = mean)) +
  coord_cartesian(xlim = c(-130, -110), ylim = c(40, 50)) +
  theme_map() +
  scale_fill_viridis(option = "magma", 
                     limits = c(0, 1))
ggsave("figures/mixlup-overlap.png", mixlup.overlap.plot, width = 6, height = 4, units = "in")

mixlup.idm.ensemble <- raster(mean(rast(mixlup.idmlist[c(1:100)])))
mixlup.idm.spdf <- as(mixlup.idm.ensemble, "SpatialPixelsDataFrame")
mixlup.idm.df <- as.data.frame(mixlup.idm.spdf)

mixlup.idm.plot <- ggplot() +
  geom_tile(data = mixlup.idm.df, aes(x = x, y = y, fill = mean)) +
  coord_cartesian(xlim = c(-130, -110), ylim = c(40, 50)) +
  theme_map() +
  scale_fill_viridis(option = "magma", 
                     limits = c(0, 1))
ggsave("figures/mixlup-idm.png", mixlup.idm.plot, width = 6, height = 4, units = "in")
```

## Penstemon

```{r mix pen data, message = F}
gbif.pen <- gbif %>%
  filter(genus == "Penstemon")

mixpen <- bbna %>%
  filter(species == "mixtus",
         plant.host.genus == "Penstemon") %>%
  dplyr::select(latitude, longitude, plant.host.genus, date, month, day, year)
```

```{r mixpen maxent for loop, message = F, eval = T, results = "hide"}
mixpen.overlaplist <- vector(mode = "list", length = 100)
mixpen.idmlist <- vector(mode = "list", length = 100)
mixpen.overlapthresh <- vector(mode = "list", length = 100)
mixpen.idmthresh <- vector(mode = "list", length = 100)

mixpen.evaldf <- data.frame()
mixpen.thresholddf <- data.frame()
# mixpen.varimpdf <- data.frame()

set.seed(208483)
for(i in 1:100){
  # Step 1: separate all data into training and testing datasets
  bg <- as.data.frame(spatSample(x = bioclim, size = 10000, method = "random", na.rm = T, xy = T)) %>%
    dplyr::select(x, y) %>%
    rename(longitude = x,
           latitude = y)
  bgfold <- kfold(bg, k = 5)
  bg.test <- bg[bgfold == 1,]
  bg.train <- bg[bgfold != 1,]
  
  mix.longlat <- bbna %>%
    filter(species == "mixtus",
           plant.host.genus != "Penstemon") %>%
    slice_sample(by = BBNA.code, n = 1) %>%
    dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  mix.fold <- kfold(mix.longlat, k = 5)
  mix.test <- mix.longlat[mix.fold == 1,]
  mix.train <- mix.longlat[mix.fold != 1,]
  
  pen.longlat <- gbif.pen %>%
  dplyr::select(decimalLongitude, decimalLatitude) %>%
  as.data.frame(.) %>%
  rename(longitude = decimalLongitude,
         latitude = decimalLatitude)
  pen.fold <- kfold(pen.longlat, k = 5)
  pen.test <- pen.longlat[pen.fold == 1,]
  pen.train <- pen.longlat[pen.fold != 1,]
  
  mixpen.longlat <- mixpen %>%
  dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  mixpen.fold <- kfold(mixpen.longlat, k = 5)
  mixpen.test <- mixpen.longlat[mixpen.fold == 1,]
  mixpen.train <- mixpen.longlat[mixpen.fold != 1,]
  
  
  
  # Step 2: Calculate overlaps
  ## Step 2a: Individual models
  mix.maxent <- maxent(x = stack(bioclim),
                       p = mix.train, 
                       a = bg.train)
  mix.predict <- dismo::predict(mix.maxent,
                                stack(bioclim))
  
  pen.maxent <- maxent(x = stack(bioclim), 
                       p = pen.train, 
                       a = bg.train)
  pen.predict <- dismo::predict(pen.maxent,
                                stack(bioclim))
  
  ## Step 2b: Multiply bee and plant habitat suitability to get a joint probability
  mixpen.overlap <- as(mix.predict * pen.predict, "SpatRaster")
  mixpen.overlaplist[[i]] = mixpen.overlap
  
  
  
  # Step 3: Calculate IDM
  mixpen.maxent <- maxent(x = stack(bioclim), 
                          p = mixpen.train, 
                          a = bg.train)
  
  mixpen.idm <- as(dismo::predict(mixpen.maxent, stack(bioclim)), "SpatRaster")
  mixpen.idmlist[[i]] = mixpen.idm
  
  
  
  # Step 4: Evaluate overlap model and IDM with the same interaction test data
  ## Step 4a: Normalize rasters for RMSE calculation
  mixpen.idmnorm = (mixpen.idm - minmax(mixpen.idm)[1,])/(minmax(mixpen.idm)[2,] - minmax(mixpen.idm)[1,])
  mixpen.overlapnorm = (mixpen.overlap - minmax(mixpen.overlap)[1,])/(minmax(mixpen.overlap)[2,] - minmax(mixpen.overlap)[1,])
  
  ## Step 4b: Use modEvA::AUC to get AUC
  mixpen.overlap.auc <- AUC(obs = mixpen.test, pred = mixpen.overlapnorm)
  mixpen.idm.auc <- AUC(obs = mixpen.test, pred = mixpen.idmnorm)
  
  ## Step 4c: Calculate TSS and tstar
  mixpen.overlap.tssdf <- mixpen.overlap.auc$thresholds %>%
    mutate(TSS = sensitivity + specificity - 1)
  mixpen.overlap.tstar <- which.max(mixpen.overlap.tssdf$TSS)
  mixpen.idm.tssdf <- mixpen.idm.auc$thresholds %>%
    mutate(TSS = sensitivity + specificity - 1)
  mixpen.idm.tstar <- which.max(mixpen.idm.tssdf$TSS)
  
  ## Step 4d: Save evaluation scores
  ### Note: RMSE is the same for both so it is only noted under the overlap
  mixpen.overlap.eval = data.frame(run = i,
                        model = "overlap",
                        AUC = mixpen.overlap.auc$AUC,
                        TSS = max(mixpen.overlap.tssdf$TSS),
                        tstar = mixpen.overlap.tssdf[mixpen.overlap.tstar, 1],
                        sens_star = mixpen.overlap.tssdf[mixpen.overlap.tstar, 4],
                        spec_star = mixpen.overlap.tssdf[mixpen.overlap.tstar, 5],
                        RMSE = predicts::RMSE(na.omit(values(mixpen.idmnorm)), na.omit(values(mixpen.overlapnorm)), na.rm = T))

  mixpen.idm.eval = data.frame(run = i,
                        model = "IDM",
                        AUC = mixpen.idm.auc$AUC,
                        TSS = max(mixpen.idm.tssdf$TSS),
                        tstar = mixpen.idm.tssdf[mixpen.idm.tstar, 1],
                        sens_star = mixpen.idm.tssdf[mixpen.idm.tstar, 4],
                        spec_star = mixpen.idm.tssdf[mixpen.idm.tstar, 5])
  
  mixpen.evaldf = bind_rows(mixpen.evaldf, mixpen.overlap.eval, mixpen.idm.eval)
  
  # Step 5: Calculate threshold difference
  tstar.overlap = (mixpen.evaldf %>%
    filter(run == i,
           model == "overlap"))$tstar
  overlap.thresh = clamp(mixpen.overlapnorm, lower = tstar.overlap, upper = 1, values = T)
  overlap.thresh[overlap.thresh > tstar.overlap] = 1
  overlap.thresh[overlap.thresh <= tstar.overlap] = 0
  mixpen.overlapthresh[[i]] = overlap.thresh
  
  tstar.idm = (mixpen.evaldf %>%
    filter(run == i,
           model == "IDM"))$tstar
  idm.thresh = clamp(mixpen.idmnorm, lower = tstar.idm, upper = 1, values = T)
  idm.thresh[idm.thresh > tstar.idm] = 1
  idm.thresh[idm.thresh <= tstar.idm] = 0
  mixpen.idmthresh[[i]] = idm.thresh
  
  shared = overlap.thresh + idm.thresh
  diff = idm.thresh - overlap.thresh
  
  shared.df = data.frame(run = i,
                         n_shared = length(shared[shared == 2]),
                         n_IDM = length(diff[diff == 1]),
                         n_overlap = length(diff[diff == -1])) %>%
    mutate(prop.shared = n_shared/(n_shared + n_IDM + n_overlap),
           prop.idm = n_IDM/(n_shared + n_IDM + n_overlap),
           prop.overlap = n_overlap/(n_shared + n_IDM + n_overlap))
  
  mixpen.thresholddf = bind_rows(mixpen.thresholddf, shared.df)
  
  #   # Step 5: Save Variable Importance
  # idm.vars = data.frame(run = rep(i, 20),
  #                       model = rep("IDM", 20),
  #                       variable = names(mixpen.maxent@results[7:26,]),
  #                       percent = mixpen.maxent@results[7:26],
  #                       permutation = mixpen.maxent@results[27:46])
  # 
  # mixpen.varimpdf = bind_rows(mixpen.varimpdf, idm.vars)
}

write.csv(mixpen.evaldf, file = "completed-evals/mixpen-eval.csv")
write.csv(mixpen.thresholddf, file = "completed-evals/mixpen-threshold.csv")
# write.csv(mixpen.varimpdf, file = "completed-evals/mixpen-varimport.csv")
save(mixpen.overlaplist, file = "mixpen-overlaps.RData")
save(mixpen.idmlist, file = "mixpen-idms.RData")
```

```{r mixpen ensemble}
mixpen.overlap.ensemble <- raster(mean(rast(mixpen.overlaplist[c(1:100)])))
mixpen.overlap.spdf <- as(mixpen.overlap.ensemble, "SpatialPixelsDataFrame")
mixpen.overlap.df <- as.data.frame(mixpen.overlap.spdf)

mixpen.overlap.plot <- ggplot() +
  geom_tile(data = mixpen.overlap.df, aes(x = x, y = y, fill = mean)) +
  coord_cartesian(xlim = c(-130, -110), ylim = c(40, 50)) +
  theme_map() +
  scale_fill_viridis(option = "magma", 
                     limits = c(0, 1))
ggsave("figures/mixpen-overlap.png", mixpen.overlap.plot, width = 6, height = 4, units = "in")

mixpen.idm.ensemble <- raster(mean(rast(mixpen.idmlist[c(1:100)])))
mixpen.idm.spdf <- as(mixpen.idm.ensemble, "SpatialPixelsDataFrame")
mixpen.idm.df <- as.data.frame(mixpen.idm.spdf)

mixpen.idm.plot <- ggplot() +
  geom_tile(data = mixpen.idm.df, aes(x = x, y = y, fill = mean)) +
  coord_cartesian(xlim = c(-130, -110), ylim = c(40, 50)) +
  theme_map() +
  scale_fill_viridis(option = "magma", 
                     limits = c(0, 1))
ggsave("figures/mixpen-idm.png", mixpen.idm.plot, width = 6, height = 4, units = "in")
```

## Rubus

```{r mix rub data, message = F}
gbif.rub <- gbif %>%
  filter(genus == "Rubus")

mixrub <- bbna %>%
  filter(species == "mixtus",
         plant.host.genus == "Rubus") %>%
  dplyr::select(latitude, longitude, plant.host.genus, date, month, day, year)
```

```{r mixrub maxent for loop, message = F, eval = T, results = "hide"}
mixrub.overlaplist <- vector(mode = "list", length = 100)
mixrub.idmlist <- vector(mode = "list", length = 100)
mixrub.overlapthresh <- vector(mode = "list", length = 100)
mixrub.idmthresh <- vector(mode = "list", length = 100)

mixrub.evaldf <- data.frame()
mixrub.thresholddf <- data.frame()
# mixrub.varimpdf <- data.frame()

set.seed(121023)
for(i in 1:100){
  # Step 1: separate all data into training and testing datasets
  bg <- as.data.frame(spatSample(x = bioclim, size = 10000, method = "random", na.rm = T, xy = T)) %>%
    dplyr::select(x, y) %>%
    rename(longitude = x,
           latitude = y)
  bgfold <- kfold(bg, k = 5)
  bg.test <- bg[bgfold == 1,]
  bg.train <- bg[bgfold != 1,]
  
  mix.longlat <- bbna %>%
    filter(species == "mixtus",
           plant.host.genus != "Rubus") %>%
    slice_sample(by = BBNA.code, n = 1) %>%
    dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  mix.fold <- kfold(mix.longlat, k = 5)
  mix.test <- mix.longlat[mix.fold == 1,]
  mix.train <- mix.longlat[mix.fold != 1,]
  
  rub.longlat <- gbif.rub %>%
  dplyr::select(decimalLongitude, decimalLatitude) %>%
  as.data.frame(.) %>%
  rename(longitude = decimalLongitude,
         latitude = decimalLatitude)
  rub.fold <- kfold(rub.longlat, k = 5)
  rub.test <- rub.longlat[rub.fold == 1,]
  rub.train <- rub.longlat[rub.fold != 1,]
  
  mixrub.longlat <- mixrub %>%
  dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  mixrub.fold <- kfold(mixrub.longlat, k = 5)
  mixrub.test <- mixrub.longlat[mixrub.fold == 1,]
  mixrub.train <- mixrub.longlat[mixrub.fold != 1,]
  
  
  
  # Step 2: Calculate overlaps
  ## Step 2a: Individual models
  mix.maxent <- maxent(x = stack(bioclim),
                       p = mix.train, 
                       a = bg.train)
  mix.predict <- dismo::predict(mix.maxent,
                                stack(bioclim))
  
  rub.maxent <- maxent(x = stack(bioclim), 
                       p = rub.train, 
                       a = bg.train)
  rub.predict <- dismo::predict(rub.maxent,
                                stack(bioclim))
  
  ## Step 2b: Multiply bee and plant habitat suitability to get a joint probability
  mixrub.overlap <- as(mix.predict * rub.predict, "SpatRaster")
  mixrub.overlaplist[[i]] = mixrub.overlap
  
  
  
  # Step 3: Calculate IDM
  mixrub.maxent <- maxent(x = stack(bioclim), 
                          p = mixrub.train, 
                          a = bg.train)
  
  mixrub.idm <- as(dismo::predict(mixrub.maxent, stack(bioclim)), "SpatRaster")
  mixrub.idmlist[[i]] = mixrub.idm
  
  
  
  # Step 4: Evaluate overlap model and IDM with the same interaction test data
  ## Step 4a: Normalize rasters
  mixrub.idmnorm = (mixrub.idm - minmax(mixrub.idm)[1,])/(minmax(mixrub.idm)[2,] - minmax(mixrub.idm)[1,])
  mixrub.overlapnorm = (mixrub.overlap - minmax(mixrub.overlap)[1,])/(minmax(mixrub.overlap)[2,] - minmax(mixrub.overlap)[1,])
  
  ## Step 4b: Use modEvA::AUC to get AUC
  mixrub.overlap.auc <- AUC(obs = mixrub.test, pred = mixrub.overlapnorm)
  mixrub.idm.auc <- AUC(obs = mixrub.test, pred = mixrub.idmnorm)
  
  ## Step 4c: Calculate TSS and tstar
  mixrub.overlap.tssdf <- mixrub.overlap.auc$thresholds %>%
    mutate(TSS = sensitivity + specificity - 1)
  mixrub.overlap.tstar <- which.max(mixrub.overlap.tssdf$TSS)
  mixrub.idm.tssdf <- mixrub.idm.auc$thresholds %>%
    mutate(TSS = sensitivity + specificity - 1)
  mixrub.idm.tstar <- which.max(mixrub.idm.tssdf$TSS)
  
  ## Step 4d: Save evaluation scores
  ### Note: RMSE is the same for both so it is only noted under the overlap
  mixrub.overlap.eval = data.frame(run = i,
                        model = "overlap",
                        AUC = mixrub.overlap.auc$AUC,
                        TSS = max(mixrub.overlap.tssdf$TSS),
                        tstar = mixrub.overlap.tssdf[mixrub.overlap.tstar, 1],
                        sens_star = mixrub.overlap.tssdf[mixrub.overlap.tstar, 4],
                        spec_star = mixrub.overlap.tssdf[mixrub.overlap.tstar, 5],
                        RMSE = predicts::RMSE(na.omit(values(mixrub.idmnorm)), na.omit(values(mixrub.overlapnorm)), na.rm = T))

  mixrub.idm.eval = data.frame(run = i,
                        model = "IDM",
                        AUC = mixrub.idm.auc$AUC,
                        TSS = max(mixrub.idm.tssdf$TSS),
                        tstar = mixrub.idm.tssdf[mixrub.idm.tstar, 1],
                        sens_star = mixrub.idm.tssdf[mixrub.idm.tstar, 4],
                        spec_star = mixrub.idm.tssdf[mixrub.idm.tstar, 5])
  
  mixrub.evaldf = bind_rows(mixrub.evaldf, mixrub.overlap.eval, mixrub.idm.eval)

  # Step 5: Calculate threshold difference
  tstar.overlap = (mixrub.evaldf %>%
    filter(run == i,
           model == "overlap"))$tstar
  overlap.thresh = clamp(mixrub.overlapnorm, lower = tstar.overlap, upper = 1, values = T)
  overlap.thresh[overlap.thresh > tstar.overlap] = 1
  overlap.thresh[overlap.thresh <= tstar.overlap] = 0
  mixrub.overlapthresh[[i]] = overlap.thresh
  
  tstar.idm = (mixrub.evaldf %>%
    filter(run == i,
           model == "IDM"))$tstar
  idm.thresh = clamp(mixrub.idmnorm, lower = tstar.idm, upper = 1, values = T)
  idm.thresh[idm.thresh > tstar.idm] = 1
  idm.thresh[idm.thresh <= tstar.idm] = 0
  mixrub.idmthresh[[i]] = idm.thresh
  
  shared = overlap.thresh + idm.thresh
  diff = idm.thresh - overlap.thresh
  
  shared.df = data.frame(run = i,
                         n_shared = length(shared[shared == 2]),
                         n_IDM = length(diff[diff == 1]),
                         n_overlap = length(diff[diff == -1])) %>%
    mutate(prop.shared = n_shared/(n_shared + n_IDM + n_overlap),
           prop.idm = n_IDM/(n_shared + n_IDM + n_overlap),
           prop.overlap = n_overlap/(n_shared + n_IDM + n_overlap))
  
  mixrub.thresholddf = bind_rows(mixrub.thresholddf, shared.df)
  
  #   # Step 5: Save Variable Importance
  # idm.vars = data.frame(run = rep(i, 20),
  #                       model = rep("IDM", 20),
  #                       variable = names(mixrub.maxent@results[7:26,]),
  #                       percent = mixrub.maxent@results[7:26],
  #                       permutation = mixrub.maxent@results[27:46])
  # 
  # mixrub.varimpdf = bind_rows(mixrub.varimpdf, idm.vars)
}

write.csv(mixrub.evaldf, file = "completed-evals/mixrub-eval.csv")
write.csv(mixrub.thresholddf, file = "completed-evals/mixrub-threshold.csv")
# write.csv(mixrub.varimpdf, file = "completed-evals/mixrub-varimport.csv")
save(mixrub.overlaplist, file = "mixrub-overlaps.RData")
save(mixrub.idmlist, file = "mixrub-idms.RData")
```

```{r mixrub ensemble}
mixrub.overlap.ensemble <- raster(mean(rast(mixrub.overlaplist[c(1:100)])))
mixrub.overlap.spdf <- as(mixrub.overlap.ensemble, "SpatialPixelsDataFrame")
mixrub.overlap.df <- as.data.frame(mixrub.overlap.spdf)

mixrub.overlap.plot <- ggplot() +
  geom_tile(data = mixrub.overlap.df, aes(x = x, y = y, fill = mean)) +
  coord_cartesian(xlim = c(-130, -110), ylim = c(40, 50)) +
  theme_map() +
  scale_fill_viridis(option = "magma", 
                     limits = c(0, 1))
ggsave("figures/mixrub-overlap.png", mixrub.overlap.plot, width = 6, height = 4, units = "in")

mixrub.idm.ensemble <- raster(mean(rast(mixrub.idmlist[c(1:100)])))
mixrub.idm.spdf <- as(mixrub.idm.ensemble, "SpatialPixelsDataFrame")
mixrub.idm.df <- as.data.frame(mixrub.idm.spdf)

mixrub.idm.plot <- ggplot() +
  geom_tile(data = mixrub.idm.df, aes(x = x, y = y, fill = mean)) +
  coord_cartesian(xlim = c(-130, -110), ylim = c(40, 50)) +
  theme_map() +
  scale_fill_viridis(option = "magma", 
                     limits = c(0, 1))
ggsave("figures/mixrub-idm.png", mixrub.idm.plot, width = 6, height = 4, units = "in")
```


# Vosnesenskii
## Chamaenerion

```{r vos cham data, message = F}
gbif.cham <- gbif %>%
  filter(genus == "Chamaenerion")

voscham <- bbna %>% 
  filter(species == "vosnesenskii",
         plant.host.genus == "Chamaenerion") %>%
  dplyr::select(latitude, longitude, plant.host.genus, date, month, day, year)
```

```{r voscham maxent for loop, message = F, eval = T, results = "hide"}
voscham.overlaplist <- vector(mode = "list", length = 100)
voscham.idmlist <- vector(mode = "list", length = 100)
voscham.overlapthresh <- vector(mode = "list", length = 100)
voscham.idmthresh <- vector(mode = "list", length = 100)

voscham.evaldf <- data.frame()
voscham.thresholddf <- data.frame()
# voscham.varimpdf <- data.frame()

set.seed(1301143)
for(i in 1:100){
  # Step 1: separate all data into training and testing datasets
  bg <- as.data.frame(spatSample(x = bioclim, size = 10000, method = "random", na.rm = T, xy = T)) %>%
    dplyr::select(x, y) %>%
    rename(longitude = x,
           latitude = y)
  bgfold <- kfold(bg, k = 5)
  bg.test <- bg[bgfold == 1,]
  bg.train <- bg[bgfold != 1,]
  
  vos.longlat <- bbna %>%
    filter(species == "vosnesenskii",
           plant.host.genus != "Chamaenerion") %>%
    slice_sample(by = BBNA.code, n = 1) %>%
    dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  vos.fold <- kfold(vos.longlat, k = 5)
  vos.test <- vos.longlat[vos.fold == 1,]
  vos.train <- vos.longlat[vos.fold != 1,]
  
  cham.longlat <- gbif.cham %>%
  dplyr::select(decimalLongitude, decimalLatitude) %>%
  as.data.frame(.) %>%
  rename(longitude = decimalLongitude,
         latitude = decimalLatitude)
  cham.fold <- kfold(cham.longlat, k = 5)
  cham.test <- cham.longlat[cham.fold == 1,]
  cham.train <- cham.longlat[cham.fold != 1,]
  
  voscham.longlat <- voscham %>%
  dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  voscham.fold <- kfold(voscham.longlat, k = 5)
  voscham.test <- voscham.longlat[voscham.fold == 1,]
  voscham.train <- voscham.longlat[voscham.fold != 1,]

  
  
  # Step 2: Calculate overlaps
  ## Step 2a: Individual models
  vos.maxent <- maxent(x = stack(bioclim),
                       p = vos.train, 
                       a = bg.train)
  vos.predict <- dismo::predict(vos.maxent,
                                stack(bioclim))
  
  cham.maxent <- maxent(x = stack(bioclim), 
                       p = cham.train, 
                       a = bg.train)
  cham.predict <- dismo::predict(cham.maxent,
                                stack(bioclim))
  
  ## Step 2b: Multiply bee and plant habitat suitability to get a joint probability
  voscham.overlap <- as(vos.predict * cham.predict, "SpatRaster")
  voscham.overlaplist[[i]] = voscham.overlap
  
  
  
  # Step 3: Calculate IDM
  voscham.maxent <- maxent(x = stack(bioclim), 
                          p = voscham.train, 
                          a = bg.train)
  
  voscham.idm <- as(dismo::predict(voscham.maxent, stack(bioclim)), "SpatRaster")
  voscham.idmlist[[i]] = voscham.idm
  
  
  
  # Step 4: Evaluate overlap model and IDM with the same interaction test data
  ## Step 4a: Normalize rasters
  voscham.idmnorm = (voscham.idm - minmax(voscham.idm)[1,])/(minmax(voscham.idm)[2,] - minmax(voscham.idm)[1,])
  voscham.overlapnorm = (voscham.overlap - minmax(voscham.overlap)[1,])/(minmax(voscham.overlap)[2,] - minmax(voscham.overlap)[1,])
  
  ## Step 4b: Use modEvA::AUC to get AUC
  voscham.overlap.auc <- AUC(obs = voscham.test, pred = voscham.overlapnorm)
  voscham.idm.auc <- AUC(obs = voscham.test, pred = voscham.idmnorm)
  
  ## Step 4c: Calculate TSS and tstar
  voscham.overlap.tssdf <- voscham.overlap.auc$thresholds %>%
    mutate(TSS = sensitivity + specificity - 1)
  voscham.overlap.tstar <- which.max(voscham.overlap.tssdf$TSS)
  voscham.idm.tssdf <- voscham.idm.auc$thresholds %>%
    mutate(TSS = sensitivity + specificity - 1)
  voscham.idm.tstar <- which.max(voscham.idm.tssdf$TSS)
  
  ## Step 4d: Save evaluation scores
  ### Note: RMSE is the same for both so it is only noted under the overlap
  voscham.overlap.eval = data.frame(run = i,
                        model = "overlap",
                        AUC = voscham.overlap.auc$AUC,
                        TSS = max(voscham.overlap.tssdf$TSS),
                        tstar = voscham.overlap.tssdf[voscham.overlap.tstar, 1],
                        sens_star = voscham.overlap.tssdf[voscham.overlap.tstar, 4],
                        spec_star = voscham.overlap.tssdf[voscham.overlap.tstar, 5],
                        RMSE = predicts::RMSE(na.omit(values(voscham.idmnorm)), na.omit(values(voscham.overlapnorm)), na.rm = T))

  voscham.idm.eval = data.frame(run = i,
                        model = "IDM",
                        AUC = voscham.idm.auc$AUC,
                        TSS = max(voscham.idm.tssdf$TSS),
                        tstar = voscham.idm.tssdf[voscham.idm.tstar, 1],
                        sens_star = voscham.idm.tssdf[voscham.idm.tstar, 4],
                        spec_star = voscham.idm.tssdf[voscham.idm.tstar, 5])
  
  voscham.evaldf = bind_rows(voscham.evaldf, voscham.overlap.eval, voscham.idm.eval)
  
  # Step 5: Calculate threshold difference
  tstar.overlap = (voscham.evaldf %>%
    filter(run == i,
           model == "overlap"))$tstar
  overlap.thresh = clamp(voscham.overlapnorm, lower = tstar.overlap, upper = 1, values = T)
  overlap.thresh[overlap.thresh > tstar.overlap] = 1
  overlap.thresh[overlap.thresh <= tstar.overlap] = 0
  voscham.overlapthresh[[i]] = overlap.thresh
  
  tstar.idm = (voscham.evaldf %>%
    filter(run == i,
           model == "IDM"))$tstar
  idm.thresh = clamp(voscham.idmnorm, lower = tstar.idm, upper = 1, values = T)
  idm.thresh[idm.thresh > tstar.idm] = 1
  idm.thresh[idm.thresh <= tstar.idm] = 0
  voscham.idmthresh[[i]] = idm.thresh
  
  shared = overlap.thresh + idm.thresh
  diff = idm.thresh - overlap.thresh
  
  shared.df = data.frame(run = i,
                         n_shared = length(shared[shared == 2]),
                         n_IDM = length(diff[diff == 1]),
                         n_overlap = length(diff[diff == -1])) %>%
    mutate(prop.shared = n_shared/(n_shared + n_IDM + n_overlap),
           prop.idm = n_IDM/(n_shared + n_IDM + n_overlap),
           prop.overlap = n_overlap/(n_shared + n_IDM + n_overlap))
  
  voscham.thresholddf = bind_rows(voscham.thresholddf, shared.df)
  
  #   # Step 5: Save Variable Importance
  # idm.vars = data.frame(run = rep(i, 20),
  #                       model = rep("IDM", 20),
  #                       variable = names(voscham.maxent@results[7:26,]),
  #                       percent = voscham.maxent@results[7:26],
  #                       permutation = voscham.maxent@results[27:46])
  # 
  # voscham.varimpdf = bind_rows(voscham.varimpdf, idm.vars)
}

write.csv(voscham.evaldf, file = "completed-evals/voscham-eval.csv")
write.csv(voscham.thresholddf, file = "completed-evals/voscham-threshold.csv")
# write.csv(voscham.varimpdf, file = "completed-evals/voscham-varimport.csv")
save(voscham.overlaplist, file = "voscham-overlaps.RData")
save(voscham.idmlist, file = "voscham-idms.RData")
```

```{r voscham ensemble}
voscham.overlap.ensemble <- raster(mean(rast(voscham.overlaplist[c(1:100)])))
voscham.overlap.spdf <- as(voscham.overlap.ensemble, "SpatialPixelsDataFrame")
voscham.overlap.df <- as.data.frame(voscham.overlap.spdf)

voscham.overlap.plot <- ggplot() +
  geom_tile(data = voscham.overlap.df, aes(x = x, y = y, fill = mean)) +
  coord_cartesian(xlim = c(-130, -110), ylim = c(40, 50)) +
  theme_map() +
  scale_fill_viridis(option = "magma", 
                     limits = c(0, 1))
ggsave("figures/voscham-overlap.png", voscham.overlap.plot, width = 6, height = 4, units = "in")

voscham.idm.ensemble <- raster(mean(rast(voscham.idmlist[c(1:100)])))
voscham.idm.spdf <- as(voscham.idm.ensemble, "SpatialPixelsDataFrame")
voscham.idm.df <- as.data.frame(voscham.idm.spdf)

voscham.idm.plot <- ggplot() +
  geom_tile(data = voscham.idm.df, aes(x = x, y = y, fill = mean)) +
  coord_cartesian(xlim = c(-130, -110), ylim = c(40, 50)) +
  theme_map() +
  scale_fill_viridis(option = "magma", 
                     limits = c(0, 1))
ggsave("figures/voscham-idm.png", voscham.idm.plot, width = 6, height = 4, units = "in")
```

## Cirsium

```{r vos cir data, message = F}
gbif.cir <- gbif %>%
  filter(genus == "Cirsium")

voscir <- bbna %>% 
  filter(species == "vosnesenskii",
         plant.host.genus == "Cirsium") %>%
  dplyr::select(latitude, longitude, plant.host.genus, date, month, day, year)
```

```{r voscir maxent for loop, message = F, eval = T, results = "hide"}
voscir.overlaplist <- vector(mode = "list", length = 100)
voscir.idmlist <- vector(mode = "list", length = 100)
voscir.overlapthresh <- vector(mode = "list", length = 100)
voscir.idmthresh <- vector(mode = "list", length = 100)

voscir.evaldf <- data.frame()
voscir.thresholddf <- data.frame()
# voscir.varimpdf <- data.frame()

set.seed(261402)
for(i in 1:100){
  # Step 1: separate all data into training and testing datasets
  bg <- as.data.frame(spatSample(x = bioclim, size = 10000, method = "random", na.rm = T, xy = T)) %>%
    dplyr::select(x, y) %>%
    rename(longitude = x,
           latitude = y)
  bgfold <- kfold(bg, k = 5)
  bg.test <- bg[bgfold == 1,]
  bg.train <- bg[bgfold != 1,]
  
  vos.longlat <- bbna %>%
    filter(species == "vosnesenskii",
           plant.host.genus != "Cirsium") %>%
    slice_sample(by = BBNA.code, n = 1) %>%
    dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  vos.fold <- kfold(vos.longlat, k = 5)
  vos.test <- vos.longlat[vos.fold == 1,]
  vos.train <- vos.longlat[vos.fold != 1,]
  
  cir.longlat <- gbif.cir %>%
  dplyr::select(decimalLongitude, decimalLatitude) %>%
  as.data.frame(.) %>%
  rename(longitude = decimalLongitude,
         latitude = decimalLatitude)
  cir.fold <- kfold(cir.longlat, k = 5)
  cir.test <- cir.longlat[cir.fold == 1,]
  cir.train <- cir.longlat[cir.fold != 1,]
  
  voscir.longlat <- voscir %>%
  dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  voscir.fold <- kfold(voscir.longlat, k = 5)
  voscir.test <- voscir.longlat[voscir.fold == 1,]
  voscir.train <- voscir.longlat[voscir.fold != 1,]

  
  
  # Step 2: Calculate overlaps
  ## Step 2a: Individual models
  vos.maxent <- maxent(x = stack(bioclim),
                       p = vos.train, 
                       a = bg.train)
  vos.predict <- dismo::predict(vos.maxent,
                                stack(bioclim))
  
  cir.maxent <- maxent(x = stack(bioclim), 
                       p = cir.train, 
                       a = bg.train)
  cir.predict <- dismo::predict(cir.maxent,
                                stack(bioclim))
  
  ## Step 2b: Multiply bee and plant habitat suitability to get a joint probability
  voscir.overlap <- as(vos.predict * cir.predict, "SpatRaster")
  voscir.overlaplist[[i]] = voscir.overlap
  
  
  
  # Step 3: Calculate IDM
  voscir.maxent <- maxent(x = stack(bioclim), 
                          p = voscir.train, 
                          a = bg.train)
  
  voscir.idm <- as(dismo::predict(voscir.maxent, stack(bioclim)), "SpatRaster")
  voscir.idmlist[[i]] = voscir.idm
  
  
  
  # Step 4: Evaluate overlap model and IDM with the same interaction test data
  ## Step 4a: Normalize rasters for RMSE calculation
  voscir.idmnorm = (voscir.idm - minmax(voscir.idm)[1,])/(minmax(voscir.idm)[2,] - minmax(voscir.idm)[1,])
  voscir.overlapnorm = (voscir.overlap - minmax(voscir.overlap)[1,])/(minmax(voscir.overlap)[2,] - minmax(voscir.overlap)[1,])
  
  ## Step 4b: Use modEvA::AUC to get AUC
  voscir.overlap.auc <- AUC(obs = voscir.test, pred = voscir.overlapnorm)
  voscir.idm.auc <- AUC(obs = voscir.test, pred = voscir.idmnorm)
  
  ## Step 4c: Calculate TSS and tstar
  voscir.overlap.tssdf <- voscir.overlap.auc$thresholds %>%
    mutate(TSS = sensitivity + specificity - 1)
  voscir.overlap.tstar <- which.max(voscir.overlap.tssdf$TSS)
  voscir.idm.tssdf <- voscir.idm.auc$thresholds %>%
    mutate(TSS = sensitivity + specificity - 1)
  voscir.idm.tstar <- which.max(voscir.idm.tssdf$TSS)
  
  ## Step 4d: Save evaluation scores
  ### Note: RMSE is the same for both so it is only noted under the overlap
  voscir.overlap.eval = data.frame(run = i,
                        model = "overlap",
                        AUC = voscir.overlap.auc$AUC,
                        TSS = max(voscir.overlap.tssdf$TSS),
                        tstar = voscir.overlap.tssdf[voscir.overlap.tstar, 1],
                        sens_star = voscir.overlap.tssdf[voscir.overlap.tstar, 4],
                        spec_star = voscir.overlap.tssdf[voscir.overlap.tstar, 5],
                        RMSE = predicts::RMSE(na.omit(values(voscir.idmnorm)), na.omit(values(voscir.overlapnorm)), na.rm = T))

  voscir.idm.eval = data.frame(run = i,
                        model = "IDM",
                        AUC = voscir.idm.auc$AUC,
                        TSS = max(voscir.idm.tssdf$TSS),
                        tstar = voscir.idm.tssdf[voscir.idm.tstar, 1],
                        sens_star = voscir.idm.tssdf[voscir.idm.tstar, 4],
                        spec_star = voscir.idm.tssdf[voscir.idm.tstar, 5])
  
  voscir.evaldf = bind_rows(voscir.evaldf, voscir.overlap.eval, voscir.idm.eval)
  
  # Step 5: Calculate threshold difference
  tstar.overlap = (voscir.evaldf %>%
    filter(run == i,
           model == "overlap"))$tstar
  overlap.thresh = clamp(voscir.overlapnorm, lower = tstar.overlap, upper = 1, values = T)
  overlap.thresh[overlap.thresh > tstar.overlap] = 1
  overlap.thresh[overlap.thresh <= tstar.overlap] = 0
  voscir.overlapthresh[[i]] = overlap.thresh
  
  tstar.idm = (voscir.evaldf %>%
    filter(run == i,
           model == "IDM"))$tstar
  idm.thresh = clamp(voscir.idmnorm, lower = tstar.idm, upper = 1, values = T)
  idm.thresh[idm.thresh > tstar.idm] = 1
  idm.thresh[idm.thresh <= tstar.idm] = 0
  voscir.idmthresh[[i]] = idm.thresh
  
  shared = overlap.thresh + idm.thresh
  diff = idm.thresh - overlap.thresh
  
  shared.df = data.frame(run = i,
                         n_shared = length(shared[shared == 2]),
                         n_IDM = length(diff[diff == 1]),
                         n_overlap = length(diff[diff == -1])) %>%
    mutate(prop.shared = n_shared/(n_shared + n_IDM + n_overlap),
           prop.idm = n_IDM/(n_shared + n_IDM + n_overlap),
           prop.overlap = n_overlap/(n_shared + n_IDM + n_overlap))
  
  voscir.thresholddf = bind_rows(voscir.thresholddf, shared.df)
  
  #   # Step 5: Save Variable Importance
  # idm.vars = data.frame(run = rep(i, 20),
  #                       model = rep("IDM", 20),
  #                       variable = names(voscir.maxent@results[7:26,]),
  #                       percent = voscir.maxent@results[7:26],
  #                       permutation = voscir.maxent@results[27:46])
  # 
  # voscir.varimpdf = bind_rows(voscir.varimpdf, idm.vars)
}

write.csv(voscir.evaldf, file = "completed-evals/voscir-eval.csv")
write.csv(voscir.thresholddf, file = "completed-evals/voscir-threshold.csv")
# write.csv(voscir.varimpdf, file = "completed-evals/voscir-varimport.csv")
save(voscir.overlaplist, file = "voscir-overlaps.RData")
save(voscir.idmlist, file = "voscir-idms.RData")
```

```{r voscir ensemble}
voscir.overlap.ensemble <- raster(mean(rast(voscir.overlaplist[c(1:100)])))
voscir.overlap.spdf <- as(voscir.overlap.ensemble, "SpatialPixelsDataFrame")
voscir.overlap.df <- as.data.frame(voscir.overlap.spdf)

voscir.overlap.plot <- ggplot() +
  geom_tile(data = voscir.overlap.df, aes(x = x, y = y, fill = mean)) +
  coord_cartesian(xlim = c(-130, -110), ylim = c(40, 50)) +
  theme_map() +
  scale_fill_viridis(option = "magma", 
                     limits = c(0, 1))
ggsave("figures/voscir-overlap.png", voscir.overlap.plot, width = 6, height = 4, units = "in")

voscir.idm.ensemble <- raster(mean(rast(voscir.idmlist[c(1:100)])))
voscir.idm.spdf <- as(voscir.idm.ensemble, "SpatialPixelsDataFrame")
voscir.idm.df <- as.data.frame(voscir.idm.spdf)

voscir.idm.plot <- ggplot() +
  geom_tile(data = voscir.idm.df, aes(x = x, y = y, fill = mean)) +
  coord_cartesian(xlim = c(-130, -110), ylim = c(40, 50)) +
  theme_map() +
  scale_fill_viridis(option = "magma", 
                     limits = c(0, 1))
ggsave("figures/voscir-idm.png", voscir.idm.plot, width = 6, height = 4, units = "in")
```

## Lupinus

```{r vos lup data, message = F}
gbif.lup <- gbif %>%
  filter(genus == "Lupinus")

voslup <- bbna %>% 
  filter(species == "vosnesenskii",
         plant.host.genus == "Lupinus") %>%
  dplyr::select(latitude, longitude, plant.host.genus, date, month, day, year)
```

```{r voslup maxent for loop, message = F}
voslup.overlaplist <- vector(mode = "list", length = 100)
voslup.idmlist <- vector(mode = "list", length = 100)
voslup.overlapthresh <- vector(mode = "list", length = 100)
voslup.idmthresh <- vector(mode = "list", length = 100)

voslup.evaldf <- data.frame()
voslup.thresholddf <- data.frame()
# voslup.varimpdf <- data.frame()

set.seed(122323)
for(i in 1:100){
  # Step 1: separate all data into training and testing datasets
  bg <- as.data.frame(spatSample(x = bioclim, size = 10000, method = "random", na.rm = T, xy = T)) %>%
    dplyr::select(x, y) %>%
    rename(longitude = x,
           latitude = y)
  bgfold <- kfold(bg, k = 5)
  bg.test <- bg[bgfold == 1,]
  bg.train <- bg[bgfold != 1,]
  
  vos.longlat <- bbna %>%
    filter(species == "vosnesenskii",
           plant.host.genus != "Lupinus") %>%
    slice_sample(by = BBNA.code, n = 1) %>%
    dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  vos.fold <- kfold(vos.longlat, k = 5)
  vos.test <- vos.longlat[vos.fold == 1,]
  vos.train <- vos.longlat[vos.fold != 1,]
  
  lup.longlat <- gbif.lup %>%
  dplyr::select(decimalLongitude, decimalLatitude) %>%
  as.data.frame(.) %>%
  rename(longitude = decimalLongitude,
         latitude = decimalLatitude)
  lup.fold <- kfold(lup.longlat, k = 5)
  lup.test <- lup.longlat[lup.fold == 1,]
  lup.train <- lup.longlat[lup.fold != 1,]
  
  voslup.longlat <- voslup %>%
  dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  voslup.fold <- kfold(voslup.longlat, k = 5)
  voslup.test <- voslup.longlat[voslup.fold == 1,]
  voslup.train <- voslup.longlat[voslup.fold != 1,]

  
  
  # Step 2: Calculate overlaps
  ## Step 2a: Individual models
  vos.maxent <- maxent(x = stack(bioclim),
                       p = vos.train, 
                       a = bg.train)
  vos.predict <- dismo::predict(vos.maxent,
                                stack(bioclim))
  
  lup.maxent <- maxent(x = stack(bioclim), 
                       p = lup.train, 
                       a = bg.train)
  lup.predict <- dismo::predict(lup.maxent,
                                stack(bioclim))
  
  ## Step 2b: Multiply bee and plant habitat suitability to get a joint probability
  voslup.overlap <- as(vos.predict * lup.predict, "SpatRaster")
  voslup.overlaplist[[i]] = voslup.overlap
  
  
  
  # Step 3: Calculate IDM
  voslup.maxent <- maxent(x = stack(bioclim), 
                          p = voslup.train, 
                          a = bg.train)
  
  voslup.idm <- as(dismo::predict(voslup.maxent, stack(bioclim)), "SpatRaster")
  voslup.idmlist[[i]] = voslup.idm
  
  
  
  # Step 4: Evaluate overlap model and IDM with the same interaction test data
  ## Step 4a: Normalize rasters
  voslup.idmnorm = (voslup.idm - minmax(voslup.idm)[1,])/(minmax(voslup.idm)[2,] - minmax(voslup.idm)[1,])
  voslup.overlapnorm = (voslup.overlap - minmax(voslup.overlap)[1,])/(minmax(voslup.overlap)[2,] - minmax(voslup.overlap)[1,])
  
  ## Step 4b: Use modEvA::AUC to get AUC
  voslup.overlap.auc <- AUC(obs = voslup.test, pred = voslup.overlapnorm)
  voslup.idm.auc <- AUC(obs = voslup.test, pred = voslup.idmnorm)
  
  ## Step 4c: Calculate TSS and tstar
  voslup.overlap.tssdf <- voslup.overlap.auc$thresholds %>%
    mutate(TSS = sensitivity + specificity - 1)
  voslup.overlap.tstar <- which.max(voslup.overlap.tssdf$TSS)
  voslup.idm.tssdf <- voslup.idm.auc$thresholds %>%
    mutate(TSS = sensitivity + specificity - 1)
  voslup.idm.tstar <- which.max(voslup.idm.tssdf$TSS)
  
  ## Step 4d: Save evaluation scores
  ### Note: RMSE is the same for both so it is only noted under the overlap
  voslup.overlap.eval = data.frame(run = i,
                        model = "overlap",
                        AUC = voslup.overlap.auc$AUC,
                        TSS = max(voslup.overlap.tssdf$TSS),
                        tstar = voslup.overlap.tssdf[voslup.overlap.tstar, 1],
                        sens_star = voslup.overlap.tssdf[voslup.overlap.tstar, 4],
                        spec_star = voslup.overlap.tssdf[voslup.overlap.tstar, 5],
                        RMSE = predicts::RMSE(na.omit(values(voslup.idmnorm)), na.omit(values(voslup.overlapnorm)), na.rm = T))

  voslup.idm.eval = data.frame(run = i,
                        model = "IDM",
                        AUC = voslup.idm.auc$AUC,
                        TSS = max(voslup.idm.tssdf$TSS),
                        tstar = voslup.idm.tssdf[voslup.idm.tstar, 1],
                        sens_star = voslup.idm.tssdf[voslup.idm.tstar, 4],
                        spec_star = voslup.idm.tssdf[voslup.idm.tstar, 5])
  
  voslup.evaldf = bind_rows(voslup.evaldf, voslup.overlap.eval, voslup.idm.eval)
  
  # Step 5: Calculate threshold difference
  tstar.overlap = (voslup.evaldf %>%
    filter(run == i,
           model == "overlap"))$tstar
  overlap.thresh = clamp(voslup.overlapnorm, lower = tstar.overlap, upper = 1, values = T)
  overlap.thresh[overlap.thresh > tstar.overlap] = 1
  overlap.thresh[overlap.thresh <= tstar.overlap] = 0
  voslup.overlapthresh[[i]] = overlap.thresh
  
  tstar.idm = (voslup.evaldf %>%
    filter(run == i,
           model == "IDM"))$tstar
  idm.thresh = clamp(voslup.idmnorm, lower = tstar.idm, upper = 1, values = T)
  idm.thresh[idm.thresh > tstar.idm] = 1
  idm.thresh[idm.thresh <= tstar.idm] = 0
  voslup.idmthresh[[i]] = idm.thresh
  
  shared = overlap.thresh + idm.thresh
  diff = idm.thresh - overlap.thresh
  
  shared.df = data.frame(run = i,
                         n_shared = length(shared[shared == 2]),
                         n_IDM = length(diff[diff == 1]),
                         n_overlap = length(diff[diff == -1])) %>%
    mutate(prop.shared = n_shared/(n_shared + n_IDM + n_overlap),
           prop.idm = n_IDM/(n_shared + n_IDM + n_overlap),
           prop.overlap = n_overlap/(n_shared + n_IDM + n_overlap))
  
  voslup.thresholddf = bind_rows(voslup.thresholddf, shared.df)
  
  #   # Step 5: Save Variable Importance
  # idm.vars = data.frame(run = rep(i, 20),
  #                       model = rep("IDM", 20),
  #                       variable = names(voslup.maxent@results[7:26,]),
  #                       percent = voslup.maxent@results[7:26],
  #                       permutation = voslup.maxent@results[27:46])
  # 
  # voslup.varimpdf = bind_rows(voslup.varimpdf, idm.vars)
}

write.csv(voslup.evaldf, file = "completed-evals/voslup-eval.csv")
write.csv(voslup.thresholddf, file = "completed-evals/voslup-threshold.csv")
# write.csv(voslup.varimpdf, file = "completed-evals/voslup-varimport.csv")
save(voslup.overlaplist, file = "voslup-overlaps.RData")
save(voslup.idmlist, file = "voslup-idms.RData")
```

```{r voslup ensemble}
voslup.overlap.ensemble <- raster(mean(rast(voslup.overlaplist[c(1:100)])))
voslup.overlap.spdf <- as(voslup.overlap.ensemble, "SpatialPixelsDataFrame")
voslup.overlap.df <- as.data.frame(voslup.overlap.spdf)

voslup.overlap.plot <- ggplot() +
  geom_tile(data = voslup.overlap.df, aes(x = x, y = y, fill = mean)) +
  coord_cartesian(xlim = c(-130, -110), ylim = c(40, 50)) +
  theme_map() +
  scale_fill_viridis(option = "magma", 
                     limits = c(0, 1))
ggsave("figures/voslup-overlap.png", voslup.overlap.plot, width = 6, height = 4, units = "in")

voslup.idm.ensemble <- raster(mean(rast(voslup.idmlist[c(1:100)])))
voslup.idm.spdf <- as(voslup.idm.ensemble, "SpatialPixelsDataFrame")
voslup.idm.df <- as.data.frame(voslup.idm.spdf)

voslup.idm.plot <- ggplot() +
  geom_tile(data = voslup.idm.df, aes(x = x, y = y, fill = mean)) +
  coord_cartesian(xlim = c(-130, -110), ylim = c(40, 50)) +
  theme_map() +
  scale_fill_viridis(option = "magma", 
                     limits = c(0, 1))
ggsave("figures/voslup-idm.png", voslup.idm.plot, width = 6, height = 4, units = "in")
```

## Penstemon

```{r vos pen data, message = F}
gbif.pen <- gbif %>%
  filter(genus == "Penstemon")

vospen <- bbna %>% 
  filter(species == "vosnesenskii",
         plant.host.genus == "Penstemon") %>%
  dplyr::select(latitude, longitude, plant.host.genus, date, month, day, year)
```

```{r vospen maxent for loop, message = F}
vospen.overlaplist <- vector(mode = "list", length = 100)
vospen.idmlist <- vector(mode = "list", length = 100)
vospen.overlapthresh <- vector(mode = "list", length = 100)
vospen.idmthresh <- vector(mode = "list", length = 100)

vospen.evaldf <- data.frame()
vospen.thresholddf <- data.frame()
# vospen.varimpdf <- data.frame()

set.seed(65784)
for(i in 1:100){
  # Step 1: separate all data into training and testing datasets
  bg <- as.data.frame(spatSample(x = bioclim, size = 10000, method = "random", na.rm = T, xy = T)) %>%
    dplyr::select(x, y) %>%
    rename(longitude = x,
           latitude = y)
  bgfold <- kfold(bg, k = 5)
  bg.test <- bg[bgfold == 1,]
  bg.train <- bg[bgfold != 1,]
  
  vos.longlat <- bbna %>%
    filter(species == "vosnesenskii",
           plant.host.genus != "Penstemon") %>%
    slice_sample(by = BBNA.code, n = 1) %>%
    dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  vos.fold <- kfold(vos.longlat, k = 5)
  vos.test <- vos.longlat[vos.fold == 1,]
  vos.train <- vos.longlat[vos.fold != 1,]
  
  pen.longlat <- gbif.pen %>%
  dplyr::select(decimalLongitude, decimalLatitude) %>%
  as.data.frame(.) %>%
  rename(longitude = decimalLongitude,
         latitude = decimalLatitude)
  pen.fold <- kfold(pen.longlat, k = 5)
  pen.test <- pen.longlat[pen.fold == 1,]
  pen.train <- pen.longlat[pen.fold != 1,]
  
  vospen.longlat <- vospen %>%
  dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  vospen.fold <- kfold(vospen.longlat, k = 5)
  vospen.test <- vospen.longlat[vospen.fold == 1,]
  vospen.train <- vospen.longlat[vospen.fold != 1,]

  
  
  # Step 2: Calculate overlaps
  ## Step 2a: Individual models
  vos.maxent <- maxent(x = stack(bioclim),
                       p = vos.train, 
                       a = bg.train)
  vos.predict <- dismo::predict(vos.maxent,
                                stack(bioclim))
  
  pen.maxent <- maxent(x = stack(bioclim), 
                       p = pen.train, 
                       a = bg.train)
  pen.predict <- dismo::predict(pen.maxent,
                                stack(bioclim))
  
  ## Step 2b: Multiply bee and plant habitat suitability to get a joint probability
  vospen.overlap <- as(vos.predict * pen.predict, "SpatRaster")
  vospen.overlaplist[[i]] = vospen.overlap
  
  
  
  # Step 3: Calculate IDM
  vospen.maxent <- maxent(x = stack(bioclim), 
                          p = vospen.train, 
                          a = bg.train)
  
  vospen.idm <- as(dismo::predict(vospen.maxent, stack(bioclim)), "SpatRaster")
  vospen.idmlist[[i]] = vospen.idm
  
  
  
  # Step 4: Evaluate overlap model and IDM with the same interaction test data
  ## Step 4a: Normalize rasters
  vospen.idmnorm = (vospen.idm - minmax(vospen.idm)[1,])/(minmax(vospen.idm)[2,] - minmax(vospen.idm)[1,])
  vospen.overlapnorm = (vospen.overlap - minmax(vospen.overlap)[1,])/(minmax(vospen.overlap)[2,] - minmax(vospen.overlap)[1,])
  
  ## Step 4b: Use modEvA::AUC to get AUC
  vospen.overlap.auc <- AUC(obs = vospen.test, pred = vospen.overlapnorm)
  vospen.idm.auc <- AUC(obs = vospen.test, pred = vospen.idmnorm)
  
  ## Step 4c: Calculate TSS and tstar
  vospen.overlap.tssdf <- vospen.overlap.auc$thresholds %>%
    mutate(TSS = sensitivity + specificity - 1)
  vospen.overlap.tstar <- which.max(vospen.overlap.tssdf$TSS)
  vospen.idm.tssdf <- vospen.idm.auc$thresholds %>%
    mutate(TSS = sensitivity + specificity - 1)
  vospen.idm.tstar <- which.max(vospen.idm.tssdf$TSS)
  
  ## Step 4d: Save evaluation scores
  ### Note: RMSE is the same for both so it is only noted under the overlap
  vospen.overlap.eval = data.frame(run = i,
                        model = "overlap",
                        AUC = vospen.overlap.auc$AUC,
                        TSS = max(vospen.overlap.tssdf$TSS),
                        tstar = vospen.overlap.tssdf[vospen.overlap.tstar, 1],
                        sens_star = vospen.overlap.tssdf[vospen.overlap.tstar, 4],
                        spec_star = vospen.overlap.tssdf[vospen.overlap.tstar, 5],
                        RMSE = predicts::RMSE(na.omit(values(vospen.idmnorm)), na.omit(values(vospen.overlapnorm)), na.rm = T))

  vospen.idm.eval = data.frame(run = i,
                        model = "IDM",
                        AUC = vospen.idm.auc$AUC,
                        TSS = max(vospen.idm.tssdf$TSS),
                        tstar = vospen.idm.tssdf[vospen.idm.tstar, 1],
                        sens_star = vospen.idm.tssdf[vospen.idm.tstar, 4],
                        spec_star = vospen.idm.tssdf[vospen.idm.tstar, 5])
  
  vospen.evaldf = bind_rows(vospen.evaldf, vospen.overlap.eval, vospen.idm.eval)
  
  # Step 5: Calculate threshold difference
  tstar.overlap = (vospen.evaldf %>%
    filter(run == i,
           model == "overlap"))$tstar
  overlap.thresh = clamp(vospen.overlapnorm, lower = tstar.overlap, upper = 1, values = T)
  overlap.thresh[overlap.thresh > tstar.overlap] = 1
  overlap.thresh[overlap.thresh <= tstar.overlap] = 0
  vospen.overlapthresh[[i]] = overlap.thresh
  
  tstar.idm = (vospen.evaldf %>%
    filter(run == i,
           model == "IDM"))$tstar
  idm.thresh = clamp(vospen.idmnorm, lower = tstar.idm, upper = 1, values = T)
  idm.thresh[idm.thresh > tstar.idm] = 1
  idm.thresh[idm.thresh <= tstar.idm] = 0
  vospen.idmthresh[[i]] = idm.thresh
  
  shared = overlap.thresh + idm.thresh
  diff = idm.thresh - overlap.thresh
  
  shared.df = data.frame(run = i,
                         n_shared = length(shared[shared == 2]),
                         n_IDM = length(diff[diff == 1]),
                         n_overlap = length(diff[diff == -1])) %>%
    mutate(prop.shared = n_shared/(n_shared + n_IDM + n_overlap),
           prop.idm = n_IDM/(n_shared + n_IDM + n_overlap),
           prop.overlap = n_overlap/(n_shared + n_IDM + n_overlap))
  
  vospen.thresholddf = bind_rows(vospen.thresholddf, shared.df)
  
  #   # Step 5: Save Variable Importance
  # idm.vars = data.frame(run = rep(i, 20),
  #                       model = rep("IDM", 20),
  #                       variable = names(vospen.maxent@results[7:26,]),
  #                       percent = vospen.maxent@results[7:26],
  #                       permutation = vospen.maxent@results[27:46])
  # 
  # vospen.varimpdf = bind_rows(vospen.varimpdf, idm.vars)
}

write.csv(vospen.evaldf, file = "completed-evals/vospen-eval.csv")
write.csv(vospen.thresholddf, file = "completed-evals/vospen-threshold.csv")
# write.csv(vospen.varimpdf, file = "completed-evals/vospen-varimport.csv")
save(vospen.overlaplist, file = "vospen-overlaps.RData")
save(vospen.idmlist, file = "vospen-idms.RData")
```

```{r vospen ensemble}
vospen.overlap.ensemble <- raster(mean(rast(vospen.overlaplist[c(1:100)])))
vospen.overlap.spdf <- as(vospen.overlap.ensemble, "SpatialPixelsDataFrame")
vospen.overlap.df <- as.data.frame(vospen.overlap.spdf)

vospen.overlap.plot <- ggplot() +
  geom_tile(data = vospen.overlap.df, aes(x = x, y = y, fill = mean)) +
  coord_cartesian(xlim = c(-130, -110), ylim = c(40, 50)) +
  theme_map() +
  scale_fill_viridis(option = "magma", 
                     limits = c(0, 1))
ggsave("figures/vospen-overlap.png", vospen.overlap.plot, width = 6, height = 4, units = "in")

vospen.idm.ensemble <- raster(mean(rast(vospen.idmlist[c(1:100)])))
vospen.idm.spdf <- as(vospen.idm.ensemble, "SpatialPixelsDataFrame")
vospen.idm.df <- as.data.frame(vospen.idm.spdf)

vospen.idm.plot <- ggplot() +
  geom_tile(data = vospen.idm.df, aes(x = x, y = y, fill = mean)) +
  coord_cartesian(xlim = c(-130, -110), ylim = c(40, 50)) +
  theme_map() +
  scale_fill_viridis(option = "magma", 
                     limits = c(0, 1))
ggsave("figures/vospen-idm.png", vospen.idm.plot, width = 6, height = 4, units = "in")
```

## Rubus

```{r vos rub data, message = F}
gbif.rub <- gbif %>%
  filter(genus == "Rubus")

vosrub <- bbna %>% 
  filter(species == "vosnesenskii",
         plant.host.genus == "Rubus") %>%
  dplyr::select(latitude, longitude, plant.host.genus, date, month, day, year)
```

```{r vosrub maxent for loop, message = F, eval = T, results = "hide"}
vosrub.overlaplist <- vector(mode = "list", length = 100)
vosrub.idmlist <- vector(mode = "list", length = 100)
vosrub.overlapthresh <- vector(mode = "list", length = 100)
vosrub.idmthresh <- vector(mode = "list", length = 100)

vosrub.evaldf <- data.frame()
vosrub.thresholddf <- data.frame()
# vosrub.varimpdf <- data.frame()

set.seed(11424)
for(i in 1:100){
  # Step 1: separate all data into training and testing datasets
  bg <- as.data.frame(spatSample(x = bioclim, size = 10000, method = "random", na.rm = T, xy = T)) %>%
    dplyr::select(x, y) %>%
    rename(longitude = x,
           latitude = y)
  bgfold <- kfold(bg, k = 5)
  bg.test <- bg[bgfold == 1,]
  bg.train <- bg[bgfold != 1,]
  
  vos.longlat <- bbna %>%
    filter(species == "vosnesenskii",
           plant.host.genus != "Rubus") %>%
    slice_sample(by = BBNA.code, n = 1) %>%
    dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  vos.fold <- kfold(vos.longlat, k = 5)
  vos.test <- vos.longlat[vos.fold == 1,]
  vos.train <- vos.longlat[vos.fold != 1,]
  
  rub.longlat <- gbif.rub %>%
  dplyr::select(decimalLongitude, decimalLatitude) %>%
  as.data.frame(.) %>%
  rename(longitude = decimalLongitude,
         latitude = decimalLatitude)
  rub.fold <- kfold(rub.longlat, k = 5)
  rub.test <- rub.longlat[rub.fold == 1,]
  rub.train <- rub.longlat[rub.fold != 1,]
  
  vosrub.longlat <- vosrub %>%
  dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  vosrub.fold <- kfold(vosrub.longlat, k = 5)
  vosrub.test <- vosrub.longlat[vosrub.fold == 1,]
  vosrub.train <- vosrub.longlat[vosrub.fold != 1,]

  
  
  # Step 2: Calculate overlaps
  ## Step 2a: Individual models
  vos.maxent <- maxent(x = stack(bioclim),
                       p = vos.train, 
                       a = bg.train)
  vos.predict <- dismo::predict(vos.maxent,
                                stack(bioclim))
  
  rub.maxent <- maxent(x = stack(bioclim), 
                       p = rub.train, 
                       a = bg.train)
  rub.predict <- dismo::predict(rub.maxent,
                                stack(bioclim))
  
  ## Step 2b: Multiply bee and plant habitat suitability to get a joint probability
  vosrub.overlap <- as(vos.predict * rub.predict, "SpatRaster")
  vosrub.overlaplist[[i]] = vosrub.overlap
  
  
  
  # Step 3: Calculate IDM
  vosrub.maxent <- maxent(x = stack(bioclim), 
                          p = vosrub.train, 
                          a = bg.train)
  
  vosrub.idm <- as(dismo::predict(vosrub.maxent, stack(bioclim)), "SpatRaster")
  vosrub.idmlist[[i]] = vosrub.idm
  
  
  
  # Step 4: Evaluate overlap model and IDM with the same interaction test data
  ## Step 4a: Normalize rasters
  vosrub.idmnorm = (vosrub.idm - minmax(vosrub.idm)[1,])/(minmax(vosrub.idm)[2,] - minmax(vosrub.idm)[1,])
  vosrub.overlapnorm = (vosrub.overlap - minmax(vosrub.overlap)[1,])/(minmax(vosrub.overlap)[2,] - minmax(vosrub.overlap)[1,])
  
  ## Step 4b: Use modEvA::AUC to get AUC
  vosrub.overlap.auc <- AUC(obs = vosrub.test, pred = vosrub.overlapnorm)
  vosrub.idm.auc <- AUC(obs = vosrub.test, pred = vosrub.idmnorm)
  
  ## Step 4c: Calculate TSS and tstar
  vosrub.overlap.tssdf <- vosrub.overlap.auc$thresholds %>%
    mutate(TSS = sensitivity + specificity - 1)
  vosrub.overlap.tstar <- which.max(vosrub.overlap.tssdf$TSS)
  vosrub.idm.tssdf <- vosrub.idm.auc$thresholds %>%
    mutate(TSS = sensitivity + specificity - 1)
  vosrub.idm.tstar <- which.max(vosrub.idm.tssdf$TSS)
  
  ## Step 4d: Save evaluation scores
  ### Note: RMSE is the same for both so it is only noted under the overlap
  vosrub.overlap.eval = data.frame(run = i,
                        model = "overlap",
                        AUC = vosrub.overlap.auc$AUC,
                        TSS = max(vosrub.overlap.tssdf$TSS),
                        tstar = vosrub.overlap.tssdf[vosrub.overlap.tstar, 1],
                        sens_star = vosrub.overlap.tssdf[vosrub.overlap.tstar, 4],
                        spec_star = vosrub.overlap.tssdf[vosrub.overlap.tstar, 5],
                        RMSE = predicts::RMSE(na.omit(values(vosrub.idmnorm)), na.omit(values(vosrub.overlapnorm)), na.rm = T))

  vosrub.idm.eval = data.frame(run = i,
                        model = "IDM",
                        AUC = vosrub.idm.auc$AUC,
                        TSS = max(vosrub.idm.tssdf$TSS),
                        tstar = vosrub.idm.tssdf[vosrub.idm.tstar, 1],
                        sens_star = vosrub.idm.tssdf[vosrub.idm.tstar, 4],
                        spec_star = vosrub.idm.tssdf[vosrub.idm.tstar, 5])
  
  vosrub.evaldf = bind_rows(vosrub.evaldf, vosrub.overlap.eval, vosrub.idm.eval)
  
  # Step 5: Calculate threshold difference
  tstar.overlap = (vosrub.evaldf %>%
    filter(run == i,
           model == "overlap"))$tstar
  overlap.thresh = clamp(vosrub.overlapnorm, lower = tstar.overlap, upper = 1, values = T)
  overlap.thresh[overlap.thresh > tstar.overlap] = 1
  overlap.thresh[overlap.thresh <= tstar.overlap] = 0
  vosrub.overlapthresh[[i]] = overlap.thresh
  
  tstar.idm = (vosrub.evaldf %>%
    filter(run == i,
           model == "IDM"))$tstar
  idm.thresh = clamp(vosrub.idmnorm, lower = tstar.idm, upper = 1, values = T)
  idm.thresh[idm.thresh > tstar.idm] = 1
  idm.thresh[idm.thresh <= tstar.idm] = 0
  vosrub.idmthresh[[i]] = idm.thresh
  
  shared = overlap.thresh + idm.thresh
  diff = idm.thresh - overlap.thresh
  
  shared.df = data.frame(run = i,
                         n_shared = length(shared[shared == 2]),
                         n_IDM = length(diff[diff == 1]),
                         n_overlap = length(diff[diff == -1])) %>%
    mutate(prop.shared = n_shared/(n_shared + n_IDM + n_overlap),
           prop.idm = n_IDM/(n_shared + n_IDM + n_overlap),
           prop.overlap = n_overlap/(n_shared + n_IDM + n_overlap))
  
  vosrub.thresholddf = bind_rows(vosrub.thresholddf, shared.df)
  
  #   # Step 5: Save Variable Importance
  # idm.vars = data.frame(run = rep(i, 20),
  #                       model = rep("IDM", 20),
  #                       variable = names(vosrub.maxent@results[7:26,]),
  #                       percent = vosrub.maxent@results[7:26],
  #                       permutation = vosrub.maxent@results[27:46])
  # 
  # vosrub.varimpdf = bind_rows(vosrub.varimpdf, idm.vars)
}

write.csv(vosrub.evaldf, file = "completed-evals/vosrub-eval.csv")
write.csv(vosrub.thresholddf, file = "completed-evals/vosrub-threshold.csv")
# write.csv(vosrub.varimpdf, file = "completed-evals/vosrub-varimport.csv")
save(vosrub.overlaplist, file = "vosrub-overlaps.RData")
save(vosrub.idmlist, file = "vosrub-idms.RData")
```

```{r vosrub ensemble}
vosrub.overlap.ensemble <- raster(mean(rast(vosrub.overlaplist[c(1:100)])))
vosrub.overlap.spdf <- as(vosrub.overlap.ensemble, "SpatialPixelsDataFrame")
vosrub.overlap.df <- as.data.frame(vosrub.overlap.spdf)

vosrub.overlap.plot <- ggplot() +
  geom_tile(data = vosrub.overlap.df, aes(x = x, y = y, fill = mean)) +
  coord_cartesian(xlim = c(-130, -110), ylim = c(40, 50)) +
  theme_map() +
  scale_fill_viridis(option = "magma", 
                     limits = c(0, 1))
ggsave("figures/vosrub-overlap.png", vosrub.overlap.plot, width = 6, height = 4, units = "in")

vosrub.idm.ensemble <- raster(mean(rast(vosrub.idmlist[c(1:100)])))
vosrub.idm.spdf <- as(vosrub.idm.ensemble, "SpatialPixelsDataFrame")
vosrub.idm.df <- as.data.frame(vosrub.idm.spdf)

vosrub.idm.plot <- ggplot() +
  geom_tile(data = vosrub.idm.df, aes(x = x, y = y, fill = mean)) +
  coord_cartesian(xlim = c(-130, -110), ylim = c(40, 50)) +
  theme_map() +
  scale_fill_viridis(option = "magma", 
                     limits = c(0, 1))
ggsave("figures/vosrub-idm.png", vosrub.idm.plot, width = 6, height = 4, units = "in")
```

# Session Info
```{r sessioninfo}
sessionInfo()
```

