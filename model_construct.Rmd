---
title: "IDM Model Construction"
author: "Kaysee Arrowsmith"
output: html_document
---

# Load Packages

```{r packages, message = F}
options(java.parameters = "- Xmx1024m")
library(knitr)
library(tidyverse)
library(raster)
library(geodata)
library(ENMTools)
# library(ggthemes)
# library(viridis)
library(predicts)
library(rJava)
library(modEvA)
library(pROC)

theme_set(theme_light() +
            theme(text = element_text(size = 20)))
```

# Main Bumble Bee Data
I'm using the Bumble Bees of North America data from 2018--2022, which includes data collected for the Pacific Northwest Bumble Bee Atlas.

```{r bumble bee data}
# pnwbba <- read.csv("pnwbba_raw.csv", stringsAsFactors = F) # BBNA data is more recent
bbna <- read.csv("bbna_pnwbba.csv", stringsAsFactors = F)

top.bees <- bbna %>% 
  group_by(species) %>% 
  tally() %>%
  slice_max(order_by = n, n = 4)

top.floralpartners <- bbna %>% 
  filter(plant.host.genus != "") %>%
  group_by(plant.host.genus) %>% 
  tally() %>%
  slice_max(order_by = n, n = 5)

top.ints <- bbna %>%
  # filter(species %in% top.bees$species,
         # plant.host.genus %in% top.floralpartners$plant.host.genus) %>%
  group_by(species, plant.host.genus) %>%
  tally()

ints.by.year <- bbna %>%
  filter(species %in% top.bees$species,
         plant.host.genus %in% top.floralpartners$plant.host.genus) %>%
  group_by(year, species, plant.host.genus) %>%
  tally()
```

# Plant Data
From GBIF.org (16 January 2024) GBIF Occurrence Download  https://doi.org/10.15468/dl.ymhzyy

```{r gbif}
gbif <- read_tsv("gbif-top5.csv") %>%
  filter(year >= 2018)
```

# WorldClim Data

I'm cropping all of these predictor rasters to the extreme points of my GBIF data.

```{r worldclim, message = F}
bioclim <- crop(worldclim_global(var = "bio", 
                               res = 2.5, 
                               path = getwd()),
                ext(-130, -110, 40, 50))
# 
# elev.rast <- crop(elevation_global(res = 2.5,
#                        path = getwd()), 
#                        ext(-130, -110, 40, 50))
# 
# bioclim.elev <- c(bioclim, elev.rast)
```

Per [Feng et al. (2019)](https://onlinelibrary.wiley.com/doi/pdf/10.1002/ece3.5555), collinearity in predictors is not a major problem for MaxEnt.


# Bifarius
## Chamaenerion

Now that all the code above is working, we will run it with a new pairing -- *B. bifarius* X [*Chamaenerion* sp.](https://doi.org/10.15468/dl.9apf52)

```{r bif cham data, message = F}
gbif.cham <- gbif %>%
  filter(genus == "Chamaenerion")

bifcham <- bbna %>%
  filter(species == "bifarius",
         plant.host.genus == "Chamaenerion") %>%
  dplyr::select(latitude, longitude, plant.host.genus, date, month, day, year)
```

```{r bifcham maxent for loop, message = F}
bifcham.evaldf <- data.frame()

bifcham.diffdf <- data.frame()

bifcham.varimpdf <- data.frame()

set.seed(121023)
for(i in 1:100){
  # Step 1: separate all data into training and testing datasets
  bg <- as.data.frame(spatSample(x = bioclim, size = 10000, method = "random", na.rm = T, xy = T)) %>%
    dplyr::select(x, y) %>%
    rename(longitude = x,
           latitude = y)
  bgfold <- kfold(bg, k = 5)
  bg.test <- bg[bgfold == 1,]
  bg.train <- bg[bgfold != 1,]
  
  bif.longlat <- bbna %>%
    filter(species == "bifarius",
           plant.host.genus != "Chamaenerion") %>%
    slice_sample(by = BBNA.code, n = 1) %>%
    dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  bif.fold <- kfold(bif.longlat, k = 5)
  bif.test <- bif.longlat[bif.fold == 1,]
  bif.train <- bif.longlat[bif.fold != 1,]
  
  cham.longlat <- gbif.cham %>%
  dplyr::select(decimalLongitude, decimalLatitude) %>%
  as.data.frame(.) %>%
  rename(longitude = decimalLongitude,
         latitude = decimalLatitude)
  cham.fold <- kfold(cham.longlat, k = 5)
  cham.test <- cham.longlat[cham.fold == 1,]
  cham.train <- cham.longlat[cham.fold != 1,]
  
  bifcham.longlat <- bifcham %>%
  dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  bifcham.fold <- kfold(bifcham.longlat, k = 5)
  bifcham.test <- bifcham.longlat[bifcham.fold == 1,]
  bifcham.train <- bifcham.longlat[bifcham.fold != 1,]
  
  
  
  # Step 2: Calculate overlaps
  ## Step 2a: Individual models
  bif.maxent <- maxent(x = stack(bioclim),
                       p = bif.train, 
                       a = bg.train)
  bif.predict <- dismo::predict(bif.maxent,
                                stack(bioclim))
  
  cham.maxent <- maxent(x = stack(bioclim), 
                       p = cham.train, 
                       a = bg.train)
  cham.predict <- dismo::predict(cham.maxent,
                                stack(bioclim))
  
  ## Step 2b: Multiply bee and plant habitat suitability to get a joint probability
  bifcham.overlap <- as(bif.predict * cham.predict, "SpatRaster")
  
  
  
  # Step 3: Calculate IDM
  bifcham.maxent <- maxent(x = stack(bioclim), 
                          p = bifcham.train, 
                          a = bg.train)
  
  bifcham.idm <- as(dismo::predict(bifcham.maxent, stack(bioclim)), "SpatRaster")
  
  
  
  # Step 4: Subtract predicted rasters to determine whether overlaps over- or under-predict interaction occurrence compared to IDM
  ### positive value = overlap over-predicts
  ### negative value = overlap under-predicts
  overlap_idm = data.frame(run = i, difference = (bifcham.overlap - bifcham.idm)[])

  bifcham.diffdf <- bind_rows(bifcham.diffdf, overlap_idm)
  
  # Step 5: Evaluate overlap model and IDM with the same interaction test data
  ## Step 5a: Use modEvA::AUC to get AUC
  bifcham.overlap.auc <- AUC(obs = bifcham.test, pred = bifcham.overlap)
  bifcham.idm.auc <- AUC(obs = bifcham.test, pred = bifcham.idm)
  
  
  ## Step 5b: Save Evaluation Scores
  bifcham.overlap.eval = data.frame(run = i,
                        model = "overlap",
                        AUC = bifcham.overlap.auc$AUC,
                        TSS = max(bifcham.overlap.auc$thresholds$sensitivity + bifcham.overlap.auc$thresholds$specificity - 1))

  bifcham.idm.eval = data.frame(run = i,
                        model = "IDM",
                        AUC = bifcham.idm.auc$AUC,
                        TSS = max(bifcham.idm.auc$thresholds$sensitivity + bifcham.idm.auc$thresholds$specificity - 1))
  
  bifcham.evaldf = bind_rows(bifcham.evaldf, bifcham.overlap.eval, bifcham.idm.eval)
}

write.csv(bifcham.diffdf, file = "completed-evals/bifcham-diff.csv")
write.csv(bifcham.evaldf, file = "completed-evals/bifcham-eval.csv")
# write.csv(bifcham.varimpdf, file = "completed-evals/bifcham-varimport.csv")
```

## Cirsium

```{r bif cir data, message = F}
gbif.cir <- gbif %>%
  filter(genus == "Cirsium")

bifcir <- bbna %>% 
  filter(species == "bifarius",
         plant.host.genus == "Cirsium") %>%
  dplyr::select(latitude, longitude, plant.host.genus, date, month, day, year)
```

```{r bifcir maxent for loop, message = F}
bifcir.evaldf <- data.frame()

bifcir.diffdf <- data.frame()

bifcir.varimpdf <- data.frame()

set.seed(7840126)
for(i in 1:100){
  # Step 1: separate all data into training and testing datasets
  bg <- as.data.frame(spatSample(x = bioclim, size = 10000, method = "random", na.rm = T, xy = T)) %>%
    dplyr::select(x, y) %>%
    rename(longitude = x,
           latitude = y)
  bgfold <- kfold(bg, k = 5)
  bg.test <- bg[bgfold == 1,]
  bg.train <- bg[bgfold != 1,]
  
  bif.longlat <- bbna %>%
    filter(species == "bifarius",
           plant.host.genus != "Cirsium") %>%
    slice_sample(by = BBNA.code, n = 1) %>%
    dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  bif.fold <- kfold(bif.longlat, k = 5)
  bif.test <- bif.longlat[bif.fold == 1,]
  bif.train <- bif.longlat[bif.fold != 1,]
  
  cir.longlat <- gbif.cir %>%
  dplyr::select(decimalLongitude, decimalLatitude) %>%
  as.data.frame(.) %>%
  rename(longitude = decimalLongitude,
         latitude = decimalLatitude)
  cir.fold <- kfold(cir.longlat, k = 5)
  cir.test <- cir.longlat[cir.fold == 1,]
  cir.train <- cir.longlat[cir.fold != 1,]
  
  bifcir.longlat <- bifcir %>%
  dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  bifcir.fold <- kfold(bifcir.longlat, k = 5)
  bifcir.test <- bifcir.longlat[bifcir.fold == 1,]
  bifcir.train <- bifcir.longlat[bifcir.fold != 1,]

  
  
  # Step 2: Calculate overlaps
  ## Step 2a: Individual models
  bif.maxent <- maxent(x = stack(bioclim),
                       p = bif.train, 
                       a = bg.train)
  bif.predict <- dismo::predict(bif.maxent,
                                stack(bioclim))
  
  cir.maxent <- maxent(x = stack(bioclim), 
                       p = cir.train, 
                       a = bg.train)
  cir.predict <- dismo::predict(cir.maxent,
                                stack(bioclim))
  
  ## Step 2b: Multiply bee and plant habitat suitability to get a joint probability
  bifcir.overlap <- as(bif.predict * cir.predict, "SpatRaster")
  
  
  
  # Step 3: Calculate IDM
  bifcir.maxent <- maxent(x = stack(bioclim), 
                          p = bifcir.train, 
                          a = bg.train)
  
  bifcir.idm <- as(dismo::predict(bifcir.maxent, stack(bioclim)), "SpatRaster")
  
  
  
  # Step 4: Subtract predicted rasters to determine whether overlaps over- or under-predict interaction occurrence compared to IDM
  ### positive value = overlap over-predicts
  ### negative value = overlap under-predicts
  overlap_idm = data.frame(run = i, difference = (bifcir.overlap - bifcir.idm)[])

  bifcir.diffdf <- bind_rows(bifcir.diffdf, overlap_idm)
  
  # Step 5: Evaluate overlap model and IDM with the same interaction test data
  ## Step 5a: Use modEvA::AUC to get AUC
  bifcir.overlap.auc <- AUC(obs = bifcir.test, pred = bifcir.overlap)
  bifcir.idm.auc <- AUC(obs = bifcir.test, pred = bifcir.idm)
  
  
  ## Step 5b: Save Evaluation Scores
  bifcir.overlap.eval = data.frame(run = i,
                        model = "overlap",
                        AUC = bifcir.overlap.auc$AUC,
                        TSS = max(bifcir.overlap.auc$thresholds$sensitivity + bifcir.overlap.auc$thresholds$specificity - 1))

  bifcir.idm.eval = data.frame(run = i,
                        model = "IDM",
                        AUC = bifcir.idm.auc$AUC,
                        TSS = max(bifcir.idm.auc$thresholds$sensitivity + bifcir.idm.auc$thresholds$specificity - 1))
  
  bifcir.evaldf = bind_rows(bifcir.evaldf, bifcir.overlap.eval, bifcir.idm.eval)
}

write.csv(bifcir.diffdf, file = "completed-evals/bifcir-diff.csv")
write.csv(bifcir.evaldf, file = "completed-evals/bifcir-eval.csv")
# write.csv(bifcir.varimpdf, file = "completed-evals/bifcir-varimport.csv")
```

## Lupinus

We will first run this with the most common bumble bee species/plant genus pairing -- *B. bifarius* visiting *Lupinus* sp.

```{r bif lup data, message = F}
gbif.lup <- gbif %>%
  filter(genus == "Lupinus")

biflup <- bbna %>% 
  filter(species == "bifarius",
         plant.host.genus == "Lupinus") %>%
  dplyr::select(latitude, longitude, plant.host.genus, date, month, day, year)
```

Here we have a for-loop running MaxEnt models 100 times. For each run, we will select new training and test data, calculate overlaps, and calculate an IDM. We then save the evaluation metrics (AUC, TSS) in a dataframe to assess the performance of the different methods.

```{r biflup maxent for loop, message = F}
biflup.evaldf <- data.frame()

biflup.diffdf <- data.frame()

biflup.varimpdf <- data.frame()

set.seed(122223)

for(i in 1:100){
  # Step 1: separate all data into training and testing datasets
  bg <- as.data.frame(spatSample(x = bioclim, size = 10000, method = "random", na.rm = T, xy = T)) %>%
    dplyr::select(x, y) %>%
    rename(longitude = x,
           latitude = y)
  bgfold <- kfold(bg, k = 5)
  bg.test <- bg[bgfold == 1,]
  bg.train <- bg[bgfold != 1,]
  
  bif.longlat <- bbna %>%
    filter(species == "bifarius",
           plant.host.genus != "Lupinus") %>%
    slice_sample(by = BBNA.code, n = 1) %>%
    dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  bif.fold <- kfold(bif.longlat, k = 5)
  bif.test <- bif.longlat[bif.fold == 1,]
  bif.train <- bif.longlat[bif.fold != 1,]
  
  lup.longlat <- gbif.lup %>%
  dplyr::select(decimalLongitude, decimalLatitude) %>%
  as.data.frame(.) %>%
  rename(longitude = decimalLongitude,
         latitude = decimalLatitude)
  lup.fold <- kfold(lup.longlat, k = 5)
  lup.test <- lup.longlat[lup.fold == 1,]
  lup.train <- lup.longlat[lup.fold != 1,]
  
  biflup.longlat <- biflup %>%
  dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  biflup.fold <- kfold(biflup.longlat, k = 5)
  biflup.test <- biflup.longlat[biflup.fold == 1,]
  biflup.train <- biflup.longlat[biflup.fold != 1,]

  # biflup.test <- biflup %>%
  #   filter(year == "2020") %>%
  # dplyr::select(longitude, latitude) %>%
  # as.data.frame(.)
  # biflup.train <- biflup %>%
  #   filter(year != "2020") %>%
  # dplyr::select(longitude, latitude) %>%
  # as.data.frame(.)

  
  
  # Step 2: Calculate overlaps
  ## Step 2a: Individual models
  bif.maxent <- maxent(x = stack(bioclim),
                       p = bif.train, 
                       a = bg.train)
  bif.predict <- dismo::predict(bif.maxent,
                                stack(bioclim))
  
  lup.maxent <- maxent(x = stack(bioclim), 
                       p = lup.train, 
                       a = bg.train)
  lup.predict <- dismo::predict(lup.maxent,
                                stack(bioclim))
  
  ## Step 2b: Multiply bee and plant habitat suitability to get a joint probability
  biflup.overlap <- as(bif.predict * lup.predict, "SpatRaster")
  
  
  
  # Step 3: Calculate IDM
  biflup.maxent <- maxent(x = stack(bioclim), 
                          p = biflup.train, 
                          a = bg.train)
  
  biflup.idm <- as(dismo::predict(biflup.maxent, stack(bioclim)), "SpatRaster")
  
  
  
  # Step 4: Subtract predicted rasters to determine whether overlaps over- or under-predict interaction occurrence compared to IDM
  ### positive value = overlap over-predicts
  ### negative value = overlap under-predicts
  overlap_idm = data.frame(run = i, difference = (biflup.overlap - biflup.idm)[])

  biflup.diffdf <- bind_rows(biflup.diffdf, overlap_idm)
  
  # Step 5: Evaluate overlap model and IDM with the same interaction test data
  ## Step 5a: Use modEvA::AUC to get AUC
  biflup.overlap.auc <- AUC(obs = biflup.test, pred = biflup.overlap)
  biflup.idm.auc <- AUC(obs = biflup.test, pred = biflup.idm)
  
  
  ## Step 5b: Save Evaluation Scores
  biflup.overlap.eval = data.frame(run = i,
                        model = "overlap",
                        AUC = biflup.overlap.auc$AUC,
                        TSS = max(biflup.overlap.auc$thresholds$sensitivity + biflup.overlap.auc$thresholds$specificity - 1))

  biflup.idm.eval = data.frame(run = i,
                        model = "IDM",
                        AUC = biflup.idm.auc$AUC,
                        TSS = max(biflup.idm.auc$thresholds$sensitivity + biflup.idm.auc$thresholds$specificity - 1))
  
  biflup.evaldf = bind_rows(biflup.evaldf, biflup.overlap.eval, biflup.idm.eval)
}

write.csv(biflup.diffdf, file = "completed-evals/biflup-diff.csv")
write.csv(biflup.evaldf, file = "completed-evals/biflup-eval.csv")
# write.csv(biflup.varimpdf, file = "completed-evals/biflup-varimport.csv")
```

<!-- ### L. polyphyllus -->

<!-- Here, we're looking at whether things change if we assume that all of the *Lupinus* records are one species. This allows us to use a species-specific plant distribution, but is probably not true on the interaction level. -->

<!-- I'm not re-making the IDM because it should be the same. If we include this in the final paper, we probably should just so that the same background points get selected. -->

<!-- ```{r bifarius X lupinus polyphyllus} -->
<!-- gbif.luppoly <- gbif %>% -->
<!--   filter(species == "Lupinus polyphyllus") -->

<!-- bifluppoly.evaldf <- data.frame() -->

<!-- bifluppoly.varimpdf <- data.frame() -->

<!-- set.seed(41924) -->

<!-- for(i in 1:100){ -->
<!--   # Step 1: separate all data into training and testing datasets -->
<!--   bg <- as.data.frame(spatSample(x = bioclim, size = 10000, method = "random", na.rm = T, xy = T)) %>% -->
<!--     dplyr::select(x, y) %>% -->
<!--     rename(longitude = x, -->
<!--            latitude = y) -->
<!--   bgfold <- kfold(bg, k = 5) -->
<!--   bg.test <- bg[bgfold == 1,] -->
<!--   bg.train <- bg[bgfold != 1,] -->

<!--   bif.longlat <- bbna %>% -->
<!--     filter(species == "bifarius", -->
<!--            plant.host.genus != "Lupinus") %>% -->
<!--     slice_sample(by = BBNA.code, n = 1) %>% -->
<!--     dplyr::select(longitude, latitude) %>% -->
<!--   as.data.frame(.) -->
<!--   bif.fold <- kfold(bif.longlat, k = 5) -->
<!--   bif.test <- bif.longlat[bif.fold == 1,] -->
<!--   bif.train <- bif.longlat[bif.fold != 1,] -->

<!--   luppoly.longlat <- gbif.luppoly %>% -->
<!--   dplyr::select(decimalLongitude, decimalLatitude) %>% -->
<!--   as.data.frame(.) %>% -->
<!--   rename(longitude = decimalLongitude, -->
<!--          latitude = decimalLatitude) -->
<!--   luppoly.fold <- kfold(luppoly.longlat, k = 5) -->
<!--   luppoly.test <- luppoly.longlat[luppoly.fold == 1,] -->
<!--   luppoly.train <- luppoly.longlat[luppoly.fold != 1,] -->

<!--   bifluppoly.longlat <- biflup %>% -->
<!--   dplyr::select(longitude, latitude) %>% -->
<!--   as.data.frame(.) -->
<!--   bifluppoly.fold <- kfold(bifluppoly.longlat, k = 5) -->
<!--   bifluppoly.test <- bifluppoly.longlat[bifluppoly.fold == 1,] -->
<!--   bifluppoly.train <- bifluppoly.longlat[bifluppoly.fold != 1,] -->



<!--   # Step 2: Calculate overlaps -->
<!--   ## Step 2a: Initial models based on just bioclim variables -->
<!--   bif.maxent <- maxent(x = stack(bioclim), -->
<!--                        p = bif.train,  -->
<!--                        a = bg.train) -->
<!--   bif.predict <- dismo::predict(bif.maxent, -->
<!--                                 stack(bioclim)) -->

<!--   luppoly.maxent <- maxent(x = stack(bioclim),  -->
<!--                        p = luppoly.train,  -->
<!--                        a = bg.train) -->
<!--   luppoly.predict <- dismo::predict(luppoly.maxent, -->
<!--                                 stack(bioclim)) -->

<!--   ## Step 2b: Updated models including partner -->
<!--   bif.by.luppoly <- maxent(x = stack(stack(bioclim), luppoly.predict), -->
<!--                        p = bif.train, -->
<!--                        a = bg.train) -->
<!--   luppoly.by.bif <- maxent(x = stack(stack(bioclim), bif.predict), -->
<!--                        p = luppoly.train, -->
<!--                        a = bg.train) -->




<!--   # Step 4: Evaluate all both overlap models and IDM with the same interaction test data -->
<!--   ## Step 4a: Use dismo::evaluate to get AUC and TSS scores -->
<!--   bifbyluppoly.eval <- dismo::evaluate(p = biflup.test, -->
<!--                                    a = bg.test, -->
<!--                                    model = bif.by.luppoly, -->
<!--                                    x = stack(stack(bioclim), luppoly.predict)) -->
<!--   luppolybybif.eval <- dismo::evaluate(p = biflup.test, -->
<!--                                    a = bg.test, -->
<!--                                    model = luppoly.by.bif, -->
<!--                                    x = stack(stack(bioclim), bif.predict)) -->


<!--   # Step 5: Save Evaluation Scores -->
<!--   bblpoly.eval = data.frame(run = i, -->
<!--                         model = "bblpoly", -->
<!--                         AUC = bifbyluppoly.eval@auc, -->
<!--                         cor = bifbyluppoly.eval@cor, -->
<!--                         TSS = max(bifbyluppoly.eval@TPR - bifbyluppoly.eval@FPR), -->
<!--                         tstar = which.max(bifbyluppoly.eval@TPR - bifbyluppoly.eval@FPR)) -->

<!--   lpolybb.eval = data.frame(run = i, -->
<!--                         model = "lpolybb", -->
<!--                         AUC = luppolybybif.eval@auc, -->
<!--                         cor = luppolybybif.eval@cor, -->
<!--                         TSS = max(luppolybybif.eval@TPR - luppolybybif.eval@FPR), -->
<!--                         tstar = which.max(luppolybybif.eval@TPR - luppolybybif.eval@FPR)) -->



<!--   bifluppoly.evaldf = bind_rows(bifluppoly.evaldf, bblpoly.eval, lpolybb.eval) -->

<!--   # Step 6: Save Variable Importance -->
<!--   bblpoly.vars = data.frame(run = rep(i, 21), -->
<!--                         model = rep("bblpoly", 21), -->
<!--                         variable = names(bif.by.luppoly@results[7:27,]), -->
<!--                         percent = bif.by.luppoly@results[7:27], -->
<!--                         permutation = bif.by.luppoly@results[28:48]) -->

<!--   lpolybb.vars = data.frame(run = rep(i, 21), -->
<!--                         model = rep("lpolybb", 21), -->
<!--                         variable = names(luppoly.by.bif@results[7:27,]), -->
<!--                         percent = luppoly.by.bif@results[7:27], -->
<!--                         permutation = luppoly.by.bif@results[28:48]) -->

<!--   bifluppoly.varimpdf = bind_rows(bifluppoly.varimpdf, bblpoly.vars, lpolybb.vars) -->
<!-- } -->
<!-- ``` -->

<!-- ### L. bicolor -->

<!-- ```{r bifarius X lupinus bicolor} -->
<!-- gbif.lupbicolor <- gbif %>% -->
<!--   filter(species == "Lupinus bicolor") -->

<!-- biflupbicolor.evaldf <- data.frame() -->

<!-- biflupbicolor.varimpdf <- data.frame() -->

<!-- set.seed(2024422) -->

<!-- for(i in 1:100){ -->
<!--   # Step 1: separate all data into training and testing datasets -->
<!--   bg <- as.data.frame(spatSample(x = bioclim, size = 10000, method = "random", na.rm = T, xy = T)) %>% -->
<!--     dplyr::select(x, y) %>% -->
<!--     rename(longitude = x, -->
<!--            latitude = y) -->
<!--   bgfold <- kfold(bg, k = 5) -->
<!--   bg.test <- bg[bgfold == 1,] -->
<!--   bg.train <- bg[bgfold != 1,] -->

<!--   bif.longlat <- bbna %>% -->
<!--     filter(species == "bifarius", -->
<!--            plant.host.genus != "Lupinus") %>% -->
<!--     slice_sample(by = BBNA.code, n = 1) %>% -->
<!--     dplyr::select(longitude, latitude) %>% -->
<!--   as.data.frame(.) -->
<!--   bif.fold <- kfold(bif.longlat, k = 5) -->
<!--   bif.test <- bif.longlat[bif.fold == 1,] -->
<!--   bif.train <- bif.longlat[bif.fold != 1,] -->

<!--   lupbicolor.longlat <- gbif.lupbicolor %>% -->
<!--   dplyr::select(decimalLongitude, decimalLatitude) %>% -->
<!--   as.data.frame(.) %>% -->
<!--   rename(longitude = decimalLongitude, -->
<!--          latitude = decimalLatitude) -->
<!--   lupbicolor.fold <- kfold(lupbicolor.longlat, k = 5) -->
<!--   lupbicolor.test <- lupbicolor.longlat[lupbicolor.fold == 1,] -->
<!--   lupbicolor.train <- lupbicolor.longlat[lupbicolor.fold != 1,] -->

<!--   biflup.longlat <- biflup %>% -->
<!--   dplyr::select(longitude, latitude) %>% -->
<!--   as.data.frame(.) -->
<!--   biflup.fold <- kfold(biflup.longlat, k = 5) -->
<!--   biflup.test <- biflup.longlat[biflup.fold == 1,] -->
<!--   biflup.train <- biflup.longlat[biflup.fold != 1,] -->



<!--   # Step 2: Calculate overlaps -->
<!--   ## Step 2a: Initial models based on just bioclim variables -->
<!--   bif.maxent <- maxent(x = stack(bioclim), -->
<!--                        p = bif.train,  -->
<!--                        a = bg.train) -->
<!--   bif.predict <- dismo::predict(bif.maxent, -->
<!--                                 stack(bioclim)) -->

<!--   lupbicolor.maxent <- maxent(x = stack(bioclim),  -->
<!--                        p = lupbicolor.train,  -->
<!--                        a = bg.train) -->
<!--   lupbicolor.predict <- dismo::predict(lupbicolor.maxent, -->
<!--                                 stack(bioclim)) -->

<!--   ## Step 2b: Updated models including partner -->
<!--   bif.by.lupbicolor <- maxent(x = stack(stack(bioclim), lupbicolor.predict), -->
<!--                        p = bif.train, -->
<!--                        a = bg.train) -->
<!--   lupbicolor.by.bif <- maxent(x = stack(stack(bioclim), bif.predict), -->
<!--                        p = lupbicolor.train, -->
<!--                        a = bg.train) -->




<!--   # Step 4: Evaluate all both overlap models and IDM with the same interaction test data -->
<!--   ## Step 4a: Use dismo::evaluate to get AUC and TSS scores -->
<!--   bifbylupbicolor.eval <- dismo::evaluate(p = biflup.test, -->
<!--                                    a = bg.test, -->
<!--                                    model = bif.by.lupbicolor, -->
<!--                                    x = stack(stack(bioclim), lupbicolor.predict)) -->
<!--   lupbicolorbybif.eval <- dismo::evaluate(p = biflup.test, -->
<!--                                    a = bg.test, -->
<!--                                    model = lupbicolor.by.bif, -->
<!--                                    x = stack(stack(bioclim), bif.predict)) -->


<!--   # Step 5: Save Evaluation Scores -->
<!--   bblbicolor.eval = data.frame(run = i, -->
<!--                         model = "bblbicolor", -->
<!--                         AUC = bifbylupbicolor.eval@auc, -->
<!--                         cor = bifbylupbicolor.eval@cor, -->
<!--                         TSS = max(bifbylupbicolor.eval@TPR - bifbylupbicolor.eval@FPR), -->
<!--                         tstar = which.max(bifbylupbicolor.eval@TPR - bifbylupbicolor.eval@FPR)) -->

<!--   lbicolorbb.eval = data.frame(run = i, -->
<!--                         model = "lbicolorbb", -->
<!--                         AUC = lupbicolorbybif.eval@auc, -->
<!--                         cor = lupbicolorbybif.eval@cor, -->
<!--                         TSS = max(lupbicolorbybif.eval@TPR - lupbicolorbybif.eval@FPR), -->
<!--                         tstar = which.max(lupbicolorbybif.eval@TPR - lupbicolorbybif.eval@FPR)) -->



<!--   biflupbicolor.evaldf = bind_rows(biflupbicolor.evaldf, bblbicolor.eval, lbicolorbb.eval) -->

<!--   # Step 6: Save Variable Importance -->
<!--   bblbicolor.vars = data.frame(run = rep(i, 21), -->
<!--                         model = rep("bblbicolor", 21), -->
<!--                         variable = names(bif.by.lupbicolor@results[7:27,]), -->
<!--                         percent = bif.by.lupbicolor@results[7:27], -->
<!--                         permutation = bif.by.lupbicolor@results[28:48]) -->

<!--   lbicolorbb.vars = data.frame(run = rep(i, 21), -->
<!--                         model = rep("lbicolorbb", 21), -->
<!--                         variable = names(lupbicolor.by.bif@results[7:27,]), -->
<!--                         percent = lupbicolor.by.bif@results[7:27], -->
<!--                         permutation = lupbicolor.by.bif@results[28:48]) -->

<!--   biflupbicolor.varimpdf = bind_rows(biflupbicolor.varimpdf, bblbicolor.vars, lbicolorbb.vars) -->
<!-- } -->
<!-- ``` -->


<!-- And let's look at some variable importance. -->

<!-- ```{r biflup variable importance} -->
<!-- var.idm <- ggplot(biflup.varimpdf %>% filter(model == "IDM"), aes(x = variable, y = percent)) + -->
<!--   geom_boxplot() + -->
<!--   theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) -->
<!-- var.idm -->
<!-- # 8, 14, 19, 6, 12 -->

<!-- var.bbl <- ggplot(biflup.varimpdf %>% filter(model == "bbl"), aes(x = variable, y = percent)) + -->
<!--   geom_boxplot() + -->
<!--   theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) -->
<!-- var.bbl -->
<!-- # 17, lupinus 12, 11 -->

<!-- var.lbb <- ggplot(biflup.varimpdf %>% filter(model == "lbb"), aes(x = variable, y = percent)) + -->
<!--   geom_boxplot() + -->
<!--   theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) -->
<!-- var.lbb -->
<!-- # 19, bifarius, elevation, 18 -->
<!-- ``` -->

<!-- I don't really know what to do with these yet. I think I'll probably run some statistics to confirm that they're statistically different between methods and then plot them out. -->

## Penstemon

```{r bif pen data, message = F}
gbif.pen <- gbif %>%
  filter(genus == "Penstemon")

bifpen <- bbna %>% 
  filter(species == "bifarius",
         plant.host.genus == "Penstemon") %>%
  dplyr::select(latitude, longitude, plant.host.genus, date, month, day, year)
```

```{r bifpen maxent for loop, message = F}
bifpen.evaldf <- data.frame()

bifpen.diffdf <- data.frame()

bifpen.varimpdf <- data.frame()

set.seed(122323)
for(i in 1:100){
  # Step 1: separate all data into training and testing datasets
  bg <- as.data.frame(spatSample(x = bioclim, size = 10000, method = "random", na.rm = T, xy = T)) %>%
    dplyr::select(x, y) %>%
    rename(longitude = x,
           latitude = y)
  bgfold <- kfold(bg, k = 5)
  bg.test <- bg[bgfold == 1,]
  bg.train <- bg[bgfold != 1,]
  
  bif.longlat <- bbna %>%
    filter(species == "bifarius",
           plant.host.genus != "Penstemon") %>%
    slice_sample(by = BBNA.code, n = 1) %>%
    dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  bif.fold <- kfold(bif.longlat, k = 5)
  bif.test <- bif.longlat[bif.fold == 1,]
  bif.train <- bif.longlat[bif.fold != 1,]
  
  pen.longlat <- gbif.pen %>%
  dplyr::select(decimalLongitude, decimalLatitude) %>%
  as.data.frame(.) %>%
  rename(longitude = decimalLongitude,
         latitude = decimalLatitude)
  pen.fold <- kfold(pen.longlat, k = 5)
  pen.test <- pen.longlat[pen.fold == 1,]
  pen.train <- pen.longlat[pen.fold != 1,]
  
  bifpen.longlat <- bifpen %>%
  dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  bifpen.fold <- kfold(bifpen.longlat, k = 5)
  bifpen.test <- bifpen.longlat[bifpen.fold == 1,]
  bifpen.train <- bifpen.longlat[bifpen.fold != 1,]

  
  
  # Step 2: Calculate overlaps
  ## Step 2a: Individual models
  bif.maxent <- maxent(x = stack(bioclim),
                       p = bif.train, 
                       a = bg.train)
  bif.predict <- dismo::predict(bif.maxent,
                                stack(bioclim))
  
  pen.maxent <- maxent(x = stack(bioclim), 
                       p = pen.train, 
                       a = bg.train)
  pen.predict <- dismo::predict(pen.maxent,
                                stack(bioclim))
  
  ## Step 2b: Multiply bee and plant habitat suitability to get a joint probability
  bifpen.overlap <- as(bif.predict * pen.predict, "SpatRaster")
  
  
  
  # Step 3: Calculate IDM
  bifpen.maxent <- maxent(x = stack(bioclim), 
                          p = bifpen.train, 
                          a = bg.train)
  
  bifpen.idm <- as(dismo::predict(bifpen.maxent, stack(bioclim)), "SpatRaster")
  
  
  
  # Step 4: Subtract predicted rasters to determine whether overlaps over- or under-predict interaction occurrence compared to IDM
  ### positive value = overlap over-predicts
  ### negative value = overlap under-predicts
  overlap_idm = data.frame(run = i, difference = (bifpen.overlap - bifpen.idm)[])

  bifpen.diffdf <- bind_rows(bifpen.diffdf, overlap_idm)
  
  # Step 5: Evaluate overlap model and IDM with the same interaction test data
  ## Step 5a: Use modEvA::AUC to get AUC
  bifpen.overlap.auc <- AUC(obs = bifpen.test, pred = bifpen.overlap)
  bifpen.idm.auc <- AUC(obs = bifpen.test, pred = bifpen.idm)
  
  
  ## Step 5b: Save Evaluation Scores
  bifpen.overlap.eval = data.frame(run = i,
                        model = "overlap",
                        AUC = bifpen.overlap.auc$AUC,
                        TSS = max(bifpen.overlap.auc$thresholds$sensitivity + bifpen.overlap.auc$thresholds$specificity - 1))

  bifpen.idm.eval = data.frame(run = i,
                        model = "IDM",
                        AUC = bifpen.idm.auc$AUC,
                        TSS = max(bifpen.idm.auc$thresholds$sensitivity + bifpen.idm.auc$thresholds$specificity - 1))
  
  bifpen.evaldf = bind_rows(bifpen.evaldf, bifpen.overlap.eval, bifpen.idm.eval)
}

write.csv(bifpen.diffdf, file = "completed-evals/bifpen-diff.csv")
write.csv(bifpen.evaldf, file = "completed-evals/bifpen-eval.csv")
# write.csv(bifpen.varimpdf, file = "completed-evals/bifpen-varimport.csv")
```

## Rubus
```{r flav rub data, message = F}
gbif.rub <- gbif %>%
  filter(genus == "Rubus")

bifrub <- bbna %>%
  filter(species == "bifarius",
         plant.host.genus == "Rubus") %>%
  dplyr::select(latitude, longitude, plant.host.genus, date, month, day, year)
```

```{r flavrub maxent for loop, message = F}
bifrub.evaldf <- data.frame()

bifrub.diffdf <- data.frame()

bifrub.varimpdf <- data.frame()

set.seed(429024)
for(i in 1:100){
  # Step 1: separate all data into training and testing datasets
  bg <- as.data.frame(spatSample(x = bioclim, size = 10000, method = "random", na.rm = T, xy = T)) %>%
    dplyr::select(x, y) %>%
    rename(longitude = x,
           latitude = y)
  bgfold <- kfold(bg, k = 5)
  bg.test <- bg[bgfold == 1,]
  bg.train <- bg[bgfold != 1,]
  
  bif.longlat <- bbna %>%
    filter(species == "bifarius",
           plant.host.genus != "Rubus") %>%
    slice_sample(by = BBNA.code, n = 1) %>%
    dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  bif.fold <- kfold(bif.longlat, k = 5)
  bif.test <- bif.longlat[bif.fold == 1,]
  bif.train <- bif.longlat[bif.fold != 1,]
  
  rub.longlat <- gbif.rub %>%
  dplyr::select(decimalLongitude, decimalLatitude) %>%
  as.data.frame(.) %>%
  rename(longitude = decimalLongitude,
         latitude = decimalLatitude)
  rub.fold <- kfold(rub.longlat, k = 5)
  rub.test <- rub.longlat[rub.fold == 1,]
  rub.train <- rub.longlat[rub.fold != 1,]
  
  bifrub.longlat <- bifrub %>%
  dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  bifrub.fold <- kfold(bifrub.longlat, k = 5)
  bifrub.test <- bifrub.longlat[bifrub.fold == 1,]
  bifrub.train <- bifrub.longlat[bifrub.fold != 1,]
  
  
  
  # Step 2: Calculate overlaps
  ## Step 2a: Individual models
  bif.maxent <- maxent(x = stack(bioclim),
                       p = bif.train, 
                       a = bg.train)
  bif.predict <- dismo::predict(bif.maxent,
                                stack(bioclim))
  
  rub.maxent <- maxent(x = stack(bioclim), 
                       p = rub.train, 
                       a = bg.train)
  rub.predict <- dismo::predict(rub.maxent,
                                stack(bioclim))
  
  ## Step 2b: Multiply bee and plant habitat suitability to get a joint probability
  bifrub.overlap <- as(bif.predict * rub.predict, "SpatRaster")
  
  
  
  # Step 3: Calculate IDM
  bifrub.maxent <- maxent(x = stack(bioclim), 
                          p = bifrub.train, 
                          a = bg.train)
  
  bifrub.idm <- as(dismo::predict(bifrub.maxent, stack(bioclim)), "SpatRaster")
  
  
  
  # Step 4: Subtract predicted rasters to determine whether overlaps over- or under-predict interaction occurrence compared to IDM
  ### positive value = overlap over-predicts
  ### negative value = overlap under-predicts
  overlap_idm = data.frame(run = i, difference = (bifrub.overlap - bifrub.idm)[])

  bifrub.diffdf <- bind_rows(bifrub.diffdf, overlap_idm)
  
  # Step 5: Evaluate overlap model and IDM with the same interaction test data
  ## Step 5a: Use modEvA::AUC to get AUC
  bifrub.overlap.auc <- AUC(obs = bifrub.test, pred = bifrub.overlap)
  bifrub.idm.auc <- AUC(obs = bifrub.test, pred = bifrub.idm)
  
  
  ## Step 5b: Save Evaluation Scores
  bifrub.overlap.eval = data.frame(run = i,
                        model = "overlap",
                        AUC = bifrub.overlap.auc$AUC,
                        TSS = max(bifrub.overlap.auc$thresholds$sensitivity + bifrub.overlap.auc$thresholds$specificity - 1))

  bifrub.idm.eval = data.frame(run = i,
                        model = "IDM",
                        AUC = bifrub.idm.auc$AUC,
                        TSS = max(bifrub.idm.auc$thresholds$sensitivity + bifrub.idm.auc$thresholds$specificity - 1))
  
  bifrub.evaldf = bind_rows(bifrub.evaldf, bifrub.overlap.eval, bifrub.idm.eval)
}

write.csv(bifrub.evaldf, file = "completed-evals/bifrub-eval.csv")
write.csv(bifrub.diffdf, file = "completed-evals/bifrub-diff.csv")
#write.csv(bifrub.varimpdf, file = "completed-evals/bifrub-varimport.csv")
```

# Flavifrons
## Chamaenerion
```{r flav cham data, message = F}
gbif.cham <- gbif %>%
  filter(genus == "Chamaenerion")

flavcham <- bbna %>%
  filter(species == "flavifrons",
         plant.host.genus == "Chamaenerion") %>%
  dplyr::select(latitude, longitude, plant.host.genus, date, month, day, year)
```

```{r flavcham maxent for loop, message = F}
flavcham.evaldf <- data.frame()
flavcham.diffdf <- data.frame()
flavcham.varimpdf <- data.frame()

set.seed(15124)
for(i in 1:100){
  # Step 1: separate all data into training and testing datasets
  bg <- as.data.frame(spatSample(x = bioclim, size = 10000, method = "random", na.rm = T, xy = T)) %>%
    dplyr::select(x, y) %>%
    rename(longitude = x,
           latitude = y)
  bgfold <- kfold(bg, k = 5)
  bg.test <- bg[bgfold == 1,]
  bg.train <- bg[bgfold != 1,]
  
  flav.longlat <- bbna %>%
    filter(species == "flavifrons",
           plant.host.genus != "Chamaenerion") %>%
    slice_sample(by = BBNA.code, n = 1) %>%
    dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  flav.fold <- kfold(flav.longlat, k = 5)
  flav.test <- flav.longlat[flav.fold == 1,]
  flav.train <- flav.longlat[flav.fold != 1,]
  
  cham.longlat <- gbif.cham %>%
  dplyr::select(decimalLongitude, decimalLatitude) %>%
  as.data.frame(.) %>%
  rename(longitude = decimalLongitude,
         latitude = decimalLatitude)
  cham.fold <- kfold(cham.longlat, k = 5)
  cham.test <- cham.longlat[cham.fold == 1,]
  cham.train <- cham.longlat[cham.fold != 1,]
  
  flavcham.longlat <- flavcham %>%
  dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  flavcham.fold <- kfold(flavcham.longlat, k = 5)
  flavcham.test <- flavcham.longlat[flavcham.fold == 1,]
  flavcham.train <- flavcham.longlat[flavcham.fold != 1,]
  
  
  
  # Step 2: Calculate overlaps
  ## Step 2a: Individual models
  flav.maxent <- maxent(x = stack(bioclim),
                       p = flav.train, 
                       a = bg.train)
  flav.predict <- dismo::predict(flav.maxent,
                                stack(bioclim))
  
  cham.maxent <- maxent(x = stack(bioclim), 
                       p = cham.train, 
                       a = bg.train)
  cham.predict <- dismo::predict(cham.maxent,
                                stack(bioclim))
  
  ## Step 2b: Multiply bee and plant habitat suitability to get a joint probability
  flavcham.overlap <- as(flav.predict * cham.predict, "SpatRaster")
  
  
  
  # Step 3: Calculate IDM
  flavcham.maxent <- maxent(x = stack(bioclim), 
                          p = flavcham.train, 
                          a = bg.train)
  
  flavcham.idm <- as(dismo::predict(flavcham.maxent, stack(bioclim)), "SpatRaster")
  
  
  
  # Step 4: Subtract predicted rasters to determine whether overlaps over- or under-predict interaction occurrence compared to IDM
  ### positive value = overlap over-predicts
  ### negative value = overlap under-predicts
  overlap_idm = data.frame(run = i, difference = (flavcham.overlap - flavcham.idm)[])

  flavcham.diffdf <- bind_rows(flavcham.diffdf, overlap_idm)
  
  # Step 5: Evaluate overlap model and IDM with the same interaction test data
  ## Step 5a: Use modEvA::AUC to get AUC
  flavcham.overlap.auc <- AUC(obs = flavcham.test, pred = flavcham.overlap)
  flavcham.idm.auc <- AUC(obs = flavcham.test, pred = flavcham.idm)
  
  
  ## Step 5b: Save Evaluation Scores
  flavcham.overlap.eval = data.frame(run = i,
                        model = "overlap",
                        AUC = flavcham.overlap.auc$AUC,
                        TSS = max(flavcham.overlap.auc$thresholds$sensitivity + flavcham.overlap.auc$thresholds$specificity - 1))

  flavcham.idm.eval = data.frame(run = i,
                        model = "IDM",
                        AUC = flavcham.idm.auc$AUC,
                        TSS = max(flavcham.idm.auc$thresholds$sensitivity + flavcham.idm.auc$thresholds$specificity - 1))
  
  flavcham.evaldf = bind_rows(flavcham.evaldf, flavcham.overlap.eval, flavcham.idm.eval)
}

write.csv(flavcham.evaldf, file = "completed-evals/flavcham-eval.csv")
write.csv(flavcham.diffdf, file = "completed-evals/flavcham-diff.csv")
write.csv(flavcham.varimpdf, file = "completed-evals/flavcham-varimport.csv")
```

## Cirsium
```{r flav cir data, message = F}
gbif.cir <- gbif %>%
  filter(genus == "Cirsium")

flavcir <- bbna %>%
  filter(species == "flavifrons",
         plant.host.genus == "Cirsium") %>%
  dplyr::select(latitude, longitude, plant.host.genus, date, month, day, year)
```

```{r flavcir maxent for loop, message = F}
flavcir.evaldf <- data.frame()
flavcir.diffdf <- data.frame()
flavcir.varimpdf <- data.frame()

set.seed(163190)
for(i in 1:100){
  # Step 1: separate all data into training and testing datasets
  bg <- as.data.frame(spatSample(x = bioclim, size = 10000, method = "random", na.rm = T, xy = T)) %>%
    dplyr::select(x, y) %>%
    rename(longitude = x,
           latitude = y)
  bgfold <- kfold(bg, k = 5)
  bg.test <- bg[bgfold == 1,]
  bg.train <- bg[bgfold != 1,]
  
  flav.longlat <- bbna %>%
    filter(species == "flavifrons",
           plant.host.genus != "Cirsium") %>%
    slice_sample(by = BBNA.code, n = 1) %>%
    dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  flav.fold <- kfold(flav.longlat, k = 5)
  flav.test <- flav.longlat[flav.fold == 1,]
  flav.train <- flav.longlat[flav.fold != 1,]
  
  cir.longlat <- gbif.cir %>%
  dplyr::select(decimalLongitude, decimalLatitude) %>%
  as.data.frame(.) %>%
  rename(longitude = decimalLongitude,
         latitude = decimalLatitude)
  cir.fold <- kfold(cir.longlat, k = 5)
  cir.test <- cir.longlat[cir.fold == 1,]
  cir.train <- cir.longlat[cir.fold != 1,]
  
  flavcir.longlat <- flavcir %>%
  dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  flavcir.fold <- kfold(flavcir.longlat, k = 5)
  flavcir.test <- flavcir.longlat[flavcir.fold == 1,]
  flavcir.train <- flavcir.longlat[flavcir.fold != 1,]
  
  
  
  # Step 2: Calculate overlaps
  ## Step 2a: Individual models
  flav.maxent <- maxent(x = stack(bioclim),
                       p = flav.train, 
                       a = bg.train)
  flav.predict <- dismo::predict(flav.maxent,
                                stack(bioclim))
  
  cir.maxent <- maxent(x = stack(bioclim), 
                       p = cir.train, 
                       a = bg.train)
  cir.predict <- dismo::predict(cir.maxent,
                                stack(bioclim))
  
  ## Step 2b: Multiply bee and plant habitat suitability to get a joint probability
  flavcir.overlap <- as(flav.predict * cir.predict, "SpatRaster")
  
  
  
  # Step 3: Calculate IDM
  flavcir.maxent <- maxent(x = stack(bioclim), 
                          p = flavcir.train, 
                          a = bg.train)
  
  flavcir.idm <- as(dismo::predict(flavcir.maxent, stack(bioclim)), "SpatRaster")
  
  
  
  # Step 4: Subtract predicted rasters to determine whether overlaps over- or under-predict interaction occurrence compared to IDM
  ### positive value = overlap over-predicts
  ### negative value = overlap under-predicts
  overlap_idm = data.frame(run = i, difference = (flavcir.overlap - flavcir.idm)[])

  flavcir.diffdf <- bind_rows(flavcir.diffdf, overlap_idm)
  
  # Step 5: Evaluate overlap model and IDM with the same interaction test data
  ## Step 5a: Use modEvA::AUC to get AUC
  flavcir.overlap.auc <- AUC(obs = flavcir.test, pred = flavcir.overlap)
  flavcir.idm.auc <- AUC(obs = flavcir.test, pred = flavcir.idm)
  
  
  ## Step 5b: Save Evaluation Scores
  flavcir.overlap.eval = data.frame(run = i,
                        model = "overlap",
                        AUC = flavcir.overlap.auc$AUC,
                        TSS = max(flavcir.overlap.auc$thresholds$sensitivity + flavcir.overlap.auc$thresholds$specificity - 1))

  flavcir.idm.eval = data.frame(run = i,
                        model = "IDM",
                        AUC = flavcir.idm.auc$AUC,
                        TSS = max(flavcir.idm.auc$thresholds$sensitivity + flavcir.idm.auc$thresholds$specificity - 1))
  
  flavcir.evaldf = bind_rows(flavcir.evaldf, flavcir.overlap.eval, flavcir.idm.eval)
}

write.csv(flavcir.evaldf, file = "completed-evals/flavcir-eval.csv")
write.csv(flavcir.diffdf, file = "completed-evals/flavcir-diff.csv")
# write.csv(flavcir.varimpdf, file = "completed-evals/flavcir-varimport.csv")
```


## Lupinus

```{r flav lup data, message = F}
gbif.lup <- gbif %>%
  filter(genus == "Lupinus")

flavlup <- bbna %>% 
  filter(species == "flavifrons",
         plant.host.genus == "Lupinus") %>%
  dplyr::select(latitude, longitude, plant.host.genus, date, month, day, year)
```

```{r flavlup maxent for loop, message = F}
flavlup.evaldf <- data.frame()

flavlup.diffdf <- data.frame()

flavlup.varimpdf <- data.frame()

set.seed(11624)
for(i in 1:100){
  # Step 1: separate all data into training and testing datasets
  bg <- as.data.frame(spatSample(x = bioclim, size = 10000, method = "random", na.rm = T, xy = T)) %>%
    dplyr::select(x, y) %>%
    rename(longitude = x,
           latitude = y)
  bgfold <- kfold(bg, k = 5)
  bg.test <- bg[bgfold == 1,]
  bg.train <- bg[bgfold != 1,]
  
  flav.longlat <- bbna %>%
    filter(species == "flavifrons",
           plant.host.genus != "Lupinus") %>%
    slice_sample(by = BBNA.code, n = 1) %>%
    dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  flav.fold <- kfold(flav.longlat, k = 5)
  flav.test <- flav.longlat[flav.fold == 1,]
  flav.train <- flav.longlat[flav.fold != 1,]
  
  lup.longlat <- gbif.lup %>%
  dplyr::select(decimalLongitude, decimalLatitude) %>%
  as.data.frame(.) %>%
  rename(longitude = decimalLongitude,
         latitude = decimalLatitude)
  lup.fold <- kfold(lup.longlat, k = 5)
  lup.test <- lup.longlat[lup.fold == 1,]
  lup.train <- lup.longlat[lup.fold != 1,]
  
  flavlup.longlat <- flavlup %>%
  dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  flavlup.fold <- kfold(flavlup.longlat, k = 5)
  flavlup.test <- flavlup.longlat[flavlup.fold == 1,]
  flavlup.train <- flavlup.longlat[flavlup.fold != 1,]

  
  
  # Step 2: Calculate overlaps
  ## Step 2a: Individual models
  flav.maxent <- maxent(x = stack(bioclim),
                       p = flav.train, 
                       a = bg.train)
  flav.predict <- dismo::predict(flav.maxent,
                                stack(bioclim))
  
  lup.maxent <- maxent(x = stack(bioclim), 
                       p = lup.train, 
                       a = bg.train)
  lup.predict <- dismo::predict(lup.maxent,
                                stack(bioclim))
  
  ## Step 2b: Multiply bee and plant habitat suitability to get a joint probability
  flavlup.overlap <- as(flav.predict * lup.predict, "SpatRaster")
  
  
  
  # Step 3: Calculate IDM
  flavlup.maxent <- maxent(x = stack(bioclim), 
                          p = flavlup.train, 
                          a = bg.train)
  
  flavlup.idm <- as(dismo::predict(flavlup.maxent, stack(bioclim)), "SpatRaster")
  
  
  
  # Step 4: Subtract predicted rasters to determine whether overlaps over- or under-predict interaction occurrence compared to IDM
  ### positive value = overlap over-predicts
  ### negative value = overlap under-predicts
  overlap_idm = data.frame(run = i, difference = (flavlup.overlap - flavlup.idm)[])

  flavlup.diffdf <- bind_rows(flavlup.diffdf, overlap_idm)
  
  # Step 5: Evaluate overlap model and IDM with the same interaction test data
  ## Step 5a: Use modEvA::AUC to get AUC
  flavlup.overlap.auc <- AUC(obs = flavlup.test, pred = flavlup.overlap)
  flavlup.idm.auc <- AUC(obs = flavlup.test, pred = flavlup.idm)
  
  
  ## Step 5b: Save Evaluation Scores
  flavlup.overlap.eval = data.frame(run = i,
                        model = "overlap",
                        AUC = flavlup.overlap.auc$AUC,
                        TSS = max(flavlup.overlap.auc$thresholds$sensitivity + flavlup.overlap.auc$thresholds$specificity - 1))

  flavlup.idm.eval = data.frame(run = i,
                        model = "IDM",
                        AUC = flavlup.idm.auc$AUC,
                        TSS = max(flavlup.idm.auc$thresholds$sensitivity + flavlup.idm.auc$thresholds$specificity - 1))
  
  flavlup.evaldf = bind_rows(flavlup.evaldf, flavlup.overlap.eval, flavlup.idm.eval)
}

write.csv(flavlup.evaldf, file = "completed-evals/flavlup-eval.csv")
write.csv(flavlup.diffdf, file = "completed-evals/flavlup-diff.csv")
#write.csv(flavlup.varimpdf, file = "completed-evals/flavlup-varimport.csv")
```

## Penstemon
```{r flav pen data, message = F}
gbif.pen <- gbif %>%
  filter(genus == "Penstemon")

flavpen <- bbna %>% 
  filter(species == "flavifrons",
         plant.host.genus == "Penstemon") %>%
  dplyr::select(latitude, longitude, plant.host.genus, date, month, day, year)
```

```{r flavpen maxent for loop, message = F}
flavpen.evaldf <- data.frame()

flavpen.diffdf <- data.frame()

flavpen.varimpdf <- data.frame()

set.seed(11124)
for(i in 1:100){
  # Step 1: separate all data into training and testing datasets
  bg <- as.data.frame(spatSample(x = bioclim, size = 10000, method = "random", na.rm = T, xy = T)) %>%
    dplyr::select(x, y) %>%
    rename(longitude = x,
           latitude = y)
  bgfold <- kfold(bg, k = 5)
  bg.test <- bg[bgfold == 1,]
  bg.train <- bg[bgfold != 1,]
  
  flav.longlat <- bbna %>%
    filter(species == "flavifrons",
           plant.host.genus != "Penstemon") %>%
    slice_sample(by = BBNA.code, n = 1) %>%
    dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  flav.fold <- kfold(flav.longlat, k = 5)
  flav.test <- flav.longlat[flav.fold == 1,]
  flav.train <- flav.longlat[flav.fold != 1,]
  
  pen.longlat <- gbif.pen %>%
  dplyr::select(decimalLongitude, decimalLatitude) %>%
  as.data.frame(.) %>%
  rename(longitude = decimalLongitude,
         latitude = decimalLatitude)
  pen.fold <- kfold(pen.longlat, k = 5)
  pen.test <- pen.longlat[pen.fold == 1,]
  pen.train <- pen.longlat[pen.fold != 1,]
  
  flavpen.longlat <- flavpen %>%
  dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  flavpen.fold <- kfold(flavpen.longlat, k = 5)
  flavpen.test <- flavpen.longlat[flavpen.fold == 1,]
  flavpen.train <- flavpen.longlat[flavpen.fold != 1,]

  
  
  # Step 2: Calculate overlaps
  ## Step 2a: Individual models
  flav.maxent <- maxent(x = stack(bioclim),
                       p = flav.train, 
                       a = bg.train)
  flav.predict <- dismo::predict(flav.maxent,
                                stack(bioclim))
  
  pen.maxent <- maxent(x = stack(bioclim), 
                       p = pen.train, 
                       a = bg.train)
  pen.predict <- dismo::predict(pen.maxent,
                                stack(bioclim))
  
  ## Step 2b: Multiply bee and plant habitat suitability to get a joint probability
  flavpen.overlap <- as(flav.predict * pen.predict, "SpatRaster")
  
  
  
  # Step 3: Calculate IDM
  flavpen.maxent <- maxent(x = stack(bioclim), 
                          p = flavpen.train, 
                          a = bg.train)
  
  flavpen.idm <- as(dismo::predict(flavpen.maxent, stack(bioclim)), "SpatRaster")
  
  
  
  # Step 4: Subtract predicted rasters to determine whether overlaps over- or under-predict interaction occurrence compared to IDM
  ### positive value = overlap over-predicts
  ### negative value = overlap under-predicts
  overlap_idm = data.frame(run = i, difference = (flavpen.overlap - flavpen.idm)[])

  flavpen.diffdf <- bind_rows(flavpen.diffdf, overlap_idm)
  
  # Step 5: Evaluate overlap model and IDM with the same interaction test data
  ## Step 5a: Use modEvA::AUC to get AUC
  flavpen.overlap.auc <- AUC(obs = flavpen.test, pred = flavpen.overlap)
  flavpen.idm.auc <- AUC(obs = flavpen.test, pred = flavpen.idm)
  
  
  ## Step 5b: Save Evaluation Scores
  flavpen.overlap.eval = data.frame(run = i,
                        model = "overlap",
                        AUC = flavpen.overlap.auc$AUC,
                        TSS = max(flavpen.overlap.auc$thresholds$sensitivity + flavpen.overlap.auc$thresholds$specificity - 1))

  flavpen.idm.eval = data.frame(run = i,
                        model = "IDM",
                        AUC = flavpen.idm.auc$AUC,
                        TSS = max(flavpen.idm.auc$thresholds$sensitivity + flavpen.idm.auc$thresholds$specificity - 1))
  
  flavpen.evaldf = bind_rows(flavpen.evaldf, flavpen.overlap.eval, flavpen.idm.eval)
}

write.csv(flavpen.evaldf, file = "completed-evals/flavpen-eval.csv")
write.csv(flavpen.diffdf, file = "completed-evals/flavpen-diff.csv")
#write.csv(flavpen.varimpdf, file = "completed-evals/flavpen-varimport.csv")
```


## Rubus
```{r flav rub data, message = F}
gbif.rub <- gbif %>%
  filter(genus == "Rubus")

flavrub <- bbna %>%
  filter(species == "flavifrons",
         plant.host.genus == "Rubus") %>%
  dplyr::select(latitude, longitude, plant.host.genus, date, month, day, year)
```

```{r flavrub maxent for loop, message = F}
flavrub.evaldf <- data.frame()

flavrub.diffdf <- data.frame()

flavrub.varimpdf <- data.frame()

set.seed(160124)
for(i in 1:100){
  # Step 1: separate all data into training and testing datasets
  bg <- as.data.frame(spatSample(x = bioclim, size = 10000, method = "random", na.rm = T, xy = T)) %>%
    dplyr::select(x, y) %>%
    rename(longitude = x,
           latitude = y)
  bgfold <- kfold(bg, k = 5)
  bg.test <- bg[bgfold == 1,]
  bg.train <- bg[bgfold != 1,]
  
  flav.longlat <- bbna %>%
    filter(species == "flavifrons",
           plant.host.genus != "Rubus") %>%
    slice_sample(by = BBNA.code, n = 1) %>%
    dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  flav.fold <- kfold(flav.longlat, k = 5)
  flav.test <- flav.longlat[flav.fold == 1,]
  flav.train <- flav.longlat[flav.fold != 1,]
  
  rub.longlat <- gbif.rub %>%
  dplyr::select(decimalLongitude, decimalLatitude) %>%
  as.data.frame(.) %>%
  rename(longitude = decimalLongitude,
         latitude = decimalLatitude)
  rub.fold <- kfold(rub.longlat, k = 5)
  rub.test <- rub.longlat[rub.fold == 1,]
  rub.train <- rub.longlat[rub.fold != 1,]
  
  flavrub.longlat <- flavrub %>%
  dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  flavrub.fold <- kfold(flavrub.longlat, k = 5)
  flavrub.test <- flavrub.longlat[flavrub.fold == 1,]
  flavrub.train <- flavrub.longlat[flavrub.fold != 1,]
  
  
  
  # Step 2: Calculate overlaps
  ## Step 2a: Individual models
  flav.maxent <- maxent(x = stack(bioclim),
                       p = flav.train, 
                       a = bg.train)
  flav.predict <- dismo::predict(flav.maxent,
                                stack(bioclim))
  
  rub.maxent <- maxent(x = stack(bioclim), 
                       p = rub.train, 
                       a = bg.train)
  rub.predict <- dismo::predict(rub.maxent,
                                stack(bioclim))
  
  ## Step 2b: Multiply bee and plant habitat suitability to get a joint probability
  flavrub.overlap <- as(flav.predict * rub.predict, "SpatRaster")
  
  
  
  # Step 3: Calculate IDM
  flavrub.maxent <- maxent(x = stack(bioclim), 
                          p = flavrub.train, 
                          a = bg.train)
  
  flavrub.idm <- as(dismo::predict(flavrub.maxent, stack(bioclim)), "SpatRaster")
  
  
  
  # Step 4: Subtract predicted rasters to determine whether overlaps over- or under-predict interaction occurrence compared to IDM
  ### positive value = overlap over-predicts
  ### negative value = overlap under-predicts
  overlap_idm = data.frame(run = i, difference = (flavrub.overlap - flavrub.idm)[])

  flavrub.diffdf <- bind_rows(flavrub.diffdf, overlap_idm)
  
  # Step 5: Evaluate overlap model and IDM with the same interaction test data
  ## Step 5a: Use modEvA::AUC to get AUC
  flavrub.overlap.auc <- AUC(obs = flavrub.test, pred = flavrub.overlap)
  flavrub.idm.auc <- AUC(obs = flavrub.test, pred = flavrub.idm)
  
  
  ## Step 5b: Save Evaluation Scores
  flavrub.overlap.eval = data.frame(run = i,
                        model = "overlap",
                        AUC = flavrub.overlap.auc$AUC,
                        TSS = max(flavrub.overlap.auc$thresholds$sensitivity + flavrub.overlap.auc$thresholds$specificity - 1))

  flavrub.idm.eval = data.frame(run = i,
                        model = "IDM",
                        AUC = flavrub.idm.auc$AUC,
                        TSS = max(flavrub.idm.auc$thresholds$sensitivity + flavrub.idm.auc$thresholds$specificity - 1))
  
  flavrub.evaldf = bind_rows(flavrub.evaldf, flavrub.overlap.eval, flavrub.idm.eval)
}

write.csv(flavrub.evaldf, file = "completed-evals/flavrub-eval.csv")
write.csv(flavrub.diffdf, file = "completed-evals/flavrub-diff.csv")
#write.csv(flavrub.varimpdf, file = "completed-evals/flavrub-varimport.csv")
```



# Mixtus
## Chamaenerion

```{r mix cham data, message = F}
gbif.cham <- gbif %>%
  filter(genus == "Chamaenerion")

mixcham <- bbna %>%
  filter(species == "mixtus",
         plant.host.genus == "Chamaenerion") %>%
  dplyr::select(latitude, longitude, plant.host.genus, date, month, day, year)
```

```{r mixcham maxent for loop, message = F}
mixcham.evaldf <- data.frame()

mixcham.diffdf <- data.frame()

mixcham.varimpdf <- data.frame()

set.seed(51445)
for(i in 1:100){
  # Step 1: separate all data into training and testing datasets
  bg <- as.data.frame(spatSample(x = bioclim, size = 10000, method = "random", na.rm = T, xy = T)) %>%
    dplyr::select(x, y) %>%
    rename(longitude = x,
           latitude = y)
  bgfold <- kfold(bg, k = 5)
  bg.test <- bg[bgfold == 1,]
  bg.train <- bg[bgfold != 1,]
  
  mix.longlat <- bbna %>%
    filter(species == "mixtus",
           plant.host.genus != "Chamaenerion") %>%
    slice_sample(by = BBNA.code, n = 1) %>%
    dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  mix.fold <- kfold(mix.longlat, k = 5)
  mix.test <- mix.longlat[mix.fold == 1,]
  mix.train <- mix.longlat[mix.fold != 1,]
  
  cham.longlat <- gbif.cham %>%
  dplyr::select(decimalLongitude, decimalLatitude) %>%
  as.data.frame(.) %>%
  rename(longitude = decimalLongitude,
         latitude = decimalLatitude)
  cham.fold <- kfold(cham.longlat, k = 5)
  cham.test <- cham.longlat[cham.fold == 1,]
  cham.train <- cham.longlat[cham.fold != 1,]
  
  mixcham.longlat <- mixcham %>%
  dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  mixcham.fold <- kfold(mixcham.longlat, k = 5)
  mixcham.test <- mixcham.longlat[mixcham.fold == 1,]
  mixcham.train <- mixcham.longlat[mixcham.fold != 1,]
  
  
  
  # Step 2: Calculate overlaps
  ## Step 2a: Individual models
  mix.maxent <- maxent(x = stack(bioclim),
                       p = mix.train, 
                       a = bg.train)
  mix.predict <- dismo::predict(mix.maxent,
                                stack(bioclim))
  
  cham.maxent <- maxent(x = stack(bioclim), 
                       p = cham.train, 
                       a = bg.train)
  cham.predict <- dismo::predict(cham.maxent,
                                stack(bioclim))
  
  ## Step 2b: Multiply bee and plant habitat suitability to get a joint probability
  mixcham.overlap <- as(mix.predict * cham.predict, "SpatRaster")
  
  
  
  # Step 3: Calculate IDM
  mixcham.maxent <- maxent(x = stack(bioclim), 
                          p = mixcham.train, 
                          a = bg.train)
  
  mixcham.idm <- as(dismo::predict(mixcham.maxent, stack(bioclim)), "SpatRaster")
  
  
  
  # Step 4: Subtract predicted rasters to determine whether overlaps over- or under-predict interaction occurrence compared to IDM
  ### positive value = overlap over-predicts
  ### negative value = overlap under-predicts
  overlap_idm = data.frame(run = i, difference = (mixcham.overlap - mixcham.idm)[])

  mixcham.diffdf <- bind_rows(mixcham.diffdf, overlap_idm)
  
  # Step 5: Evaluate overlap model and IDM with the same interaction test data
  ## Step 5a: Use modEvA::AUC to get AUC
  mixcham.overlap.auc <- AUC(obs = mixcham.test, pred = mixcham.overlap)
  mixcham.idm.auc <- AUC(obs = mixcham.test, pred = mixcham.idm)
  
  
  ## Step 5b: Save Evaluation Scores
  mixcham.overlap.eval = data.frame(run = i,
                        model = "overlap",
                        AUC = mixcham.overlap.auc$AUC,
                        TSS = max(mixcham.overlap.auc$thresholds$sensitivity + mixcham.overlap.auc$thresholds$specificity - 1))

  mixcham.idm.eval = data.frame(run = i,
                        model = "IDM",
                        AUC = mixcham.idm.auc$AUC,
                        TSS = max(mixcham.idm.auc$thresholds$sensitivity + mixcham.idm.auc$thresholds$specificity - 1))
  
  mixcham.evaldf = bind_rows(mixcham.evaldf, mixcham.overlap.eval, mixcham.idm.eval)
}

write.csv(mixcham.evaldf, file = "completed-evals/mixcham-eval.csv")
write.csv(mixcham.diffdf, file = "completed-evals/mixcham-diff.csv")
# write.csv(mixcham.varimpdf, file = "completed-evals/mixcham-varimport.csv")
```

## Cirsium

```{r mix cham data, message = F}
gbif.cir <- gbif %>%
  filter(genus == "Cirsium")

mixcir <- bbna %>%
  filter(species == "mixtus",
         plant.host.genus == "Cirsium") %>%
  dplyr::select(latitude, longitude, plant.host.genus, date, month, day, year)
```

```{r mixcir maxent for loop, message = F}
mixcir.evaldf <- data.frame()

mixcir.diffdf <- data.frame()

mixcir.varimpdf <- data.frame()

set.seed(290424)
for(i in 1:100){
  # Step 1: separate all data into training and testing datasets
  bg <- as.data.frame(spatSample(x = bioclim, size = 10000, method = "random", na.rm = T, xy = T)) %>%
    dplyr::select(x, y) %>%
    rename(longitude = x,
           latitude = y)
  bgfold <- kfold(bg, k = 5)
  bg.test <- bg[bgfold == 1,]
  bg.train <- bg[bgfold != 1,]
  
  mix.longlat <- bbna %>%
    filter(species == "mixtus",
           plant.host.genus != "Cirsium") %>%
    slice_sample(by = BBNA.code, n = 1) %>%
    dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  mix.fold <- kfold(mix.longlat, k = 5)
  mix.test <- mix.longlat[mix.fold == 1,]
  mix.train <- mix.longlat[mix.fold != 1,]
  
  cir.longlat <- gbif.cir %>%
  dplyr::select(decimalLongitude, decimalLatitude) %>%
  as.data.frame(.) %>%
  rename(longitude = decimalLongitude,
         latitude = decimalLatitude)
  cir.fold <- kfold(cir.longlat, k = 5)
  cir.test <- cir.longlat[cir.fold == 1,]
  cir.train <- cir.longlat[cir.fold != 1,]
  
  mixcir.longlat <- mixcham %>%
  dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  mixcir.fold <- kfold(mixcir.longlat, k = 5)
  mixcir.test <- mixcir.longlat[mixcir.fold == 1,]
  mixcir.train <- mixcir.longlat[mixcir.fold != 1,]
  
  
  
  # Step 2: Calculate overlaps
  ## Step 2a: Individual models
  mix.maxent <- maxent(x = stack(bioclim),
                       p = mix.train, 
                       a = bg.train)
  mix.predict <- dismo::predict(mix.maxent,
                                stack(bioclim))
  
  cir.maxent <- maxent(x = stack(bioclim), 
                       p = cir.train, 
                       a = bg.train)
  cir.predict <- dismo::predict(cir.maxent,
                                stack(bioclim))
  
  ## Step 2b: Multiply bee and plant habitat suitability to get a joint probability
  mixcir.overlap <- as(mix.predict * cir.predict, "SpatRaster")
  
  
  
  # Step 3: Calculate IDM
  mixcir.maxent <- maxent(x = stack(bioclim), 
                          p = mixcir.train, 
                          a = bg.train)
  
  mixcir.idm <- as(dismo::predict(mixcir.maxent, stack(bioclim)), "SpatRaster")
  
  
  
  # Step 4: Subtract predicted rasters to determine whether overlaps over- or under-predict interaction occurrence compared to IDM
  ### positive value = overlap over-predicts
  ### negative value = overlap under-predicts
  overlap_idm = data.frame(run = i, difference = (mixcir.overlap - mixcir.idm)[])

  mixcir.diffdf <- bind_rows(mixcir.diffdf, overlap_idm)
  
  # Step 5: Evaluate overlap model and IDM with the same interaction test data
  ## Step 5a: Use modEvA::AUC to get AUC
  mixcir.overlap.auc <- AUC(obs = mixcir.test, pred = mixcir.overlap)
  mixcir.idm.auc <- AUC(obs = mixcir.test, pred = mixcir.idm)
  
  
  ## Step 5b: Save Evaluation Scores
  mixcir.overlap.eval = data.frame(run = i,
                        model = "overlap",
                        AUC = mixcir.overlap.auc$AUC,
                        TSS = max(mixcir.overlap.auc$thresholds$sensitivity + mixcir.overlap.auc$thresholds$specificity - 1))

  mixcir.idm.eval = data.frame(run = i,
                        model = "IDM",
                        AUC = mixcir.idm.auc$AUC,
                        TSS = max(mixcir.idm.auc$thresholds$sensitivity + mixcir.idm.auc$thresholds$specificity - 1))
  
  mixcir.evaldf = bind_rows(mixcir.evaldf, mixcir.overlap.eval, mixcir.idm.eval)
}

write.csv(mixcir.evaldf, file = "completed-evals/mixcir-eval.csv")
write.csv(mixcir.diffdf, file = "completed-evals/mixcir-diff.csv")
# write.csv(mixcir.varimpdf, file = "completed-evals/mixcir-varimport.csv")
```


## Lupinus

```{r mix lup data, message = F}
gbif.lup <- gbif %>%
  filter(genus == "Lupinus")

mixlup <- bbna %>%
  filter(species == "mixtus",
         plant.host.genus == "Lupinus") %>%
  dplyr::select(latitude, longitude, plant.host.genus, date, month, day, year)
```

```{r mixlup maxent for loop, message = F}
mixlup.evaldf <- data.frame()

mixlup.diffdf <- data.frame()

mixlup.varimpdf <- data.frame()

set.seed(232024)
for(i in 1:100){
  # Step 1: separate all data into training and testing datasets
  bg <- as.data.frame(spatSample(x = bioclim, size = 10000, method = "random", na.rm = T, xy = T)) %>%
    dplyr::select(x, y) %>%
    rename(longitude = x,
           latitude = y)
  bgfold <- kfold(bg, k = 5)
  bg.test <- bg[bgfold == 1,]
  bg.train <- bg[bgfold != 1,]
  
  mix.longlat <- bbna %>%
    filter(species == "mixtus",
           plant.host.genus != "Lupinus") %>%
    slice_sample(by = BBNA.code, n = 1) %>%
    dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  mix.fold <- kfold(mix.longlat, k = 5)
  mix.test <- mix.longlat[mix.fold == 1,]
  mix.train <- mix.longlat[mix.fold != 1,]
  
  lup.longlat <- gbif.lup %>%
  dplyr::select(decimalLongitude, decimalLatitude) %>%
  as.data.frame(.) %>%
  rename(longitude = decimalLongitude,
         latitude = decimalLatitude)
  lup.fold <- kfold(lup.longlat, k = 5)
  lup.test <- lup.longlat[lup.fold == 1,]
  lup.train <- lup.longlat[lup.fold != 1,]
  
  mixlup.longlat <- mixlup %>%
  dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  mixlup.fold <- kfold(mixlup.longlat, k = 5)
  mixlup.test <- mixlup.longlat[mixlup.fold == 1,]
  mixlup.train <- mixlup.longlat[mixlup.fold != 1,]
  
  
  
  # Step 2: Calculate overlaps
  ## Step 2a: Individual models
  mix.maxent <- maxent(x = stack(bioclim),
                       p = mix.train, 
                       a = bg.train)
  mix.predict <- dismo::predict(mix.maxent,
                                stack(bioclim))
  
  lup.maxent <- maxent(x = stack(bioclim), 
                       p = lup.train, 
                       a = bg.train)
  lup.predict <- dismo::predict(lup.maxent,
                                stack(bioclim))
  
  ## Step 2b: Multiply bee and plant habitat suitability to get a joint probability
  mixlup.overlap <- as(mix.predict * lup.predict, "SpatRaster")
  
  
  
  # Step 3: Calculate IDM
  mixlup.maxent <- maxent(x = stack(bioclim), 
                          p = mixlup.train, 
                          a = bg.train)
  
  mixlup.idm <- as(dismo::predict(mixlup.maxent, stack(bioclim)), "SpatRaster")
  
  
  
  # Step 4: Subtract predicted rasters to determine whether overlaps over- or under-predict interaction occurrence compared to IDM
  ### positive value = overlap over-predicts
  ### negative value = overlap under-predicts
  overlap_idm = data.frame(run = i, difference = (mixlup.overlap - mixlup.idm)[])

  mixlup.diffdf <- bind_rows(mixlup.diffdf, overlap_idm)
  
  # Step 5: Evaluate overlap model and IDM with the same interaction test data
  ## Step 5a: Use modEvA::AUC to get AUC
  mixlup.overlap.auc <- AUC(obs = mixlup.test, pred = mixlup.overlap)
  mixlup.idm.auc <- AUC(obs = mixlup.test, pred = mixlup.idm)
  
  
  ## Step 5b: Save Evaluation Scores
  mixlup.overlap.eval = data.frame(run = i,
                        model = "overlap",
                        AUC = mixlup.overlap.auc$AUC,
                        TSS = max(mixlup.overlap.auc$thresholds$sensitivity + mixlup.overlap.auc$thresholds$specificity - 1))

  mixlup.idm.eval = data.frame(run = i,
                        model = "IDM",
                        AUC = mixlup.idm.auc$AUC,
                        TSS = max(mixlup.idm.auc$thresholds$sensitivity + mixlup.idm.auc$thresholds$specificity - 1))
  
  mixlup.evaldf = bind_rows(mixlup.evaldf, mixlup.overlap.eval, mixlup.idm.eval)
}

write.csv(mixlup.evaldf, file = "completed-evals/mixlup-eval.csv")
write.csv(mixlup.diffdf, file = "completed-evals/mixlup-diff.csv")
# write.csv(mixlup.varimpdf, file = "completed-evals/mixlup-varimport.csv")
```

## Penstemon

```{r mix pen data, message = F}
gbif.pen <- gbif %>%
  filter(genus == "Penstemon")

mixpen <- bbna %>%
  filter(species == "mixtus",
         plant.host.genus == "Penstemon") %>%
  dplyr::select(latitude, longitude, plant.host.genus, date, month, day, year)
```

```{r mixpen maxent for loop, message = F}
mixpen.evaldf <- data.frame()

mixpen.diffdf <- data.frame()

mixpen.varimpdf <- data.frame()

set.seed(208483)
for(i in 1:100){
  # Step 1: separate all data into training and testing datasets
  bg <- as.data.frame(spatSample(x = bioclim, size = 10000, method = "random", na.rm = T, xy = T)) %>%
    dplyr::select(x, y) %>%
    rename(longitude = x,
           latitude = y)
  bgfold <- kfold(bg, k = 5)
  bg.test <- bg[bgfold == 1,]
  bg.train <- bg[bgfold != 1,]
  
  mix.longlat <- bbna %>%
    filter(species == "mixtus",
           plant.host.genus != "Penstemon") %>%
    slice_sample(by = BBNA.code, n = 1) %>%
    dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  mix.fold <- kfold(mix.longlat, k = 5)
  mix.test <- mix.longlat[mix.fold == 1,]
  mix.train <- mix.longlat[mix.fold != 1,]
  
  pen.longlat <- gbif.pen %>%
  dplyr::select(decimalLongitude, decimalLatitude) %>%
  as.data.frame(.) %>%
  rename(longitude = decimalLongitude,
         latitude = decimalLatitude)
  pen.fold <- kfold(pen.longlat, k = 5)
  pen.test <- pen.longlat[pen.fold == 1,]
  pen.train <- pen.longlat[pen.fold != 1,]
  
  mixpen.longlat <- mixpen %>%
  dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  mixpen.fold <- kfold(mixpen.longlat, k = 5)
  mixpen.test <- mixpen.longlat[mixpen.fold == 1,]
  mixpen.train <- mixpen.longlat[mixpen.fold != 1,]
  
  
  
  # Step 2: Calculate overlaps
  ## Step 2a: Individual models
  mix.maxent <- maxent(x = stack(bioclim),
                       p = mix.train, 
                       a = bg.train)
  mix.predict <- dismo::predict(mix.maxent,
                                stack(bioclim))
  
  pen.maxent <- maxent(x = stack(bioclim), 
                       p = pen.train, 
                       a = bg.train)
  pen.predict <- dismo::predict(pen.maxent,
                                stack(bioclim))
  
  ## Step 2b: Multiply bee and plant habitat suitability to get a joint probability
  mixpen.overlap <- as(mix.predict * pen.predict, "SpatRaster")
  
  
  
  # Step 3: Calculate IDM
  mixpen.maxent <- maxent(x = stack(bioclim), 
                          p = mixpen.train, 
                          a = bg.train)
  
  mixpen.idm <- as(dismo::predict(mixpen.maxent, stack(bioclim)), "SpatRaster")
  
  
  
  # Step 4: Subtract predicted rasters to determine whether overlaps over- or under-predict interaction occurrence compared to IDM
  ### positive value = overlap over-predicts
  ### negative value = overlap under-predicts
  overlap_idm = data.frame(run = i, difference = (mixpen.overlap - mixpen.idm)[])

  mixpen.diffdf <- bind_rows(mixpen.diffdf, overlap_idm)
  
  # Step 5: Evaluate overlap model and IDM with the same interaction test data
  ## Step 5a: Use modEvA::AUC to get AUC
  mixpen.overlap.auc <- AUC(obs = mixpen.test, pred = mixpen.overlap)
  mixpen.idm.auc <- AUC(obs = mixpen.test, pred = mixpen.idm)
  
  
  ## Step 5b: Save Evaluation Scores
  mixpen.overlap.eval = data.frame(run = i,
                        model = "overlap",
                        AUC = mixpen.overlap.auc$AUC,
                        TSS = max(mixpen.overlap.auc$thresholds$sensitivity + mixpen.overlap.auc$thresholds$specificity - 1))

  mixpen.idm.eval = data.frame(run = i,
                        model = "IDM",
                        AUC = mixpen.idm.auc$AUC,
                        TSS = max(mixpen.idm.auc$thresholds$sensitivity + mixpen.idm.auc$thresholds$specificity - 1))
  
  mixpen.evaldf = bind_rows(mixpen.evaldf, mixpen.overlap.eval, mixpen.idm.eval)
}

write.csv(mixpen.evaldf, file = "completed-evals/mixpen-eval.csv")
write.csv(mixpen.diffdf, file = "completed-evals/mixpen-diff.csv")
# write.csv(mixpen.varimpdf, file = "completed-evals/mixpen-varimport.csv")
```


## Rubus

```{r mix rub data, message = F}
gbif.rub <- gbif %>%
  filter(genus == "Rubus")

mixrub <- bbna %>%
  filter(species == "mixtus",
         plant.host.genus == "Rubus") %>%
  dplyr::select(latitude, longitude, plant.host.genus, date, month, day, year)
```

```{r mixrub maxent for loop, message = F}
mixrub.evaldf <- data.frame()

mixrub.diffdf <- data.frame()

mixrub.varimpdf <- data.frame()

set.seed(121023)
for(i in 1:100){
  # Step 1: separate all data into training and testing datasets
  bg <- as.data.frame(spatSample(x = bioclim, size = 10000, method = "random", na.rm = T, xy = T)) %>%
    dplyr::select(x, y) %>%
    rename(longitude = x,
           latitude = y)
  bgfold <- kfold(bg, k = 5)
  bg.test <- bg[bgfold == 1,]
  bg.train <- bg[bgfold != 1,]
  
  mix.longlat <- bbna %>%
    filter(species == "mixtus",
           plant.host.genus != "Rubus") %>%
    slice_sample(by = BBNA.code, n = 1) %>%
    dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  mix.fold <- kfold(mix.longlat, k = 5)
  mix.test <- mix.longlat[mix.fold == 1,]
  mix.train <- mix.longlat[mix.fold != 1,]
  
  rub.longlat <- gbif.rub %>%
  dplyr::select(decimalLongitude, decimalLatitude) %>%
  as.data.frame(.) %>%
  rename(longitude = decimalLongitude,
         latitude = decimalLatitude)
  rub.fold <- kfold(rub.longlat, k = 5)
  rub.test <- rub.longlat[rub.fold == 1,]
  rub.train <- rub.longlat[rub.fold != 1,]
  
  mixrub.longlat <- mixrub %>%
  dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  mixrub.fold <- kfold(mixrub.longlat, k = 5)
  mixrub.test <- mixrub.longlat[mixrub.fold == 1,]
  mixrub.train <- mixrub.longlat[mixrub.fold != 1,]
  
  
  
  # Step 2: Calculate overlaps
  ## Step 2a: Individual models
  mix.maxent <- maxent(x = stack(bioclim),
                       p = mix.train, 
                       a = bg.train)
  mix.predict <- dismo::predict(mix.maxent,
                                stack(bioclim))
  
  rub.maxent <- maxent(x = stack(bioclim), 
                       p = rub.train, 
                       a = bg.train)
  rub.predict <- dismo::predict(rub.maxent,
                                stack(bioclim))
  
  ## Step 2b: Multiply bee and plant habitat suitability to get a joint probability
  mixrub.overlap <- as(mix.predict * rub.predict, "SpatRaster")
  
  
  
  # Step 3: Calculate IDM
  mixrub.maxent <- maxent(x = stack(bioclim), 
                          p = mixrub.train, 
                          a = bg.train)
  
  mixrub.idm <- as(dismo::predict(mixrub.maxent, stack(bioclim)), "SpatRaster")
  
  
  
  # Step 4: Subtract predicted rasters to determine whether overlaps over- or under-predict interaction occurrence compared to IDM
  ### positive value = overlap over-predicts
  ### negative value = overlap under-predicts
  overlap_idm = data.frame(run = i, difference = (mixrub.overlap - mixrub.idm)[])

  mixrub.diffdf <- bind_rows(mixrub.diffdf, overlap_idm)
  
  # Step 5: Evaluate overlap model and IDM with the same interaction test data
  ## Step 5a: Use modEvA::AUC to get AUC
  mixrub.overlap.auc <- AUC(obs = mixrub.test, pred = mixrub.overlap)
  mixrub.idm.auc <- AUC(obs = mixrub.test, pred = mixrub.idm)
  
  
  ## Step 5b: Save Evaluation Scores
  mixrub.overlap.eval = data.frame(run = i,
                        model = "overlap",
                        AUC = mixrub.overlap.auc$AUC,
                        TSS = max(mixrub.overlap.auc$thresholds$sensitivity + mixrub.overlap.auc$thresholds$specificity - 1))

  mixrub.idm.eval = data.frame(run = i,
                        model = "IDM",
                        AUC = mixrub.idm.auc$AUC,
                        TSS = max(mixrub.idm.auc$thresholds$sensitivity + mixrub.idm.auc$thresholds$specificity - 1))
  
  mixrub.evaldf = bind_rows(mixrub.evaldf, mixrub.overlap.eval, mixrub.idm.eval)
}

write.csv(mixrub.evaldf, file = "completed-evals/mixrub-eval.csv")
write.csv(mixrub.diffdf, file = "completed-evals/mixrub-diff.csv")
#write.csv(mixrub.varimpdf, file = "completed-evals/mixrub-varimport.csv")
```

<!-- ### Rubus spectabilis -->

<!-- ```{r mixtus rubus spectabilis} -->
<!-- gbif.rubspec <- gbif %>% -->
<!--   filter(species == "Rubus spectabilis") -->

<!-- mixrubspec.evaldf <- data.frame() -->

<!-- mixrubspec.varimpdf <- data.frame() -->

<!-- set.seed(240419) -->
<!-- for(i in 1:100){ -->
<!--   # Step 1: separate all data into training and testing datasets -->
<!--   bg <- as.data.frame(spatSample(x = bioclim, size = 10000, method = "random", na.rm = T, xy = T)) %>% -->
<!--     dplyr::select(x, y) %>% -->
<!--     rename(longitude = x, -->
<!--            latitude = y) -->
<!--   bgfold <- kfold(bg, k = 5) -->
<!--   bg.test <- bg[bgfold == 1,] -->
<!--   bg.train <- bg[bgfold != 1,] -->

<!--   mix.longlat <- bbna %>% -->
<!--     filter(species == "mixtus", -->
<!--            plant.host.genus != "Rubus") %>% -->
<!--     slice_sample(by = BBNA.code, n = 1) %>% -->
<!--     dplyr::select(longitude, latitude) %>% -->
<!--   as.data.frame(.) -->
<!--   mix.fold <- kfold(mix.longlat, k = 5) -->
<!--   mix.test <- mix.longlat[mix.fold == 1,] -->
<!--   mix.train <- mix.longlat[mix.fold != 1,] -->

<!--   rubspec.longlat <- gbif.rubspec %>% -->
<!--   dplyr::select(decimalLongitude, decimalLatitude) %>% -->
<!--   as.data.frame(.) %>% -->
<!--   rename(longitude = decimalLongitude, -->
<!--          latitude = decimalLatitude) -->
<!--   rubspec.fold <- kfold(rubspec.longlat, k = 5) -->
<!--   rubspec.test <- rubspec.longlat[rubspec.fold == 1,] -->
<!--   rubspec.train <- rubspec.longlat[rubspec.fold != 1,] -->



<!--   # Step 2: Calculate overlaps -->
<!--   ## Step 2a: Initial models based on just bioclim variables -->
<!--   mix.maxent <- maxent(x = stack(bioclim), -->
<!--                        p = mix.train,  -->
<!--                        a = bg.train) -->
<!--   mix.predict <- dismo::predict(mix.maxent, -->
<!--                                 stack(bioclim)) -->

<!--   rubspec.maxent <- maxent(x = stack(bioclim),  -->
<!--                        p = rubspec.train,  -->
<!--                        a = bg.train) -->
<!--   rubspec.predict <- dismo::predict(rubspec.maxent, -->
<!--                                 stack(bioclim)) -->

<!--   ## Step 2b: Updated models including partner -->
<!--   mix.by.rubspec <- maxent(x = stack(stack(bioclim), rubspec.predict), -->
<!--                        p = mix.train, -->
<!--                        a = bg.train) -->
<!--   rubspec.by.mix <- maxent(x = stack(stack(bioclim), mix.predict), -->
<!--                        p = rubspec.train, -->
<!--                        a = bg.train) -->





<!--   # Step 4: Evaluate all both overlap models and IDM with the same interaction test data -->
<!--   ## Step 4a: Use dismo::evaluate to get AUC and TSS scores -->
<!--   mixbyrubspec.eval <- dismo::evaluate(p = mixrub.test, -->
<!--                                    a = bg.test, -->
<!--                                    model = mix.by.rubspec, -->
<!--                                    x = stack(stack(bioclim), rubspec.predict)) -->
<!--   rubspecbymix.eval <- dismo::evaluate(p = mixrub.test, -->
<!--                                    a = bg.test, -->
<!--                                    model = rubspec.by.mix, -->
<!--                                    x = stack(stack(bioclim), mix.predict)) -->






<!--   # Step 5: Save Evaluation Scores -->
<!--   mbrubspec.eval = data.frame(run = i, -->
<!--                         model = "mbrubspec", -->
<!--                         AUC = mixbyrubspec.eval@auc, -->
<!--                         cor = mixbyrubspec.eval@cor, -->
<!--                         TSS = max(mixbyrubspec.eval@TPR - mixbyrubspec.eval@FPR), -->
<!--                         tstar = which.max(mixbyrubspec.eval@TPR - mixbyrubspec.eval@FPR)) -->

<!--   rubspecbm.eval = data.frame(run = i, -->
<!--                         model = "rubspecbm", -->
<!--                         AUC = rubspecbymix.eval@auc, -->
<!--                         cor = rubspecbymix.eval@cor, -->
<!--                         TSS = max(rubspecbymix.eval@TPR - rubspecbymix.eval@FPR), -->
<!--                         tstar = which.max(rubspecbymix.eval@TPR - rubspecbymix.eval@FPR)) -->



<!--   mixrubspec.evaldf = bind_rows(mixrubspec.evaldf, mbrubspec.eval, rubspecbm.eval) -->




<!--   # Step 6: Save Variable Importance -->
<!--   mbrubspec.vars = data.frame(run = rep(i, 21), -->
<!--                         model = rep("mbrubspec", 21), -->
<!--                         variable = names(mix.by.rubspec@results[7:27,]), -->
<!--                         percent = mix.by.rubspec@results[7:27], -->
<!--                         permutation = mix.by.rubspec@results[28:48]) -->

<!--   rubspecbm.vars = data.frame(run = rep(i, 21), -->
<!--                         model = rep("rubspecbm", 21), -->
<!--                         variable = names(rubspec.by.mix@results[7:27,]), -->
<!--                         percent = rubspec.by.mix@results[7:27], -->
<!--                         permutation = rubspec.by.mix@results[28:48]) -->



<!--   mixrubspec.varimpdf = bind_rows(mixrubspec.varimpdf, mbrubspec.vars, rubspecbm.vars) -->
<!-- } -->
<!-- ``` -->


<!-- ### Rubus parviflorus -->

<!-- ```{r mixtus rubus parviflorus} -->
<!-- gbif.rubparv <- gbif %>% -->
<!--   filter(species == "Rubus parviflorus") -->

<!-- mixrubparv.evaldf <- data.frame() -->

<!-- mixrubparv.varimpdf <- data.frame() -->

<!-- set.seed(2024419) -->
<!-- for(i in 1:100){ -->
<!--   # Step 1: separate all data into training and testing datasets -->
<!--   bg <- as.data.frame(spatSample(x = bioclim, size = 10000, method = "random", na.rm = T, xy = T)) %>% -->
<!--     dplyr::select(x, y) %>% -->
<!--     rename(longitude = x, -->
<!--            latitude = y) -->
<!--   bgfold <- kfold(bg, k = 5) -->
<!--   bg.test <- bg[bgfold == 1,] -->
<!--   bg.train <- bg[bgfold != 1,] -->

<!--   mix.longlat <- bbna %>% -->
<!--     filter(species == "mixtus", -->
<!--            plant.host.genus != "Rubus") %>% -->
<!--     slice_sample(by = BBNA.code, n = 1) %>% -->
<!--     dplyr::select(longitude, latitude) %>% -->
<!--   as.data.frame(.) -->
<!--   mix.fold <- kfold(mix.longlat, k = 5) -->
<!--   mix.test <- mix.longlat[mix.fold == 1,] -->
<!--   mix.train <- mix.longlat[mix.fold != 1,] -->

<!--   rubparv.longlat <- gbif.rubparv %>% -->
<!--   dplyr::select(decimalLongitude, decimalLatitude) %>% -->
<!--   as.data.frame(.) %>% -->
<!--   rename(longitude = decimalLongitude, -->
<!--          latitude = decimalLatitude) -->
<!--   rubparv.fold <- kfold(rubparv.longlat, k = 5) -->
<!--   rubparv.test <- rubparv.longlat[rubparv.fold == 1,] -->
<!--   rubparv.train <- rubparv.longlat[rubparv.fold != 1,] -->

<!--   mixrubparv.longlat <- mixrub %>% -->
<!--   dplyr::select(longitude, latitude) %>% -->
<!--   as.data.frame(.) -->
<!--   mixrubparv.fold <- kfold(mixrubparv.longlat, k = 5) -->
<!--   mixrubparv.test <- mixrubparv.longlat[mixrubparv.fold == 1,] -->
<!--   mixrubparv.train <- mixrubparv.longlat[mixrubparv.fold != 1,] -->



<!--   # Step 2: Calculate overlaps -->
<!--   ## Step 2a: Initial models based on just bioclim variables -->
<!--   mix.maxent <- maxent(x = stack(bioclim), -->
<!--                        p = mix.train,  -->
<!--                        a = bg.train) -->
<!--   mix.predict <- dismo::predict(mix.maxent, -->
<!--                                 stack(bioclim)) -->

<!--   rubparv.maxent <- maxent(x = stack(bioclim),  -->
<!--                        p = rubparv.train,  -->
<!--                        a = bg.train) -->
<!--   rubparv.predict <- dismo::predict(rubparv.maxent, -->
<!--                                 stack(bioclim)) -->

<!--   ## Step 2b: Updated models including partner -->
<!--   mix.by.rubparv <- maxent(x = stack(stack(bioclim), rubparv.predict), -->
<!--                        p = mix.train, -->
<!--                        a = bg.train) -->
<!--   rubparv.by.mix <- maxent(x = stack(stack(bioclim), mix.predict), -->
<!--                        p = rubparv.train, -->
<!--                        a = bg.train) -->





<!--   # Step 4: Evaluate all both overlap models and IDM with the same interaction test data -->
<!--   ## Step 4a: Use dismo::evaluate to get AUC and TSS scores -->
<!--   mixbyrubparv.eval <- dismo::evaluate(p = mixrub.test, -->
<!--                                    a = bg.test, -->
<!--                                    model = mix.by.rubparv, -->
<!--                                    x = stack(stack(bioclim), rubparv.predict)) -->
<!--   rubparvbymix.eval <- dismo::evaluate(p = mixrub.test, -->
<!--                                    a = bg.test, -->
<!--                                    model = rubparv.by.mix, -->
<!--                                    x = stack(stack(bioclim), mix.predict)) -->






<!--   # Step 5: Save Evaluation Scores -->
<!--   mbrubparv.eval = data.frame(run = i, -->
<!--                         model = "mbrubparv", -->
<!--                         AUC = mixbyrubparv.eval@auc, -->
<!--                         cor = mixbyrubparv.eval@cor, -->
<!--                         TSS = max(mixbyrubparv.eval@TPR - mixbyrubparv.eval@FPR), -->
<!--                         tstar = which.max(mixbyrubparv.eval@TPR - mixbyrubparv.eval@FPR)) -->

<!--   rubparvbm.eval = data.frame(run = i, -->
<!--                         model = "rubparvbm", -->
<!--                         AUC = rubparvbymix.eval@auc, -->
<!--                         cor = rubparvbymix.eval@cor, -->
<!--                         TSS = max(rubparvbymix.eval@TPR - rubparvbymix.eval@FPR), -->
<!--                         tstar = which.max(rubparvbymix.eval@TPR - rubparvbymix.eval@FPR)) -->



<!--   mixrubparv.evaldf = bind_rows(mixrubparv.evaldf, mbrubparv.eval, rubparvbm.eval) -->




<!--   # Step 6: Save Variable Importance -->
<!--   mbrubparv.vars = data.frame(run = rep(i, 21), -->
<!--                         model = rep("mbrubparv", 21), -->
<!--                         variable = names(mix.by.rubparv@results[7:27,]), -->
<!--                         percent = mix.by.rubparv@results[7:27], -->
<!--                         permutation = mix.by.rubparv@results[28:48]) -->

<!--   rubparvbm.vars = data.frame(run = rep(i, 21), -->
<!--                         model = rep("rubparvbm", 21), -->
<!--                         variable = names(rubparv.by.mix@results[7:27,]), -->
<!--                         percent = rubparv.by.mix@results[7:27], -->
<!--                         permutation = rubparv.by.mix@results[28:48]) -->



<!--   mixrubparv.varimpdf = bind_rows(mixrubparv.varimpdf, mbrubparv.vars, rubparvbm.vars) -->
<!-- } -->
<!-- ``` -->


# Vosnesenskii
## Chamaenerion

```{r vos cham data, message = F}
gbif.cham <- gbif %>%
  filter(genus == "Chamaenerion")

voscham <- bbna %>% 
  filter(species == "vosnesenskii",
         plant.host.genus == "Chamaenerion") %>%
  dplyr::select(latitude, longitude, plant.host.genus, date, month, day, year)
```

```{r voscham maxent for loop, message = F}
voscham.evaldf <- data.frame()

voscham.diffdf <- data.frame()

voscham.varimpdf <- data.frame()

set.seed(1301143)
for(i in 1:100){
  # Step 1: separate all data into training and testing datasets
  bg <- as.data.frame(spatSample(x = bioclim, size = 10000, method = "random", na.rm = T, xy = T)) %>%
    dplyr::select(x, y) %>%
    rename(longitude = x,
           latitude = y)
  bgfold <- kfold(bg, k = 5)
  bg.test <- bg[bgfold == 1,]
  bg.train <- bg[bgfold != 1,]
  
  vos.longlat <- bbna %>%
    filter(species == "vosnesenskii",
           plant.host.genus != "Chamaenerion") %>%
    slice_sample(by = BBNA.code, n = 1) %>%
    dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  vos.fold <- kfold(vos.longlat, k = 5)
  vos.test <- vos.longlat[vos.fold == 1,]
  vos.train <- vos.longlat[vos.fold != 1,]
  
  cham.longlat <- gbif.cham %>%
  dplyr::select(decimalLongitude, decimalLatitude) %>%
  as.data.frame(.) %>%
  rename(longitude = decimalLongitude,
         latitude = decimalLatitude)
  cham.fold <- kfold(cham.longlat, k = 5)
  cham.test <- cham.longlat[cham.fold == 1,]
  cham.train <- cham.longlat[cham.fold != 1,]
  
  voscham.longlat <- voscham %>%
  dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  voscham.fold <- kfold(voscham.longlat, k = 5)
  voscham.test <- voscham.longlat[voscham.fold == 1,]
  voscham.train <- voscham.longlat[voscham.fold != 1,]

  
  
  # Step 2: Calculate overlaps
  ## Step 2a: Individual models
  vos.maxent <- maxent(x = stack(bioclim),
                       p = vos.train, 
                       a = bg.train)
  vos.predict <- dismo::predict(vos.maxent,
                                stack(bioclim))
  
  cham.maxent <- maxent(x = stack(bioclim), 
                       p = cham.train, 
                       a = bg.train)
  cham.predict <- dismo::predict(cham.maxent,
                                stack(bioclim))
  
  ## Step 2b: Multiply bee and plant habitat suitability to get a joint probability
  voscham.overlap <- as(vos.predict * cham.predict, "SpatRaster")
  
  
  
  # Step 3: Calculate IDM
  voscham.maxent <- maxent(x = stack(bioclim), 
                          p = voscham.train, 
                          a = bg.train)
  
  voscham.idm <- as(dismo::predict(voscham.maxent, stack(bioclim)), "SpatRaster")
  
  
  
  # Step 4: Subtract predicted rasters to determine whether overlaps over- or under-predict interaction occurrence compared to IDM
  ### positive value = overlap over-predicts
  ### negative value = overlap under-predicts
  overlap_idm = data.frame(run = i, difference = (voscham.overlap - voscham.idm)[])

  voscham.diffdf <- bind_rows(voscham.diffdf, overlap_idm)
  
  # Step 5: Evaluate overlap model and IDM with the same interaction test data
  ## Step 5a: Use modEvA::AUC to get AUC
  voscham.overlap.auc <- AUC(obs = voscham.test, pred = voscham.overlap)
  voscham.idm.auc <- AUC(obs = voscham.test, pred = voscham.idm)
  
  
  ## Step 5b: Save Evaluation Scores
  voscham.overlap.eval = data.frame(run = i,
                        model = "overlap",
                        AUC = voscham.overlap.auc$AUC,
                        TSS = max(voscham.overlap.auc$thresholds$sensitivity + voscham.overlap.auc$thresholds$specificity - 1))

  voscham.idm.eval = data.frame(run = i,
                        model = "IDM",
                        AUC = voscham.idm.auc$AUC,
                        TSS = max(voscham.idm.auc$thresholds$sensitivity + voscham.idm.auc$thresholds$specificity - 1))
  
  voscham.evaldf = bind_rows(voscham.evaldf, voscham.overlap.eval, voscham.idm.eval)
}

write.csv(voscham.evaldf, file = "completed-evals/voscham-eval.csv")
write.csv(voscham.diffdf, file = "completed-evals/voscham-diff.csv")
#write.csv(voscham.varimpdf, file = "completed-evals/voscham-varimport.csv")
```



## Cirsium

```{r vos cir data, message = F}
gbif.cir <- gbif %>%
  filter(genus == "Cirsium")

voscir <- bbna %>% 
  filter(species == "vosnesenskii",
         plant.host.genus == "Cirsium") %>%
  dplyr::select(latitude, longitude, plant.host.genus, date, month, day, year)
```

```{r voscir maxent for loop, message = F}
voscir.evaldf <- data.frame()

voscir.diffdf <- data.frame()

voscir.varimpdf <- data.frame()

set.seed(261402)
for(i in 1:100){
  # Step 1: separate all data into training and testing datasets
  bg <- as.data.frame(spatSample(x = bioclim, size = 10000, method = "random", na.rm = T, xy = T)) %>%
    dplyr::select(x, y) %>%
    rename(longitude = x,
           latitude = y)
  bgfold <- kfold(bg, k = 5)
  bg.test <- bg[bgfold == 1,]
  bg.train <- bg[bgfold != 1,]
  
  vos.longlat <- bbna %>%
    filter(species == "vosnesenskii",
           plant.host.genus != "Cirsium") %>%
    slice_sample(by = BBNA.code, n = 1) %>%
    dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  vos.fold <- kfold(vos.longlat, k = 5)
  vos.test <- vos.longlat[vos.fold == 1,]
  vos.train <- vos.longlat[vos.fold != 1,]
  
  cir.longlat <- gbif.cir %>%
  dplyr::select(decimalLongitude, decimalLatitude) %>%
  as.data.frame(.) %>%
  rename(longitude = decimalLongitude,
         latitude = decimalLatitude)
  cir.fold <- kfold(cir.longlat, k = 5)
  cir.test <- cir.longlat[cir.fold == 1,]
  cir.train <- cir.longlat[cir.fold != 1,]
  
  voscir.longlat <- voscir %>%
  dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  voscir.fold <- kfold(voscir.longlat, k = 5)
  voscir.test <- voscir.longlat[voscir.fold == 1,]
  voscir.train <- voscir.longlat[voscir.fold != 1,]

  
  
  # Step 2: Calculate overlaps
  ## Step 2a: Individual models
  vos.maxent <- maxent(x = stack(bioclim),
                       p = vos.train, 
                       a = bg.train)
  vos.predict <- dismo::predict(vos.maxent,
                                stack(bioclim))
  
  cir.maxent <- maxent(x = stack(bioclim), 
                       p = cir.train, 
                       a = bg.train)
  cir.predict <- dismo::predict(cir.maxent,
                                stack(bioclim))
  
  ## Step 2b: Multiply bee and plant habitat suitability to get a joint probability
  voscir.overlap <- as(vos.predict * cir.predict, "SpatRaster")
  
  
  
  # Step 3: Calculate IDM
  voscir.maxent <- maxent(x = stack(bioclim), 
                          p = voscir.train, 
                          a = bg.train)
  
  voscir.idm <- as(dismo::predict(voscir.maxent, stack(bioclim)), "SpatRaster")
  
  
  
  # Step 4: Subtract predicted rasters to determine whether overlaps over- or under-predict interaction occurrence compared to IDM
  ### positive value = overlap over-predicts
  ### negative value = overlap under-predicts
  overlap_idm = data.frame(run = i, difference = (voscir.overlap - voscir.idm)[])

  voscir.diffdf <- bind_rows(voscir.diffdf, overlap_idm)
  
  # Step 5: Evaluate overlap model and IDM with the same interaction test data
  ## Step 5a: Use modEvA::AUC to get AUC
  voscir.overlap.auc <- AUC(obs = voscir.test, pred = voscir.overlap)
  voscir.idm.auc <- AUC(obs = voscir.test, pred = voscir.idm)
  
  
  ## Step 5b: Save Evaluation Scores
  voscir.overlap.eval = data.frame(run = i,
                        model = "overlap",
                        AUC = voscir.overlap.auc$AUC,
                        TSS = max(voscir.overlap.auc$thresholds$sensitivity + voscir.overlap.auc$thresholds$specificity - 1))

  voscir.idm.eval = data.frame(run = i,
                        model = "IDM",
                        AUC = voscir.idm.auc$AUC,
                        TSS = max(voscir.idm.auc$thresholds$sensitivity + voscir.idm.auc$thresholds$specificity - 1))
  
  voscir.evaldf = bind_rows(voscir.evaldf, voscir.overlap.eval, voscir.idm.eval)
}

write.csv(voscir.evaldf, file = "completed-evals/voscir-eval.csv")
write.csv(voscir.diffdf, file = "completed-evals/voscir-diff.csv")
#write.csv(voscir.varimpdf, file = "completed-evals/voscir-varimport.csv")
```

## Lupinus

```{r vos lup data, message = F}
gbif.lup <- gbif %>%
  filter(genus == "Lupinus")

voslup <- bbna %>% 
  filter(species == "vosnesenskii",
         plant.host.genus == "Lupinus") %>%
  dplyr::select(latitude, longitude, plant.host.genus, date, month, day, year)
```

```{r voslup maxent for loop, message = F}
voslup.evaldf <- data.frame()

voslup.diffdf <- data.frame()

voslup.varimpdf <- data.frame()

set.seed(122323)
for(i in 1:100){
  # Step 1: separate all data into training and testing datasets
  bg <- as.data.frame(spatSample(x = bioclim, size = 10000, method = "random", na.rm = T, xy = T)) %>%
    dplyr::select(x, y) %>%
    rename(longitude = x,
           latitude = y)
  bgfold <- kfold(bg, k = 5)
  bg.test <- bg[bgfold == 1,]
  bg.train <- bg[bgfold != 1,]
  
  vos.longlat <- bbna %>%
    filter(species == "vosnesenskii",
           plant.host.genus != "Lupinus") %>%
    slice_sample(by = BBNA.code, n = 1) %>%
    dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  vos.fold <- kfold(vos.longlat, k = 5)
  vos.test <- vos.longlat[vos.fold == 1,]
  vos.train <- vos.longlat[vos.fold != 1,]
  
  lup.longlat <- gbif.lup %>%
  dplyr::select(decimalLongitude, decimalLatitude) %>%
  as.data.frame(.) %>%
  rename(longitude = decimalLongitude,
         latitude = decimalLatitude)
  lup.fold <- kfold(lup.longlat, k = 5)
  lup.test <- lup.longlat[lup.fold == 1,]
  lup.train <- lup.longlat[lup.fold != 1,]
  
  voslup.longlat <- voslup %>%
  dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  voslup.fold <- kfold(voslup.longlat, k = 5)
  voslup.test <- voslup.longlat[voslup.fold == 1,]
  voslup.train <- voslup.longlat[voslup.fold != 1,]

  
  
  # Step 2: Calculate overlaps
  ## Step 2a: Individual models
  vos.maxent <- maxent(x = stack(bioclim),
                       p = vos.train, 
                       a = bg.train)
  vos.predict <- dismo::predict(vos.maxent,
                                stack(bioclim))
  
  lup.maxent <- maxent(x = stack(bioclim), 
                       p = lup.train, 
                       a = bg.train)
  lup.predict <- dismo::predict(lup.maxent,
                                stack(bioclim))
  
  ## Step 2b: Multiply bee and plant habitat suitability to get a joint probability
  voslup.overlap <- as(vos.predict * lup.predict, "SpatRaster")
  
  
  
  # Step 3: Calculate IDM
  voslup.maxent <- maxent(x = stack(bioclim), 
                          p = voslup.train, 
                          a = bg.train)
  
  voslup.idm <- as(dismo::predict(voslup.maxent, stack(bioclim)), "SpatRaster")
  
  
  
  # Step 4: Subtract predicted rasters to determine whether overlaps over- or under-predict interaction occurrence compared to IDM
  ### positive value = overlap over-predicts
  ### negative value = overlap under-predicts
  overlap_idm = data.frame(run = i, difference = (voslup.overlap - voslup.idm)[])

  voslup.diffdf <- bind_rows(voslup.diffdf, overlap_idm)
  
  # Step 5: Evaluate overlap model and IDM with the same interaction test data
  ## Step 5a: Use modEvA::AUC to get AUC
  voslup.overlap.auc <- AUC(obs = voslup.test, pred = voslup.overlap)
  voslup.idm.auc <- AUC(obs = voslup.test, pred = voslup.idm)
  
  
  ## Step 5b: Save Evaluation Scores
  voslup.overlap.eval = data.frame(run = i,
                        model = "overlap",
                        AUC = voslup.overlap.auc$AUC,
                        TSS = max(voslup.overlap.auc$thresholds$sensitivity + voslup.overlap.auc$thresholds$specificity - 1))

  voslup.idm.eval = data.frame(run = i,
                        model = "IDM",
                        AUC = voslup.idm.auc$AUC,
                        TSS = max(voslup.idm.auc$thresholds$sensitivity + voslup.idm.auc$thresholds$specificity - 1))
  
  voslup.evaldf = bind_rows(voslup.evaldf, voslup.overlap.eval, voslup.idm.eval)
}

write.csv(voslup.evaldf, file = "completed-evals/voslup-eval.csv")
write.csv(voslup.diffdf, file = "completed-evals/voslup-diff.csv")
# write.csv(voslup.varimpdf, file = "completed-evals/voslup-varimport.csv")
```

<!-- ### L. polyphyllus -->

<!-- ```{r vos X lupinus polyphyllus} -->
<!-- gbif.luppoly <- gbif %>% -->
<!--   filter(species == "Lupinus polyphyllus") -->

<!-- vosluppoly.evaldf <- data.frame() -->

<!-- vosluppoly.varimpdf <- data.frame() -->

<!-- set.seed(42224) -->

<!-- for(i in 1:100){ -->
<!--   # Step 1: separate all data into training and testing datasets -->
<!--   bg <- as.data.frame(spatSample(x = bioclim, size = 10000, method = "random", na.rm = T, xy = T)) %>% -->
<!--     dplyr::select(x, y) %>% -->
<!--     rename(longitude = x, -->
<!--            latitude = y) -->
<!--   bgfold <- kfold(bg, k = 5) -->
<!--   bg.test <- bg[bgfold == 1,] -->
<!--   bg.train <- bg[bgfold != 1,] -->

<!--   vos.longlat <- bbna %>% -->
<!--     filter(species == "vosnesenskii", -->
<!--            plant.host.genus != "Lupinus") %>% -->
<!--     slice_sample(by = BBNA.code, n = 1) %>% -->
<!--     dplyr::select(longitude, latitude) %>% -->
<!--   as.data.frame(.) -->
<!--   vos.fold <- kfold(vos.longlat, k = 5) -->
<!--   vos.test <- vos.longlat[vos.fold == 1,] -->
<!--   vos.train <- vos.longlat[vos.fold != 1,] -->

<!--   luppoly.longlat <- gbif.luppoly %>% -->
<!--   dplyr::select(decimalLongitude, decimalLatitude) %>% -->
<!--   as.data.frame(.) %>% -->
<!--   rename(longitude = decimalLongitude, -->
<!--          latitude = decimalLatitude) -->
<!--   luppoly.fold <- kfold(luppoly.longlat, k = 5) -->
<!--   luppoly.test <- luppoly.longlat[luppoly.fold == 1,] -->
<!--   luppoly.train <- luppoly.longlat[luppoly.fold != 1,] -->

<!--   voslup.longlat <- voslup %>% -->
<!--   dplyr::select(longitude, latitude) %>% -->
<!--   as.data.frame(.) -->
<!--   voslup.fold <- kfold(voslup.longlat, k = 5) -->
<!--   voslup.test <- voslup.longlat[voslup.fold == 1,] -->
<!--   voslup.train <- voslup.longlat[voslup.fold != 1,] -->



<!--   # Step 2: Calculate overlaps -->
<!--   ## Step 2a: Initial models based on just bioclim variables -->
<!--   vos.maxent <- maxent(x = stack(bioclim), -->
<!--                        p = vos.train,  -->
<!--                        a = bg.train) -->
<!--   vos.predict <- dismo::predict(vos.maxent, -->
<!--                                 stack(bioclim)) -->

<!--   luppoly.maxent <- maxent(x = stack(bioclim),  -->
<!--                        p = luppoly.train,  -->
<!--                        a = bg.train) -->
<!--   luppoly.predict <- dismo::predict(luppoly.maxent, -->
<!--                                 stack(bioclim)) -->

<!--   ## Step 2b: Updated models including partner -->
<!--   vos.by.luppoly <- maxent(x = stack(stack(bioclim), luppoly.predict), -->
<!--                        p = vos.train, -->
<!--                        a = bg.train) -->
<!--   luppoly.by.vos <- maxent(x = stack(stack(bioclim), vos.predict), -->
<!--                        p = luppoly.train, -->
<!--                        a = bg.train) -->




<!--   # Step 4: Evaluate all both overlap models and IDM with the same interaction test data -->
<!--   ## Step 4a: Use dismo::evaluate to get AUC and TSS scores -->
<!--   vosbyluppoly.eval <- dismo::evaluate(p = voslup.test, -->
<!--                                    a = bg.test, -->
<!--                                    model = vos.by.luppoly, -->
<!--                                    x = stack(stack(bioclim), luppoly.predict)) -->
<!--   luppolybyvos.eval <- dismo::evaluate(p = voslup.test, -->
<!--                                    a = bg.test, -->
<!--                                    model = luppoly.by.vos, -->
<!--                                    x = stack(stack(bioclim), vos.predict)) -->


<!--   # Step 5: Save Evaluation Scores -->
<!--   vblpoly.eval = data.frame(run = i, -->
<!--                         model = "vblpoly", -->
<!--                         AUC = vosbyluppoly.eval@auc, -->
<!--                         cor = vosbyluppoly.eval@cor, -->
<!--                         TSS = max(vosbyluppoly.eval@TPR - vosbyluppoly.eval@FPR), -->
<!--                         tstar = which.max(vosbyluppoly.eval@TPR - vosbyluppoly.eval@FPR)) -->

<!--   lpolybv.eval = data.frame(run = i, -->
<!--                         model = "lpolybv", -->
<!--                         AUC = luppolybyvos.eval@auc, -->
<!--                         cor = luppolybyvos.eval@cor, -->
<!--                         TSS = max(luppolybyvos.eval@TPR - luppolybyvos.eval@FPR), -->
<!--                         tstar = which.max(luppolybyvos.eval@TPR - luppolybyvos.eval@FPR)) -->



<!--   vosluppoly.evaldf = bind_rows(vosluppoly.evaldf, vblpoly.eval, lpolybv.eval) -->

<!--   # Step 6: Save Variable Importance -->
<!--   vblpoly.vars = data.frame(run = rep(i, 21), -->
<!--                         model = rep("vblpoly", 21), -->
<!--                         variable = names(vos.by.luppoly@results[7:27,]), -->
<!--                         percent = vos.by.luppoly@results[7:27], -->
<!--                         permutation = vos.by.luppoly@results[28:48]) -->

<!--   lpolybv.vars = data.frame(run = rep(i, 21), -->
<!--                         model = rep("lpolybv", 21), -->
<!--                         variable = names(luppoly.by.vos@results[7:27,]), -->
<!--                         percent = luppoly.by.vos@results[7:27], -->
<!--                         permutation = luppoly.by.vos@results[28:48]) -->

<!--   vosluppoly.varimpdf = bind_rows(vosluppoly.varimpdf, vblpoly.vars, lpolybv.vars) -->
<!-- } -->
<!-- ``` -->

<!-- ### L. bicolor -->

<!-- ```{r vos X lupinus bicolor} -->
<!-- gbif.lupbicolor <- gbif %>% -->
<!--   filter(species == "Lupinus bicolor") -->

<!-- voslupbicolor.evaldf <- data.frame() -->

<!-- voslupbicolor.varimpdf <- data.frame() -->

<!-- set.seed(423224) -->

<!-- for(i in 1:100){ -->
<!--   # Step 1: separate all data into training and testing datasets -->
<!--   bg <- as.data.frame(spatSample(x = bioclim, size = 10000, method = "random", na.rm = T, xy = T)) %>% -->
<!--     dplyr::select(x, y) %>% -->
<!--     rename(longitude = x, -->
<!--            latitude = y) -->
<!--   bgfold <- kfold(bg, k = 5) -->
<!--   bg.test <- bg[bgfold == 1,] -->
<!--   bg.train <- bg[bgfold != 1,] -->

<!--   vos.longlat <- bbna %>% -->
<!--     filter(species == "vosnesenskii", -->
<!--            plant.host.genus != "Lupinus") %>% -->
<!--     slice_sample(by = BBNA.code, n = 1) %>% -->
<!--     dplyr::select(longitude, latitude) %>% -->
<!--   as.data.frame(.) -->
<!--   vos.fold <- kfold(vos.longlat, k = 5) -->
<!--   vos.test <- vos.longlat[vos.fold == 1,] -->
<!--   vos.train <- vos.longlat[vos.fold != 1,] -->

<!--   lupbicolor.longlat <- gbif.lupbicolor %>% -->
<!--   dplyr::select(decimalLongitude, decimalLatitude) %>% -->
<!--   as.data.frame(.) %>% -->
<!--   rename(longitude = decimalLongitude, -->
<!--          latitude = decimalLatitude) -->
<!--   lupbicolor.fold <- kfold(lupbicolor.longlat, k = 5) -->
<!--   lupbicolor.test <- lupbicolor.longlat[lupbicolor.fold == 1,] -->
<!--   lupbicolor.train <- lupbicolor.longlat[lupbicolor.fold != 1,] -->





<!--   # Step 2: Calculate overlaps -->
<!--   ## Step 2a: Initial models based on just bioclim variables -->
<!--   vos.maxent <- maxent(x = stack(bioclim), -->
<!--                        p = vos.train,  -->
<!--                        a = bg.train) -->
<!--   vos.predict <- dismo::predict(vos.maxent, -->
<!--                                 stack(bioclim)) -->

<!--   lupbicolor.maxent <- maxent(x = stack(bioclim),  -->
<!--                        p = lupbicolor.train,  -->
<!--                        a = bg.train) -->
<!--   lupbicolor.predict <- dismo::predict(lupbicolor.maxent, -->
<!--                                 stack(bioclim)) -->

<!--   ## Step 2b: Updated models including partner -->
<!--   vos.by.lupbicolor <- maxent(x = stack(stack(bioclim), lupbicolor.predict), -->
<!--                        p = vos.train, -->
<!--                        a = bg.train) -->
<!--   lupbicolor.by.vos <- maxent(x = stack(stack(bioclim), vos.predict), -->
<!--                        p = lupbicolor.train, -->
<!--                        a = bg.train) -->




<!--   # Step 4: Evaluate all both overlap models and IDM with the same interaction test data -->
<!--   ## Step 4a: Use dismo::evaluate to get AUC and TSS scores -->
<!--   vosbylupbicolor.eval <- dismo::evaluate(p = voslup.test, -->
<!--                                    a = bg.test, -->
<!--                                    model = vos.by.lupbicolor, -->
<!--                                    x = stack(stack(bioclim), lupbicolor.predict)) -->
<!--   lupbicolorbyvos.eval <- dismo::evaluate(p = voslup.test, -->
<!--                                    a = bg.test, -->
<!--                                    model = lupbicolor.by.vos, -->
<!--                                    x = stack(stack(bioclim), vos.predict)) -->


<!--   # Step 5: Save Evaluation Scores -->
<!--   vblbicolor.eval = data.frame(run = i, -->
<!--                         model = "vblbicolor", -->
<!--                         AUC = vosbylupbicolor.eval@auc, -->
<!--                         cor = vosbylupbicolor.eval@cor, -->
<!--                         TSS = max(vosbylupbicolor.eval@TPR - vosbylupbicolor.eval@FPR), -->
<!--                         tstar = which.max(vosbylupbicolor.eval@TPR - vosbylupbicolor.eval@FPR)) -->

<!--   lbicolorbv.eval = data.frame(run = i, -->
<!--                         model = "lbicolorbv", -->
<!--                         AUC = lupbicolorbyvos.eval@auc, -->
<!--                         cor = lupbicolorbyvos.eval@cor, -->
<!--                         TSS = max(lupbicolorbyvos.eval@TPR - lupbicolorbyvos.eval@FPR), -->
<!--                         tstar = which.max(lupbicolorbyvos.eval@TPR - lupbicolorbyvos.eval@FPR)) -->



<!--   voslupbicolor.evaldf = bind_rows(voslupbicolor.evaldf, vblbicolor.eval, lbicolorbv.eval) -->

<!--   # Step 6: Save Variable Importance -->
<!--   vblbicolor.vars = data.frame(run = rep(i, 21), -->
<!--                         model = rep("vblbicolor", 21), -->
<!--                         variable = names(vos.by.lupbicolor@results[7:27,]), -->
<!--                         percent = vos.by.lupbicolor@results[7:27], -->
<!--                         permutation = vos.by.lupbicolor@results[28:48]) -->

<!--   lbicolorbv.vars = data.frame(run = rep(i, 21), -->
<!--                         model = rep("lbicolorbv", 21), -->
<!--                         variable = names(lupbicolor.by.vos@results[7:27,]), -->
<!--                         percent = lupbicolor.by.vos@results[7:27], -->
<!--                         permutation = lupbicolor.by.vos@results[28:48]) -->

<!--   voslupbicolor.varimpdf = bind_rows(voslupbicolor.varimpdf, vblbicolor.vars, lbicolorbv.vars) -->
<!-- } -->
<!-- ``` -->

## Penstemon

```{r vos pen data, message = F}
gbif.pen <- gbif %>%
  filter(genus == "Penstemon")

vospen <- bbna %>% 
  filter(species == "vosnesenskii",
         plant.host.genus == "Penstemon") %>%
  dplyr::select(latitude, longitude, plant.host.genus, date, month, day, year)
```

```{r vospen maxent for loop, message = F}
vospen.evaldf <- data.frame()

vospen.diffdf <- data.frame()

vospen.varimpdf <- data.frame()

set.seed(65784)
for(i in 1:100){
  # Step 1: separate all data into training and testing datasets
  bg <- as.data.frame(spatSample(x = bioclim, size = 10000, method = "random", na.rm = T, xy = T)) %>%
    dplyr::select(x, y) %>%
    rename(longitude = x,
           latitude = y)
  bgfold <- kfold(bg, k = 5)
  bg.test <- bg[bgfold == 1,]
  bg.train <- bg[bgfold != 1,]
  
  vos.longlat <- bbna %>%
    filter(species == "vosnesenskii",
           plant.host.genus != "Penstemon") %>%
    slice_sample(by = BBNA.code, n = 1) %>%
    dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  vos.fold <- kfold(vos.longlat, k = 5)
  vos.test <- vos.longlat[vos.fold == 1,]
  vos.train <- vos.longlat[vos.fold != 1,]
  
  pen.longlat <- gbif.pen %>%
  dplyr::select(decimalLongitude, decimalLatitude) %>%
  as.data.frame(.) %>%
  rename(longitude = decimalLongitude,
         latitude = decimalLatitude)
  pen.fold <- kfold(pen.longlat, k = 5)
  pen.test <- pen.longlat[pen.fold == 1,]
  pen.train <- pen.longlat[pen.fold != 1,]
  
  vospen.longlat <- vospen %>%
  dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  vospen.fold <- kfold(vospen.longlat, k = 5)
  vospen.test <- vospen.longlat[vospen.fold == 1,]
  vospen.train <- vospen.longlat[vospen.fold != 1,]

  
  
  # Step 2: Calculate overlaps
  ## Step 2a: Individual models
  vos.maxent <- maxent(x = stack(bioclim),
                       p = vos.train, 
                       a = bg.train)
  vos.predict <- dismo::predict(vos.maxent,
                                stack(bioclim))
  
  pen.maxent <- maxent(x = stack(bioclim), 
                       p = pen.train, 
                       a = bg.train)
  pen.predict <- dismo::predict(pen.maxent,
                                stack(bioclim))
  
  ## Step 2b: Multiply bee and plant habitat suitability to get a joint probability
  vospen.overlap <- as(vos.predict * pen.predict, "SpatRaster")
  
  
  
  # Step 3: Calculate IDM
  vospen.maxent <- maxent(x = stack(bioclim), 
                          p = vospen.train, 
                          a = bg.train)
  
  vospen.idm <- as(dismo::predict(vospen.maxent, stack(bioclim)), "SpatRaster")
  
  
  
  # Step 4: Subtract predicted rasters to determine whether overlaps over- or under-predict interaction occurrence compared to IDM
  ### positive value = overlap over-predicts
  ### negative value = overlap under-predicts
  overlap_idm = data.frame(run = i, difference = (vospen.overlap - vospen.idm)[])

  vospen.diffdf <- bind_rows(vospen.diffdf, overlap_idm)
  
  # Step 5: Evaluate overlap model and IDM with the same interaction test data
  ## Step 5a: Use modEvA::AUC to get AUC
  vospen.overlap.auc <- AUC(obs = vospen.test, pred = vospen.overlap)
  vospen.idm.auc <- AUC(obs = vospen.test, pred = vospen.idm)
  
  
  ## Step 5b: Save Evaluation Scores
  vospen.overlap.eval = data.frame(run = i,
                        model = "overlap",
                        AUC = vospen.overlap.auc$AUC,
                        TSS = max(vospen.overlap.auc$thresholds$sensitivity + vospen.overlap.auc$thresholds$specificity - 1))

  vospen.idm.eval = data.frame(run = i,
                        model = "IDM",
                        AUC = vospen.idm.auc$AUC,
                        TSS = max(vospen.idm.auc$thresholds$sensitivity + vospen.idm.auc$thresholds$specificity - 1))
  
  vospen.evaldf = bind_rows(vospen.evaldf, vospen.overlap.eval, vospen.idm.eval)
}

write.csv(vospen.evaldf, file = "completed-evals/vospen-eval.csv")
write.csv(vospen.diffdf, file = "completed-evals/vospen-diff.csv")
#write.csv(vospen.varimpdf, file = "completed-evals/vospen-varimport.csv")
```


## Rubus

```{r vos rub data, message = F}
gbif.rub <- gbif %>%
  filter(genus == "Rubus")

vosrub <- bbna %>% 
  filter(species == "vosnesenskii",
         plant.host.genus == "Rubus") %>%
  dplyr::select(latitude, longitude, plant.host.genus, date, month, day, year)
```

```{r vosrub maxent for loop, message = F}
vosrub.evaldf <- data.frame()

vosrub.diffdf <- data.frame()

vosrub.varimpdf <- data.frame()

set.seed(11424)
for(i in 1:100){
  # Step 1: separate all data into training and testing datasets
  bg <- as.data.frame(spatSample(x = bioclim, size = 10000, method = "random", na.rm = T, xy = T)) %>%
    dplyr::select(x, y) %>%
    rename(longitude = x,
           latitude = y)
  bgfold <- kfold(bg, k = 5)
  bg.test <- bg[bgfold == 1,]
  bg.train <- bg[bgfold != 1,]
  
  vos.longlat <- bbna %>%
    filter(species == "vosnesenskii",
           plant.host.genus != "Rubus") %>%
    slice_sample(by = BBNA.code, n = 1) %>%
    dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  vos.fold <- kfold(vos.longlat, k = 5)
  vos.test <- vos.longlat[vos.fold == 1,]
  vos.train <- vos.longlat[vos.fold != 1,]
  
  rub.longlat <- gbif.rub %>%
  dplyr::select(decimalLongitude, decimalLatitude) %>%
  as.data.frame(.) %>%
  rename(longitude = decimalLongitude,
         latitude = decimalLatitude)
  rub.fold <- kfold(rub.longlat, k = 5)
  rub.test <- rub.longlat[rub.fold == 1,]
  rub.train <- rub.longlat[rub.fold != 1,]
  
  vosrub.longlat <- vosrub %>%
  dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  vosrub.fold <- kfold(vosrub.longlat, k = 5)
  vosrub.test <- vosrub.longlat[vosrub.fold == 1,]
  vosrub.train <- vosrub.longlat[vosrub.fold != 1,]

  
  
  # Step 2: Calculate overlaps
  ## Step 2a: Individual models
  vos.maxent <- maxent(x = stack(bioclim),
                       p = vos.train, 
                       a = bg.train)
  vos.predict <- dismo::predict(vos.maxent,
                                stack(bioclim))
  
  rub.maxent <- maxent(x = stack(bioclim), 
                       p = rub.train, 
                       a = bg.train)
  rub.predict <- dismo::predict(rub.maxent,
                                stack(bioclim))
  
  ## Step 2b: Multiply bee and plant habitat suitability to get a joint probability
  vosrub.overlap <- as(vos.predict * rub.predict, "SpatRaster")
  
  
  
  # Step 3: Calculate IDM
  vosrub.maxent <- maxent(x = stack(bioclim), 
                          p = vosrub.train, 
                          a = bg.train)
  
  vosrub.idm <- as(dismo::predict(vosrub.maxent, stack(bioclim)), "SpatRaster")
  
  
  
  # Step 4: Subtract predicted rasters to determine whether overlaps over- or under-predict interaction occurrence compared to IDM
  ### positive value = overlap over-predicts
  ### negative value = overlap under-predicts
  overlap_idm = data.frame(run = i, difference = (vosrub.overlap - vosrub.idm)[])

  vosrub.diffdf <- bind_rows(vosrub.diffdf, overlap_idm)
  
  # Step 5: Evaluate overlap model and IDM with the same interaction test data
  ## Step 5a: Use modEvA::AUC to get AUC
  vosrub.overlap.auc <- AUC(obs = vosrub.test, pred = vosrub.overlap)
  vosrub.idm.auc <- AUC(obs = vosrub.test, pred = vosrub.idm)
  
  
  ## Step 5b: Save Evaluation Scores
  vosrub.overlap.eval = data.frame(run = i,
                        model = "overlap",
                        AUC = vosrub.overlap.auc$AUC,
                        TSS = max(vosrub.overlap.auc$thresholds$sensitivity + vosrub.overlap.auc$thresholds$specificity - 1))

  vosrub.idm.eval = data.frame(run = i,
                        model = "IDM",
                        AUC = vosrub.idm.auc$AUC,
                        TSS = max(vosrub.idm.auc$thresholds$sensitivity + vosrub.idm.auc$thresholds$specificity - 1))
  
  vosrub.evaldf = bind_rows(vosrub.evaldf, vosrub.overlap.eval, vosrub.idm.eval)
}

write.csv(vosrub.evaldf, file = "completed-evals/vosrub-eval.csv")
write.csv(vosrub.diffdf, file = "completed-evals/vosrub-diff.csv")
# write.csv(vosrub.varimpdf, file = "completed-evals/vosrub-varimport.csv")
```

<!-- ### Rubus spectabilis -->

<!-- ```{r mixtus rubus spectabilis} -->
<!-- gbif.rubspec <- gbif %>% -->
<!--   filter(species == "Rubus spectabilis") -->

<!-- vosrubspec.evaldf <- data.frame() -->

<!-- vosrubspec.varimpdf <- data.frame() -->

<!-- set.seed(24224) -->
<!-- for(i in 1:100){ -->
<!--   # Step 1: separate all data into training and testing datasets -->
<!--   bg <- as.data.frame(spatSample(x = bioclim, size = 10000, method = "random", na.rm = T, xy = T)) %>% -->
<!--     dplyr::select(x, y) %>% -->
<!--     rename(longitude = x, -->
<!--            latitude = y) -->
<!--   bgfold <- kfold(bg, k = 5) -->
<!--   bg.test <- bg[bgfold == 1,] -->
<!--   bg.train <- bg[bgfold != 1,] -->

<!--   vos.longlat <- bbna %>% -->
<!--     filter(species == "vosnesenskii", -->
<!--            plant.host.genus != "Rubus") %>% -->
<!--     slice_sample(by = BBNA.code, n = 1) %>% -->
<!--     dplyr::select(longitude, latitude) %>% -->
<!--   as.data.frame(.) -->
<!--   vos.fold <- kfold(vos.longlat, k = 5) -->
<!--   vos.test <- vos.longlat[vos.fold == 1,] -->
<!--   vos.train <- vos.longlat[vos.fold != 1,] -->

<!--   rubspec.longlat <- gbif.rubspec %>% -->
<!--   dplyr::select(decimalLongitude, decimalLatitude) %>% -->
<!--   as.data.frame(.) %>% -->
<!--   rename(longitude = decimalLongitude, -->
<!--          latitude = decimalLatitude) -->
<!--   rubspec.fold <- kfold(rubspec.longlat, k = 5) -->
<!--   rubspec.test <- rubspec.longlat[rubspec.fold == 1,] -->
<!--   rubspec.train <- rubspec.longlat[rubspec.fold != 1,] -->

<!--   vosrubspec.longlat <- vosrub %>% -->
<!--   dplyr::select(longitude, latitude) %>% -->
<!--   as.data.frame(.) -->
<!--   vosrubspec.fold <- kfold(vosrubspec.longlat, k = 5) -->
<!--   vosrubspec.test <- vosrubspec.longlat[vosrubspec.fold == 1,] -->
<!--   vosrubspec.train <- vosrubspec.longlat[vosrubspec.fold != 1,] -->



<!--   # Step 2: Calculate overlaps -->
<!--   ## Step 2a: Initial models based on just bioclim variables -->
<!--   vos.maxent <- maxent(x = stack(bioclim), -->
<!--                        p = vos.train,  -->
<!--                        a = bg.train) -->
<!--   vos.predict <- dismo::predict(vos.maxent, -->
<!--                                 stack(bioclim)) -->

<!--   rubspec.maxent <- maxent(x = stack(bioclim),  -->
<!--                        p = rubspec.train,  -->
<!--                        a = bg.train) -->
<!--   rubspec.predict <- dismo::predict(rubspec.maxent, -->
<!--                                 stack(bioclim)) -->

<!--   ## Step 2b: Updated models including partner -->
<!--   vos.by.rubspec <- maxent(x = stack(stack(bioclim), rubspec.predict), -->
<!--                        p = vos.train, -->
<!--                        a = bg.train) -->
<!--   rubspec.by.vos <- maxent(x = stack(stack(bioclim), vos.predict), -->
<!--                        p = rubspec.train, -->
<!--                        a = bg.train) -->





<!--   # Step 4: Evaluate all both overlap models and IDM with the same interaction test data -->
<!--   ## Step 4a: Use dismo::evaluate to get AUC and TSS scores -->
<!--   vosbyrubspec.eval <- dismo::evaluate(p = vosrub.test, -->
<!--                                    a = bg.test, -->
<!--                                    model = vos.by.rubspec, -->
<!--                                    x = stack(stack(bioclim), rubspec.predict)) -->
<!--   rubspecbyvos.eval <- dismo::evaluate(p = vosrub.test, -->
<!--                                    a = bg.test, -->
<!--                                    model = rubspec.by.vos, -->
<!--                                    x = stack(stack(bioclim), vos.predict)) -->






<!--   # Step 5: Save Evaluation Scores -->
<!--   vbrubspec.eval = data.frame(run = i, -->
<!--                         model = "vbrubspec", -->
<!--                         AUC = vosbyrubspec.eval@auc, -->
<!--                         cor = vosbyrubspec.eval@cor, -->
<!--                         TSS = max(vosbyrubspec.eval@TPR - vosbyrubspec.eval@FPR), -->
<!--                         tstar = which.max(vosbyrubspec.eval@TPR - vosbyrubspec.eval@FPR)) -->

<!--   rubspecbv.eval = data.frame(run = i, -->
<!--                         model = "rubspecbv", -->
<!--                         AUC = rubspecbyvos.eval@auc, -->
<!--                         cor = rubspecbyvos.eval@cor, -->
<!--                         TSS = max(rubspecbyvos.eval@TPR - rubspecbyvos.eval@FPR), -->
<!--                         tstar = which.max(rubspecbyvos.eval@TPR - rubspecbyvos.eval@FPR)) -->



<!--   vosrubspec.evaldf = bind_rows(vosrubspec.evaldf, vbrubspec.eval, rubspecbv.eval) -->




<!--   # Step 6: Save Variable Importance -->
<!--   vbrubspec.vars = data.frame(run = rep(i, 21), -->
<!--                         model = rep("vbrubspec", 21), -->
<!--                         variable = names(vos.by.rubspec@results[7:27,]), -->
<!--                         percent = vos.by.rubspec@results[7:27], -->
<!--                         permutation = vos.by.rubspec@results[28:48]) -->

<!--   rubspecbv.vars = data.frame(run = rep(i, 21), -->
<!--                         model = rep("rubspecbv", 21), -->
<!--                         variable = names(rubspec.by.vos@results[7:27,]), -->
<!--                         percent = rubspec.by.vos@results[7:27], -->
<!--                         permutation = rubspec.by.vos@results[28:48]) -->



<!--   vosrubspec.varimpdf = bind_rows(vosrubspec.varimpdf, vbrubspec.vars, rubspecbv.vars) -->
<!-- } -->
<!-- ``` -->


<!-- ### Rubus parviflorus -->

<!-- ```{r mixtus rubus parviflorus} -->
<!-- gbif.rubparv <- gbif %>% -->
<!--   filter(species == "Rubus parviflorus") -->

<!-- vosrubparv.evaldf <- data.frame() -->

<!-- vosrubparv.varimpdf <- data.frame() -->

<!-- set.seed(2024419) -->
<!-- for(i in 1:100){ -->
<!--   # Step 1: separate all data into training and testing datasets -->
<!--   bg <- as.data.frame(spatSample(x = bioclim, size = 10000, method = "random", na.rm = T, xy = T)) %>% -->
<!--     dplyr::select(x, y) %>% -->
<!--     rename(longitude = x, -->
<!--            latitude = y) -->
<!--   bgfold <- kfold(bg, k = 5) -->
<!--   bg.test <- bg[bgfold == 1,] -->
<!--   bg.train <- bg[bgfold != 1,] -->

<!--   vos.longlat <- bbna %>% -->
<!--     filter(species == "vosnesenskii", -->
<!--            plant.host.genus != "Rubus") %>% -->
<!--     slice_sample(by = BBNA.code, n = 1) %>% -->
<!--     dplyr::select(longitude, latitude) %>% -->
<!--   as.data.frame(.) -->
<!--   vos.fold <- kfold(vos.longlat, k = 5) -->
<!--   vos.test <- vos.longlat[vos.fold == 1,] -->
<!--   vos.train <- vos.longlat[vos.fold != 1,] -->

<!--   rubparv.longlat <- gbif.rubparv %>% -->
<!--   dplyr::select(decimalLongitude, decimalLatitude) %>% -->
<!--   as.data.frame(.) %>% -->
<!--   rename(longitude = decimalLongitude, -->
<!--          latitude = decimalLatitude) -->
<!--   rubparv.fold <- kfold(rubparv.longlat, k = 5) -->
<!--   rubparv.test <- rubparv.longlat[rubparv.fold == 1,] -->
<!--   rubparv.train <- rubparv.longlat[rubparv.fold != 1,] -->

<!--   vosrubparv.longlat <- vosrub %>% -->
<!--   dplyr::select(longitude, latitude) %>% -->
<!--   as.data.frame(.) -->
<!--   vosrubparv.fold <- kfold(vosrubparv.longlat, k = 5) -->
<!--   vosrubparv.test <- vosrubparv.longlat[vosrubparv.fold == 1,] -->
<!--   vosrubparv.train <- vosrubparv.longlat[vosrubparv.fold != 1,] -->



<!--   # Step 2: Calculate overlaps -->
<!--   ## Step 2a: Initial models based on just bioclim variables -->
<!--   vos.maxent <- maxent(x = stack(bioclim), -->
<!--                        p = vos.train,  -->
<!--                        a = bg.train) -->
<!--   vos.predict <- dismo::predict(vos.maxent, -->
<!--                                 stack(bioclim)) -->

<!--   rubparv.maxent <- maxent(x = stack(bioclim),  -->
<!--                        p = rubparv.train,  -->
<!--                        a = bg.train) -->
<!--   rubparv.predict <- dismo::predict(rubparv.maxent, -->
<!--                                 stack(bioclim)) -->

<!--   ## Step 2b: Updated models including partner -->
<!--   vos.by.rubparv <- maxent(x = stack(stack(bioclim), rubparv.predict), -->
<!--                        p = vos.train, -->
<!--                        a = bg.train) -->
<!--   rubparv.by.vos <- maxent(x = stack(stack(bioclim), vos.predict), -->
<!--                        p = rubparv.train, -->
<!--                        a = bg.train) -->





<!--   # Step 4: Evaluate all both overlap models and IDM with the same interaction test data -->
<!--   ## Step 4a: Use dismo::evaluate to get AUC and TSS scores -->
<!--   vosbyrubparv.eval <- dismo::evaluate(p = vosrub.test, -->
<!--                                    a = bg.test, -->
<!--                                    model = vos.by.rubparv, -->
<!--                                    x = stack(stack(bioclim), rubparv.predict)) -->
<!--   rubparvbyvos.eval <- dismo::evaluate(p = vosrub.test, -->
<!--                                    a = bg.test, -->
<!--                                    model = rubparv.by.vos, -->
<!--                                    x = stack(stack(bioclim), vos.predict)) -->






<!--   # Step 5: Save Evaluation Scores -->
<!--   vbrubparv.eval = data.frame(run = i, -->
<!--                         model = "vbrubparv", -->
<!--                         AUC = vosbyrubparv.eval@auc, -->
<!--                         cor = vosbyrubparv.eval@cor, -->
<!--                         TSS = max(vosbyrubparv.eval@TPR - vosbyrubparv.eval@FPR), -->
<!--                         tstar = which.max(vosbyrubparv.eval@TPR - vosbyrubparv.eval@FPR)) -->

<!--   rubparvbv.eval = data.frame(run = i, -->
<!--                         model = "rubparvbv", -->
<!--                         AUC = rubparvbyvos.eval@auc, -->
<!--                         cor = rubparvbyvos.eval@cor, -->
<!--                         TSS = max(rubparvbyvos.eval@TPR - rubparvbyvos.eval@FPR), -->
<!--                         tstar = which.max(rubparvbyvos.eval@TPR - rubparvbyvos.eval@FPR)) -->



<!--   vosrubparv.evaldf = bind_rows(vosrubparv.evaldf, vbrubparv.eval, rubparvbv.eval) -->




<!--   # Step 6: Save Variable Importance -->
<!--   vbrubparv.vars = data.frame(run = rep(i, 21), -->
<!--                         model = rep("vbrubparv", 21), -->
<!--                         variable = names(vos.by.rubparv@results[7:27,]), -->
<!--                         percent = vos.by.rubparv@results[7:27], -->
<!--                         permutation = vos.by.rubparv@results[28:48]) -->

<!--   rubparvbv.vars = data.frame(run = rep(i, 21), -->
<!--                         model = rep("rubparvbv", 21), -->
<!--                         variable = names(rubparv.by.vos@results[7:27,]), -->
<!--                         percent = rubparv.by.vos@results[7:27], -->
<!--                         permutation = rubparv.by.vos@results[28:48]) -->



<!--   vosrubparv.varimpdf = bind_rows(vosrubparv.varimpdf, vbrubparv.vars, rubparvbv.vars) -->
<!-- } -->
<!-- ``` -->

# Session Info
```{r sessioninfo}
sessionInfo()
```

