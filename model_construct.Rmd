---
title: "IDM Model Construction"
author: "Kaysee Arrowsmith"
output: html_document
---

# Load Packages

```{r packages, message = F}
options(java.parameters = "- Xmx1024m")
library(knitr)
library(tidyverse)
library(raster)
library(geodata)
library(ENMTools)
# library(ggthemes)
# library(viridis)
library(predicts)
library(rJava)

theme_set(theme_light() +
            theme(text = element_text(size = 20)))
```

# Main Bumble Bee Data
I'm using the Bumble Bees of North America data from 2018--2022, which includes data collected for the Pacific Northwest Bumble Bee Atlas.

```{r bumble bee data}
# pnwbba <- read.csv("pnwbba_raw.csv", stringsAsFactors = F) # BBNA data is more recent
bbna <- read.csv("bbna_pnwbba.csv", stringsAsFactors = F)

top.bees <- bbna %>% 
  group_by(species) %>% 
  tally() %>%
  slice_max(order_by = n, n = 4)

top.floralpartners <- bbna %>% 
  filter(plant.host.genus != "") %>%
  group_by(plant.host.genus) %>% 
  tally() %>%
  slice_max(order_by = n, n = 5)

top.ints <- bbna %>%
  # filter(species %in% top.bees$species,
         # plant.host.genus %in% top.floralpartners$plant.host.genus) %>%
  group_by(species, plant.host.genus) %>%
  tally()

ints.by.year <- bbna %>%
  filter(species %in% top.bees$species,
         plant.host.genus %in% top.floralpartners$plant.host.genus) %>%
  group_by(year, species, plant.host.genus) %>%
  tally()
```

# Plant Data
From GBIF.org (16 January 2024) GBIF Occurrence Download  https://doi.org/10.15468/dl.ymhzyy

```{r gbif}
gbif <- read_tsv("gbif-top5.csv") %>%
  filter(year >= 2018)
```

# WorldClim Data

I'm cropping all of these predictor rasters to the extreme points of my GBIF data.

```{r worldclim, message = F}
bioclim <- crop(worldclim_global(var = "bio", 
                               res = 2.5, 
                               path = getwd()),
                ext(-130, -110, 40, 50))
# 
# elev.rast <- crop(elevation_global(res = 2.5,
#                        path = getwd()), 
#                        ext(-130, -110, 40, 50))
# 
# bioclim.elev <- c(bioclim, elev.rast)
```

Per [Feng et al. (2019)](https://onlinelibrary.wiley.com/doi/pdf/10.1002/ece3.5555), collinearity in predictors is not a major problem for MaxEnt.


# Bifarius
## Chamaenerion

Now that all the code above is working, we will run it with a new pairing -- *B. bifarius* X [*Chamaenerion* sp.](https://doi.org/10.15468/dl.9apf52)

```{r bif cham data, message = F}
gbif.cham <- gbif %>%
  filter(genus == "Chamaenerion")

bifcham <- bbna %>%
  filter(species == "bifarius",
         plant.host.genus == "Chamaenerion") %>%
  dplyr::select(latitude, longitude, plant.host.genus, date, month, day, year)
```

```{r bifcham maxent for loop, message = F}
bifcham.evaldf <- data.frame()

bifcham.varimpdf <- data.frame()

set.seed(121023)
for(i in 1:100){
  # Step 1: separate all data into training and testing datasets
  bg <- as.data.frame(spatSample(x = bioclim, size = 50000, method = "random", na.rm = T, xy = T)) %>%
    dplyr::select(x, y) %>%
    rename(longitude = x,
           latitude = y)
  bgfold <- kfold(bg, k = 5)
  bg.test <- bg[bgfold == 1,]
  bg.train <- bg[bgfold != 1,]
  
  bif.longlat <- bbna %>%
    filter(species == "bifarius",
           plant.host.genus != "Chamaenerion") %>%
    slice_sample(by = BBNA.code, n = 1) %>%
    dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  bif.fold <- kfold(bif.longlat, k = 5)
  bif.test <- bif.longlat[bif.fold == 1,]
  bif.train <- bif.longlat[bif.fold != 1,]
  
  cham.longlat <- gbif.cham %>%
  dplyr::select(decimalLongitude, decimalLatitude) %>%
  as.data.frame(.) %>%
  rename(longitude = decimalLongitude,
         latitude = decimalLatitude)
  cham.fold <- kfold(cham.longlat, k = 5)
  cham.test <- cham.longlat[cham.fold == 1,]
  cham.train <- cham.longlat[cham.fold != 1,]
  
  bifcham.longlat <- bifcham %>%
  dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  bifcham.fold <- kfold(bifcham.longlat, k = 5)
  bifcham.test <- bifcham.longlat[bifcham.fold == 1,]
  bifcham.train <- bifcham.longlat[bifcham.fold != 1,]
  
  
  
  # Step 2: Calculate overlaps
  ## Step 2a: Initial models based on just bioclim variables
  bif.maxent <- maxent(x = stack(bioclim),
                       p = bif.train, 
                       a = bg.train)
  bif.predict <- dismo::predict(bif.maxent,
                                stack(bioclim))
  
  cham.maxent <- maxent(x = stack(bioclim), 
                       p = cham.train, 
                       a = bg.train)
  cham.predict <- dismo::predict(cham.maxent,
                                stack(bioclim))
  
  ## Step 2b: Updated models including partner
  bif.by.cham <- maxent(x = stack(stack(bioclim), cham.predict),
                       p = bif.train,
                       a = bg.train)
  cham.by.bif <- maxent(x = stack(stack(bioclim), bif.predict),
                       p = cham.train,
                       a = bg.train)
  
  
  
  # Step 3: Calculate IDM
  bifcham.maxent <- maxent(x = stack(bioclim), 
                          p = bifcham.train, 
                          a = bg.train)
  
  
  
  # Step 4: Evaluate all both overlap models and IDM with the same interaction test data
  ## Step 4a: Use dismo::evaluate to get AUC and TSS scores
  bifbycham.eval <- dismo::evaluate(p = bifcham.test,
                                   a = bg.test,
                                   model = bif.by.cham,
                                   x = stack(stack(bioclim), cham.predict))
  chambybif.eval <- dismo::evaluate(p = bifcham.test,
                                   a = bg.test,
                                   model = cham.by.bif,
                                   x = stack(stack(bioclim), bif.predict))
  bifcham.eval <- dismo::evaluate(p = bifcham.test, 
                                 a = bg.test, 
                                 model = bifcham.maxent, 
                                 x = stack(bioclim))
  
  ## Step 4b: Use modEvA::Boyce to get Boyce Index
  bbcham.predict <- as(dismo::predict(bif.by.cham, stack(stack(bioclim), cham.predict)), "SpatRaster")
  bbcham.boyce <- modEvA::Boyce(obs = bifcham.test, pred = bbcham.predict)
  
  chambb.predict <- as(dismo::predict(cham.by.bif, stack(stack(bioclim), bif.predict)), "SpatRaster")
  chambb.boyce <- modEvA::Boyce(obs = bifcham.test, pred = chambb.predict)
  
  bifcham.predict <- as(dismo::predict(bifcham.maxent, stack(bioclim)), "SpatRaster")
  bifcham.boyce <- modEvA::Boyce(obs = bifcham.test, pred = bifcham.predict)
  
  # Step 5: Save Evaluation Scores
  bbcham.eval = data.frame(run = i,
                        model = "bbcham",
                        AUC = bifbycham.eval@auc,
                        cor = bifbycham.eval@cor,
                        TSS = max(bifbycham.eval@TPR - bifbycham.eval@FPR),
                        tstar = which.max(bifbycham.eval@TPR - bifbycham.eval@FPR),
                        boyce = bbcham.boyce$Boyce)
  
  chambb.eval = data.frame(run = i,
                        model = "chambb",
                        AUC = chambybif.eval@auc,
                        cor = chambybif.eval@cor,
                        TSS = max(chambybif.eval@TPR - chambybif.eval@FPR),
                        tstar = which.max(chambybif.eval@TPR - chambybif.eval@FPR),
                        boyce = chambb.boyce$Boyce)

  idm.eval = data.frame(run = i,
                        model = "IDM",
                        AUC = bifcham.eval@auc,
                        cor = bifcham.eval@cor,
                        TSS = max(bifcham.eval@TPR - bifcham.eval@FPR),
                        tstar = which.max(bifcham.eval@TPR - bifcham.eval@FPR),
                        boyce = bifcham.boyce$Boyce)
  
  bifcham.evaldf = bind_rows(bifcham.evaldf, bbcham.eval, chambb.eval, idm.eval)
  
  # Step 6: Save Variable Importance
  bbcham.vars = data.frame(run = rep(i, 21),
                        model = rep("bbcham", 21),
                        variable = names(bif.by.cham@results[7:27,]),
                        percent = bif.by.cham@results[7:27],
                        permutation = bif.by.cham@results[28:48])
    
  chambb.vars = data.frame(run = rep(i, 21),
                        model = rep("chambb", 21),
                        variable = names(cham.by.bif@results[7:27,]),
                        percent = cham.by.bif@results[7:27],
                        permutation = cham.by.bif@results[28:48])
  
  idm.vars = data.frame(run = rep(i, 20),
                        model = rep("IDM", 20),
                        variable = names(bifcham.maxent@results[7:26,]),
                        percent = bifcham.maxent@results[7:26],
                        permutation = bifcham.maxent@results[27:46])
  
  bifcham.varimpdf = bind_rows(bifcham.varimpdf, bbcham.vars, chambb.vars, idm.vars)
}

#write.csv(bifcham.evaldf, file = "completed-evals/bifcham-eval.csv")
#write.csv(bifcham.varimpdf, file = "completed-evals/bifcham-varimport.csv")
```

## Cirsium

```{r bif cir data, message = F}
gbif.cir <- gbif %>%
  filter(genus == "Cirsium")

bifcir <- bbna %>% 
  filter(species == "bifarius",
         plant.host.genus == "Cirsium") %>%
  dplyr::select(latitude, longitude, plant.host.genus, date, month, day, year)
```

```{r bifcir maxent for loop, message = F}
bifcir.evaldf <- data.frame()

bifcir.varimpdf <- data.frame()

set.seed(7840126)
for(i in 1:100){
  # Step 1: separate all data into training and testing datasets
  bg <- as.data.frame(spatSample(x = bioclim, size = 50000, method = "random", na.rm = T, xy = T)) %>%
    dplyr::select(x, y) %>%
    rename(longitude = x,
           latitude = y)
  bgfold <- kfold(bg, k = 5)
  bg.test <- bg[bgfold == 1,]
  bg.train <- bg[bgfold != 1,]
  
  bif.longlat <- bbna %>%
    filter(species == "bifarius",
           plant.host.genus != "Cirsium") %>%
    slice_sample(by = BBNA.code, n = 1) %>%
    dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  bif.fold <- kfold(bif.longlat, k = 5)
  bif.test <- bif.longlat[bif.fold == 1,]
  bif.train <- bif.longlat[bif.fold != 1,]
  
  cir.longlat <- gbif.cir %>%
  dplyr::select(decimalLongitude, decimalLatitude) %>%
  as.data.frame(.) %>%
  rename(longitude = decimalLongitude,
         latitude = decimalLatitude)
  cir.fold <- kfold(cir.longlat, k = 5)
  cir.test <- cir.longlat[cir.fold == 1,]
  cir.train <- cir.longlat[cir.fold != 1,]
  
  bifcir.longlat <- bifcir %>%
  dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  bifcir.fold <- kfold(bifcir.longlat, k = 5)
  bifcir.test <- bifcir.longlat[bifcir.fold == 1,]
  bifcir.train <- bifcir.longlat[bifcir.fold != 1,]

  
  
  # Step 2: Calculate overlaps
  ## Step 2a: Initial models based on just bioclim variables
  bif.maxent <- maxent(x = stack(bioclim),
                       p = bif.train, 
                       a = bg.train)
  bif.predict <- dismo::predict(bif.maxent,
                                stack(bioclim))
  
  cir.maxent <- maxent(x = stack(bioclim), 
                       p = cir.train, 
                       a = bg.train)
  cir.predict <- dismo::predict(cir.maxent,
                                stack(bioclim))
  
  ## Step 2b: Updated models including partner
  bif.by.cir <- maxent(x = stack(stack(bioclim), cir.predict),
                       p = bif.train,
                       a = bg.train)
  cir.by.bif <- maxent(x = stack(stack(bioclim), bif.predict),
                       p = cir.train,
                       a = bg.train)
  
  
  
  # Step 3: Calculate IDM
  bifcir.maxent <- maxent(x = stack(bioclim), 
                          p = bifcir.train, 
                          a = bg.train)
  
  
  
  # Step 4: Evaluate all both overlap models and IDM with the same interaction test data
  ## Step 4a: Use dismo::evaluate to get AUC and TSS scores
  bifbycir.eval <- dismo::evaluate(p = bifcir.test,
                                   a = bg.test,
                                   model = bif.by.cir,
                                   x = stack(stack(bioclim), cir.predict))
  cirbybif.eval <- dismo::evaluate(p = bifcir.test,
                                   a = bg.test,
                                   model = cir.by.bif,
                                   x = stack(stack(bioclim), bif.predict))
  bifcir.eval <- dismo::evaluate(p = bifcir.test, 
                                 a = bg.test, 
                                 model = bifcir.maxent, 
                                 x = stack(bioclim))
  
  ## Step 4b: Use modEvA::Boyce to get Boyce Index
  bbcir.predict <- as(dismo::predict(bif.by.cir, stack(stack(bioclim), cir.predict)), "SpatRaster")
  bbcir.boyce <- modEvA::Boyce(obs = bifcir.test, pred = bbcir.predict)
  
  cirbb.predict <- as(dismo::predict(cir.by.bif, stack(stack(bioclim), bif.predict)), "SpatRaster")
  cirbb.boyce <- modEvA::Boyce(obs = bifcir.test, pred = cirbb.predict)
  
  bifcir.predict <- as(dismo::predict(bifcir.maxent, stack(bioclim)), "SpatRaster")
  bifcir.boyce <- modEvA::Boyce(obs = bifcir.test, pred = bifcir.predict)
  
  # Step 5: Save Evaluation Scores
  bbcir.eval = data.frame(run = i,
                        model = "bbcir",
                        AUC = bifbycir.eval@auc,
                        cor = bifbycir.eval@cor,
                        TSS = max(bifbycir.eval@TPR - bifbycir.eval@FPR),
                        tstar = which.max(bifbycir.eval@TPR - bifbycir.eval@FPR),
                        boyce = bbcir.boyce$Boyce)
  
  cirbb.eval = data.frame(run = i,
                        model = "cirbb",
                        AUC = cirbybif.eval@auc,
                        cor = cirbybif.eval@cor,
                        TSS = max(cirbybif.eval@TPR - cirbybif.eval@FPR),
                        tstar = which.max(cirbybif.eval@TPR - cirbybif.eval@FPR),
                        boyce = cirbb.boyce$Boyce)

  idm.eval = data.frame(run = i,
                        model = "IDM",
                        AUC = bifcir.eval@auc,
                        cor = bifcir.eval@cor,
                        TSS = max(bifcir.eval@TPR - bifcir.eval@FPR),
                        tstar = which.max(bifcir.eval@TPR - bifcir.eval@FPR),
                        boyce = bifcir.boyce$Boyce)
  
  bifcir.evaldf = bind_rows(bifcir.evaldf, bbcir.eval, cirbb.eval, idm.eval)
  
  # Step 6: Save Variable Importance
  bbcir.vars = data.frame(run = rep(i, 21),
                        model = rep("bbcir", 21),
                        variable = names(bif.by.cir@results[7:27,]),
                        percent = bif.by.cir@results[7:27],
                        permutation = bif.by.cir@results[28:48])
    
  cirbb.vars = data.frame(run = rep(i, 21),
                        model = rep("cirbb", 21),
                        variable = names(cir.by.bif@results[7:27,]),
                        percent = cir.by.bif@results[7:27],
                        permutation = cir.by.bif@results[28:48])
  
  idm.vars = data.frame(run = rep(i, 20),
                        model = rep("IDM", 20),
                        variable = names(bifcir.maxent@results[7:26,]),
                        percent = bifcir.maxent@results[7:26],
                        permutation = bifcir.maxent@results[27:46])
  
  bifcir.varimpdf = bind_rows(bifcir.varimpdf, bbcir.vars, cirbb.vars, idm.vars)
}

#write.csv(bifcir.evaldf, file = "completed-evals/bifcir-eval.csv")
#write.csv(bifcir.varimpdf, file = "completed-evals/bifcir-varimport.csv")
```

## Lupinus

We will first run this with the most common bumble bee species/plant genus pairing -- *B. bifarius* visiting *Lupinus* sp.

```{r bif lup data, message = F}
gbif.lup <- gbif %>%
  filter(genus == "Lupinus")

biflup <- bbna %>% 
  filter(species == "bifarius",
         plant.host.genus == "Lupinus") %>%
  dplyr::select(latitude, longitude, plant.host.genus, date, month, day, year)
```

Here we have a for-loop running MaxEnt models 100 times. For each run, we will select new training and test data, calculate overlaps, and calculate an IDM. We then save the evaluation metrics (AUC, TSS) in a dataframe to assess the performance of the different methods.

```{r biflup maxent for loop, message = F}
biflup.evaldf <- data.frame()

biflup.varimpdf <- data.frame()

set.seed(122223)

for(i in 1:100){
  # Step 1: separate all data into training and testing datasets
  bg <- as.data.frame(spatSample(x = bioclim, size = 50000, method = "random", na.rm = T, xy = T)) %>%
    dplyr::select(x, y) %>%
    rename(longitude = x,
           latitude = y)
  bgfold <- kfold(bg, k = 5)
  bg.test <- bg[bgfold == 1,]
  bg.train <- bg[bgfold != 1,]
  
  bif.longlat <- bbna %>%
    filter(species == "bifarius",
           plant.host.genus != "Lupinus") %>%
    slice_sample(by = BBNA.code, n = 1) %>%
    dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  bif.fold <- kfold(bif.longlat, k = 5)
  bif.test <- bif.longlat[bif.fold == 1,]
  bif.train <- bif.longlat[bif.fold != 1,]
  
  lup.longlat <- gbif.lup %>%
  dplyr::select(decimalLongitude, decimalLatitude) %>%
  as.data.frame(.) %>%
  rename(longitude = decimalLongitude,
         latitude = decimalLatitude)
  lup.fold <- kfold(lup.longlat, k = 5)
  lup.test <- lup.longlat[lup.fold == 1,]
  lup.train <- lup.longlat[lup.fold != 1,]
  
  biflup.longlat <- biflup %>%
  dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  biflup.fold <- kfold(biflup.longlat, k = 5)
  biflup.test <- biflup.longlat[biflup.fold == 1,]
  biflup.train <- biflup.longlat[biflup.fold != 1,]

  # biflup.test <- biflup %>%
  #   filter(year == "2020") %>%
  # dplyr::select(longitude, latitude) %>%
  # as.data.frame(.)
  # biflup.train <- biflup %>%
  #   filter(year != "2020") %>%
  # dplyr::select(longitude, latitude) %>%
  # as.data.frame(.)

  
  
  # Step 2: Calculate overlaps
  ## Step 2a: Initial models based on just bioclim variables
  bif.maxent <- maxent(x = stack(bioclim),
                       p = bif.train, 
                       a = bg.train)
  bif.predict <- dismo::predict(bif.maxent,
                                stack(bioclim))
  
  lup.maxent <- maxent(x = stack(bioclim), 
                       p = lup.train, 
                       a = bg.train)
  lup.predict <- dismo::predict(lup.maxent,
                                stack(bioclim))
  
  ## Step 2b: Updated models including partner
  bif.by.lup <- maxent(x = stack(stack(bioclim), lup.predict),
                       p = bif.train,
                       a = bg.train)
  lup.by.bif <- maxent(x = stack(stack(bioclim), bif.predict),
                       p = lup.train,
                       a = bg.train)
  
  
  
  # Step 3: Calculate IDM
  biflup.maxent <- maxent(x = stack(bioclim), 
                          p = biflup.train, 
                          a = bg.train)
  
  
  
  # Step 4: Evaluate all both overlap models and IDM with the same interaction test data
  ## Step 4a: Use dismo::evaluate to get AUC and TSS scores
  bifbylup.eval <- dismo::evaluate(p = biflup.test,
                                   a = bg.test,
                                   model = bif.by.lup,
                                   x = stack(stack(bioclim), lup.predict))
  lupbybif.eval <- dismo::evaluate(p = biflup.test,
                                   a = bg.test,
                                   model = lup.by.bif,
                                   x = stack(stack(bioclim), bif.predict))
  biflup.eval <- dismo::evaluate(p = biflup.test, 
                                 a = bg.test, 
                                 model = biflup.maxent, 
                                 x = stack(bioclim))
  
  ## Step 4b: Use modEvA::Boyce to get Boyce Index
  bblup.predict <- as(dismo::predict(bif.by.lup, stack(stack(bioclim), lup.predict)), "SpatRaster")
  bblup.boyce <- modEvA::Boyce(obs = biflup.test, pred = bblup.predict)
  
  lupbb.predict <- as(dismo::predict(lup.by.bif, stack(stack(bioclim), bif.predict)), "SpatRaster")
  lupbb.boyce <- modEvA::Boyce(obs = biflup.test, pred = lupbb.predict)
  
  biflup.predict <- as(dismo::predict(biflup.maxent, stack(bioclim)), "SpatRaster")
  biflup.boyce <- modEvA::Boyce(obs = biflup.test, pred = biflup.predict)
  
  # Step 5: Save Evaluation Scores
  bbl.eval = data.frame(run = i,
                        model = "bbl",
                        AUC = bifbylup.eval@auc,
                        cor = bifbylup.eval@cor,
                        TSS = max(bifbylup.eval@TPR - bifbylup.eval@FPR),
                        tstar = which.max(bifbylup.eval@TPR - bifbylup.eval@FPR),
                        boyce = bblup.boyce$Boyce)
  
  lbb.eval = data.frame(run = i,
                        model = "lbb",
                        AUC = lupbybif.eval@auc,
                        cor = lupbybif.eval@cor,
                        TSS = max(lupbybif.eval@TPR - lupbybif.eval@FPR),
                        tstar = which.max(lupbybif.eval@TPR - lupbybif.eval@FPR),
                        boyce = lupbb.boyce$Boyce)

  idm.eval = data.frame(run = i,
                        model = "IDM",
                        AUC = biflup.eval@auc,
                        cor = biflup.eval@cor,
                        TSS = max(biflup.eval@TPR - biflup.eval@FPR),
                        tstar = which.max(biflup.eval@TPR - biflup.eval@FPR),
                        boyce = biflup.boyce$Boyce)
  
  biflup.evaldf = bind_rows(biflup.evaldf, bbl.eval, lbb.eval, idm.eval)
  
  # Step 6: Save Variable Importance
  bbl.vars = data.frame(run = rep(i, 21),
                        model = rep("bbl", 21),
                        variable = names(bif.by.lup@results[7:27,]),
                        percent = bif.by.lup@results[7:27],
                        permutation = bif.by.lup@results[28:48])
    
  lbb.vars = data.frame(run = rep(i, 21),
                        model = rep("lbb", 21),
                        variable = names(lup.by.bif@results[7:27,]),
                        percent = lup.by.bif@results[7:27],
                        permutation = lup.by.bif@results[28:48])
  
  idm.vars = data.frame(run = rep(i, 20),
                        model = rep("IDM", 20),
                        variable = names(biflup.maxent@results[7:26,]),
                        percent = biflup.maxent@results[7:26],
                        permutation = biflup.maxent@results[27:46])
  
  biflup.varimpdf = bind_rows(biflup.varimpdf, bbl.vars, lbb.vars, idm.vars)
}

#write.csv(biflup.evaldf, file = "completed-evals/biflup-eval.csv")
#write.csv(biflup.varimpdf, file = "completed-evals/biflup-varimport.csv")
```

### L. polyphyllus

Here, we're looking at whether things change if we assume that all of the *Lupinus* records are one species. This allows us to use a species-specific plant distribution, but is probably not true on the interaction level.

I'm not re-making the IDM because it should be the same. If we include this in the final paper, we probably should just so that the same background points get selected.

```{r bifarius X lupinus polyphyllus}
gbif.luppoly <- gbif %>%
  filter(species == "Lupinus polyphyllus")

bifluppoly.evaldf <- data.frame()

bifluppoly.varimpdf <- data.frame()

set.seed(41924)

for(i in 1:100){
  # Step 1: separate all data into training and testing datasets
  bg <- as.data.frame(spatSample(x = bioclim, size = 50000, method = "random", na.rm = T, xy = T)) %>%
    dplyr::select(x, y) %>%
    rename(longitude = x,
           latitude = y)
  bgfold <- kfold(bg, k = 5)
  bg.test <- bg[bgfold == 1,]
  bg.train <- bg[bgfold != 1,]
  
  bif.longlat <- bbna %>%
    filter(species == "bifarius",
           plant.host.genus != "Lupinus") %>%
    slice_sample(by = BBNA.code, n = 1) %>%
    dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  bif.fold <- kfold(bif.longlat, k = 5)
  bif.test <- bif.longlat[bif.fold == 1,]
  bif.train <- bif.longlat[bif.fold != 1,]
  
  luppoly.longlat <- gbif.luppoly %>%
  dplyr::select(decimalLongitude, decimalLatitude) %>%
  as.data.frame(.) %>%
  rename(longitude = decimalLongitude,
         latitude = decimalLatitude)
  luppoly.fold <- kfold(luppoly.longlat, k = 5)
  luppoly.test <- luppoly.longlat[luppoly.fold == 1,]
  luppoly.train <- luppoly.longlat[luppoly.fold != 1,]
  
  bifluppoly.longlat <- biflup %>%
  dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  bifluppoly.fold <- kfold(bifluppoly.longlat, k = 5)
  bifluppoly.test <- bifluppoly.longlat[bifluppoly.fold == 1,]
  bifluppoly.train <- bifluppoly.longlat[bifluppoly.fold != 1,]


  
  # Step 2: Calculate overlaps
  ## Step 2a: Initial models based on just bioclim variables
  bif.maxent <- maxent(x = stack(bioclim),
                       p = bif.train, 
                       a = bg.train)
  bif.predict <- dismo::predict(bif.maxent,
                                stack(bioclim))
  
  luppoly.maxent <- maxent(x = stack(bioclim), 
                       p = luppoly.train, 
                       a = bg.train)
  luppoly.predict <- dismo::predict(luppoly.maxent,
                                stack(bioclim))
  
  ## Step 2b: Updated models including partner
  bif.by.luppoly <- maxent(x = stack(stack(bioclim), luppoly.predict),
                       p = bif.train,
                       a = bg.train)
  luppoly.by.bif <- maxent(x = stack(stack(bioclim), bif.predict),
                       p = luppoly.train,
                       a = bg.train)

  
  
  
  # Step 4: Evaluate all both overlap models and IDM with the same interaction test data
  ## Step 4a: Use dismo::evaluate to get AUC and TSS scores
  bifbyluppoly.eval <- dismo::evaluate(p = biflup.test,
                                   a = bg.test,
                                   model = bif.by.luppoly,
                                   x = stack(stack(bioclim), luppoly.predict))
  luppolybybif.eval <- dismo::evaluate(p = biflup.test,
                                   a = bg.test,
                                   model = luppoly.by.bif,
                                   x = stack(stack(bioclim), bif.predict))

  
  # Step 5: Save Evaluation Scores
  bblpoly.eval = data.frame(run = i,
                        model = "bblpoly",
                        AUC = bifbyluppoly.eval@auc,
                        cor = bifbyluppoly.eval@cor,
                        TSS = max(bifbyluppoly.eval@TPR - bifbyluppoly.eval@FPR),
                        tstar = which.max(bifbyluppoly.eval@TPR - bifbyluppoly.eval@FPR))
  
  lpolybb.eval = data.frame(run = i,
                        model = "lpolybb",
                        AUC = luppolybybif.eval@auc,
                        cor = luppolybybif.eval@cor,
                        TSS = max(luppolybybif.eval@TPR - luppolybybif.eval@FPR),
                        tstar = which.max(luppolybybif.eval@TPR - luppolybybif.eval@FPR))


  
  bifluppoly.evaldf = bind_rows(bifluppoly.evaldf, bblpoly.eval, lpolybb.eval)
  
  # Step 6: Save Variable Importance
  bblpoly.vars = data.frame(run = rep(i, 21),
                        model = rep("bblpoly", 21),
                        variable = names(bif.by.luppoly@results[7:27,]),
                        percent = bif.by.luppoly@results[7:27],
                        permutation = bif.by.luppoly@results[28:48])
    
  lpolybb.vars = data.frame(run = rep(i, 21),
                        model = rep("lpolybb", 21),
                        variable = names(luppoly.by.bif@results[7:27,]),
                        percent = luppoly.by.bif@results[7:27],
                        permutation = luppoly.by.bif@results[28:48])
  
  bifluppoly.varimpdf = bind_rows(bifluppoly.varimpdf, bblpoly.vars, lpolybb.vars)
}
```


<!-- And let's look at some variable importance. -->

<!-- ```{r biflup variable importance} -->
<!-- var.idm <- ggplot(biflup.varimpdf %>% filter(model == "IDM"), aes(x = variable, y = percent)) + -->
<!--   geom_boxplot() + -->
<!--   theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) -->
<!-- var.idm -->
<!-- # 8, 14, 19, 6, 12 -->

<!-- var.bbl <- ggplot(biflup.varimpdf %>% filter(model == "bbl"), aes(x = variable, y = percent)) + -->
<!--   geom_boxplot() + -->
<!--   theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) -->
<!-- var.bbl -->
<!-- # 17, lupinus 12, 11 -->

<!-- var.lbb <- ggplot(biflup.varimpdf %>% filter(model == "lbb"), aes(x = variable, y = percent)) + -->
<!--   geom_boxplot() + -->
<!--   theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) -->
<!-- var.lbb -->
<!-- # 19, bifarius, elevation, 18 -->
<!-- ``` -->

<!-- I don't really know what to do with these yet. I think I'll probably run some statistics to confirm that they're statistically different between methods and then plot them out. -->

## Penstemon

```{r bif pen data, message = F}
gbif.pen <- gbif %>%
  filter(genus == "Penstemon")

bifpen <- bbna %>% 
  filter(species == "bifarius",
         plant.host.genus == "Penstemon") %>%
  dplyr::select(latitude, longitude, plant.host.genus, date, month, day, year)
```

```{r bifpen maxent for loop, message = F}
bifpen.evaldf <- data.frame()

bifpen.varimpdf <- data.frame()

set.seed(122323)
for(i in 1:100){
  # Step 1: separate all data into training and testing datasets
  bg <- as.data.frame(spatSample(x = bioclim, size = 50000, method = "random", na.rm = T, xy = T)) %>%
    dplyr::select(x, y) %>%
    rename(longitude = x,
           latitude = y)
  bgfold <- kfold(bg, k = 5)
  bg.test <- bg[bgfold == 1,]
  bg.train <- bg[bgfold != 1,]
  
  bif.longlat <- bbna %>%
    filter(species == "bifarius",
           plant.host.genus != "Penstemon") %>%
    slice_sample(by = BBNA.code, n = 1) %>%
    dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  bif.fold <- kfold(bif.longlat, k = 5)
  bif.test <- bif.longlat[bif.fold == 1,]
  bif.train <- bif.longlat[bif.fold != 1,]
  
  pen.longlat <- gbif.pen %>%
  dplyr::select(decimalLongitude, decimalLatitude) %>%
  as.data.frame(.) %>%
  rename(longitude = decimalLongitude,
         latitude = decimalLatitude)
  pen.fold <- kfold(pen.longlat, k = 5)
  pen.test <- pen.longlat[pen.fold == 1,]
  pen.train <- pen.longlat[pen.fold != 1,]
  
  bifpen.longlat <- bifpen %>%
  dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  bifpen.fold <- kfold(bifpen.longlat, k = 5)
  bifpen.test <- bifpen.longlat[bifpen.fold == 1,]
  bifpen.train <- bifpen.longlat[bifpen.fold != 1,]

  
  
  # Step 2: Calculate overlaps
  ## Step 2a: Initial models based on just bioclim variables
  bif.maxent <- maxent(x = stack(bioclim),
                       p = bif.train, 
                       a = bg.train)
  bif.predict <- dismo::predict(bif.maxent,
                                stack(bioclim))
  
  pen.maxent <- maxent(x = stack(bioclim), 
                       p = pen.train, 
                       a = bg.train)
  pen.predict <- dismo::predict(pen.maxent,
                                stack(bioclim))
  
  ## Step 2b: Updated models including partner
  bif.by.pen <- maxent(x = stack(stack(bioclim), pen.predict),
                       p = bif.train,
                       a = bg.train)
  pen.by.bif <- maxent(x = stack(stack(bioclim), bif.predict),
                       p = pen.train,
                       a = bg.train)
  
  
  
  # Step 3: Calculate IDM
  bifpen.maxent <- maxent(x = stack(bioclim), 
                          p = bifpen.train, 
                          a = bg.train)
  
  
  
  # Step 4: Evaluate all both overlap models and IDM with the same interaction test data
  ## Step 4a: Use dismo::evaluate to get AUC and TSS scores
  bifbypen.eval <- dismo::evaluate(p = bifpen.test,
                                   a = bg.test,
                                   model = bif.by.pen,
                                   x = stack(stack(bioclim), pen.predict))
  penbybif.eval <- dismo::evaluate(p = bifpen.test,
                                   a = bg.test,
                                   model = pen.by.bif,
                                   x = stack(stack(bioclim), bif.predict))
  bifpen.eval <- dismo::evaluate(p = bifpen.test, 
                                 a = bg.test, 
                                 model = bifpen.maxent, 
                                 x = stack(bioclim))
  
  ## Step 4b: Use modEvA::Boyce to get Boyce Index
  bbpen.predict <- as(dismo::predict(bif.by.pen, stack(stack(bioclim), pen.predict)), "SpatRaster")
  bbpen.boyce <- modEvA::Boyce(obs = bifpen.test, pred = bbpen.predict)
  
  penbb.predict <- as(dismo::predict(pen.by.bif, stack(stack(bioclim), bif.predict)), "SpatRaster")
  penbb.boyce <- modEvA::Boyce(obs = bifpen.test, pred = penbb.predict)
  
  bifpen.predict <- as(dismo::predict(bifpen.maxent, stack(bioclim)), "SpatRaster")
  bifpen.boyce <- modEvA::Boyce(obs = bifpen.test, pred = bifpen.predict)
  
  # Step 5: Save Evaluation Scores
  bbp.eval = data.frame(run = i,
                        model = "bbp",
                        AUC = bifbypen.eval@auc,
                        cor = bifbypen.eval@cor,
                        TSS = max(bifbypen.eval@TPR - bifbypen.eval@FPR),
                        tstar = which.max(bifbypen.eval@TPR - bifbypen.eval@FPR),
                        boyce = bbpen.boyce$Boyce)
  
  pbb.eval = data.frame(run = i,
                        model = "pbb",
                        AUC = penbybif.eval@auc,
                        cor = penbybif.eval@cor,
                        TSS = max(penbybif.eval@TPR - penbybif.eval@FPR),
                        tstar = which.max(penbybif.eval@TPR - penbybif.eval@FPR),
                        boyce = penbb.boyce$Boyce)

  idm.eval = data.frame(run = i,
                        model = "IDM",
                        AUC = bifpen.eval@auc,
                        cor = bifpen.eval@cor,
                        TSS = max(bifpen.eval@TPR - bifpen.eval@FPR),
                        tstar = which.max(bifpen.eval@TPR - bifpen.eval@FPR),
                        boyce = bifpen.boyce$Boyce)
  
  bifpen.evaldf = bind_rows(bifpen.evaldf, bbp.eval, pbb.eval, idm.eval)
  
  # Step 6: Save Variable Importance
  bbp.vars = data.frame(run = rep(i, 21),
                        model = rep("bbp", 21),
                        variable = names(bif.by.pen@results[7:27,]),
                        percent = bif.by.pen@results[7:27],
                        permutation = bif.by.pen@results[28:48])
    
  pbb.vars = data.frame(run = rep(i, 21),
                        model = rep("pbb", 21),
                        variable = names(pen.by.bif@results[7:27,]),
                        percent = pen.by.bif@results[7:27],
                        permutation = pen.by.bif@results[28:48])
  
  idm.vars = data.frame(run = rep(i, 20),
                        model = rep("IDM", 20),
                        variable = names(bifpen.maxent@results[7:26,]),
                        percent = bifpen.maxent@results[7:26],
                        permutation = bifpen.maxent@results[27:46])
  
  bifpen.varimpdf = bind_rows(bifpen.varimpdf, bbp.vars, pbb.vars, idm.vars)
}

#write.csv(bifpen.evaldf, file = "completed-evals/bifpen-eval.csv")
#write.csv(bifpen.varimpdf, file = "completed-evals/bifpen-varimport.csv")
```

# Flavifrons
## Chamaenerion
```{r flav cham data, message = F}
gbif.cham <- gbif %>%
  filter(genus == "Chamaenerion")

flavcham <- bbna %>%
  filter(species == "flavifrons",
         plant.host.genus == "Chamaenerion") %>%
  dplyr::select(latitude, longitude, plant.host.genus, date, month, day, year)
```

```{r flavcham maxent for loop, message = F}
flavcham.evaldf <- data.frame()

flavcham.varimpdf <- data.frame()

set.seed(15124)
for(i in 1:100){
  # Step 1: separate all data into training and testing datasets
  bg <- as.data.frame(spatSample(x = bioclim, size = 50000, method = "random", na.rm = T, xy = T)) %>%
    dplyr::select(x, y) %>%
    rename(longitude = x,
           latitude = y)
  bgfold <- kfold(bg, k = 5)
  bg.test <- bg[bgfold == 1,]
  bg.train <- bg[bgfold != 1,]
  
  flav.longlat <- bbna %>%
    filter(species == "flavifrons",
           plant.host.genus != "Chamaenerion") %>%
    slice_sample(by = BBNA.code, n = 1) %>%
    dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  flav.fold <- kfold(flav.longlat, k = 5)
  flav.test <- flav.longlat[flav.fold == 1,]
  flav.train <- flav.longlat[flav.fold != 1,]
  
  cham.longlat <- gbif.cham %>%
  dplyr::select(decimalLongitude, decimalLatitude) %>%
  as.data.frame(.) %>%
  rename(longitude = decimalLongitude,
         latitude = decimalLatitude)
  cham.fold <- kfold(cham.longlat, k = 5)
  cham.test <- cham.longlat[cham.fold == 1,]
  cham.train <- cham.longlat[cham.fold != 1,]
  
  flavcham.longlat <- bifcham %>%
  dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  flavcham.fold <- kfold(flavcham.longlat, k = 5)
  flavcham.test <- flavcham.longlat[flavcham.fold == 1,]
  flavcham.train <- flavcham.longlat[flavcham.fold != 1,]
  
  
  
  # Step 2: Calculate overlaps
  ## Step 2a: Initial models based on just bioclim variables
  flav.maxent <- maxent(x = stack(bioclim),
                       p = flav.train, 
                       a = bg.train)
  flav.predict <- dismo::predict(flav.maxent,
                                stack(bioclim))
  
  cham.maxent <- maxent(x = stack(bioclim), 
                       p = cham.train, 
                       a = bg.train)
  cham.predict <- dismo::predict(cham.maxent,
                                stack(bioclim))
  
  ## Step 2b: Updated models including partner
  flav.by.cham <- maxent(x = stack(stack(bioclim), cham.predict),
                       p = flav.train,
                       a = bg.train)
  cham.by.flav <- maxent(x = stack(stack(bioclim), flav.predict),
                       p = cham.train,
                       a = bg.train)
  
  
  
  # Step 3: Calculate IDM
  flavcham.maxent <- maxent(x = stack(bioclim), 
                          p = flavcham.train, 
                          a = bg.train)
  
  
  
  # Step 4: Evaluate all both overlap models and IDM with the same interaction test data
  ## Step 4a: Use dismo::evaluate to get AUC and TSS scores.
  flavbycham.eval <- dismo::evaluate(p = flavcham.test,
                                   a = bg.test,
                                   model = flav.by.cham,
                                   x = stack(stack(bioclim), cham.predict))
  chambyflav.eval <- dismo::evaluate(p = flavcham.test,
                                   a = bg.test,
                                   model = cham.by.flav,
                                   x = stack(stack(bioclim), bif.predict))
  flavcham.eval <- dismo::evaluate(p = flavcham.test, 
                                 a = bg.test, 
                                 model = flavcham.maxent, 
                                 x = stack(bioclim))
  
  ## Step 4b: Use modEvA::Boyce to get Boyce Index
  fbcham.predict <- as(dismo::predict(flav.by.cham, stack(stack(bioclim), cham.predict)), "SpatRaster")
  fbcham.boyce <- modEvA::Boyce(obs = flavcham.test, pred = fbcham.predict)
  
  chambf.predict <- as(dismo::predict(cham.by.flav, stack(stack(bioclim), flav.predict)), "SpatRaster")
  chambf.boyce <- modEvA::Boyce(obs = flavcham.test, pred = chambf.predict)
  
  flavcham.predict <- as(dismo::predict(flavcham.maxent, stack(bioclim)), "SpatRaster")
  flavcham.boyce <- modEvA::Boyce(obs = flavcham.test, pred = flavcham.predict)
  
  
  
  # Step 5: Save Evaluation Scores
  fbcham.eval = data.frame(run = i,
                        model = "fbcham",
                        AUC = flavbycham.eval@auc,
                        cor = flavbycham.eval@cor,
                        TSS = max(flavbycham.eval@TPR - flavbycham.eval@FPR),
                        tstar = which.max(flavbycham.eval@TPR - flavbycham.eval@FPR),
                        boyce = fbcham.boyce$Boyce)
  
  chambf.eval = data.frame(run = i,
                        model = "chambf",
                        AUC = chambyflav.eval@auc,
                        cor = chambyflav.eval@cor,
                        TSS = max(chambyflav.eval@TPR - chambyflav.eval@FPR),
                        tstar = which.max(chambyflav.eval@TPR - chambyflav.eval@FPR),
                        boyce = chambf.boyce$Boyce)

  idm.eval = data.frame(run = i,
                        model = "IDM",
                        AUC = flavcham.eval@auc,
                        cor = flavcham.eval@cor,
                        TSS = max(flavcham.eval@TPR - flavcham.eval@FPR),
                        tstar = which.max(flavcham.eval@TPR - flavcham.eval@FPR),
                        boyce = flavcham.boyce$Boyce)
  
  flavcham.evaldf = bind_rows(flavcham.evaldf, fbcham.eval, chambf.eval, idm.eval)
  
  
  
  # Step 6: Save Variable Importance
  fbcham.vars = data.frame(run = rep(i, 21),
                        model = rep("fbcham", 21),
                        variable = names(flav.by.cham@results[7:27,]),
                        percent = flav.by.cham@results[7:27],
                        permutation = flav.by.cham@results[28:48])
    
  chambf.vars = data.frame(run = rep(i, 21),
                        model = rep("chambf", 21),
                        variable = names(cham.by.flav@results[7:27,]),
                        percent = cham.by.flav@results[7:27],
                        permutation = cham.by.flav@results[28:48])
  
  idm.vars = data.frame(run = rep(i, 20),
                        model = rep("IDM", 20),
                        variable = names(flavcham.maxent@results[7:26,]),
                        percent = flavcham.maxent@results[7:26],
                        permutation = flavcham.maxent@results[27:46])
  
  flavcham.varimpdf = bind_rows(flavcham.varimpdf, fbcham.vars, chambf.vars, idm.vars)
}

#write.csv(flavcham.evaldf, file = "completed-evals/flavcham-eval.csv")
#write.csv(flavcham.varimpdf, file = "completed-evals/flavcham-varimport.csv")
```

## Cirsium
```{r flav cir data, message = F}
gbif.cir <- gbif %>%
  filter(genus == "Cirsium")

flavcir <- bbna %>%
  filter(species == "flavifrons",
         plant.host.genus == "Cirsium") %>%
  dplyr::select(latitude, longitude, plant.host.genus, date, month, day, year)
```

```{r flavcir maxent for loop, message = F}
flavcir.evaldf <- data.frame()

flavcir.varimpdf <- data.frame()

set.seed(163190)
for(i in 1:100){
  # Step 1: separate all data into training and testing datasets
  bg <- as.data.frame(spatSample(x = bioclim, size = 50000, method = "random", na.rm = T, xy = T)) %>%
    dplyr::select(x, y) %>%
    rename(longitude = x,
           latitude = y)
  bgfold <- kfold(bg, k = 5)
  bg.test <- bg[bgfold == 1,]
  bg.train <- bg[bgfold != 1,]
  
  flav.longlat <- bbna %>%
    filter(species == "flavifrons",
           plant.host.genus != "Cirsium") %>%
    slice_sample(by = BBNA.code, n = 1) %>%
    dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  flav.fold <- kfold(flav.longlat, k = 5)
  flav.test <- flav.longlat[flav.fold == 1,]
  flav.train <- flav.longlat[flav.fold != 1,]
  
  cir.longlat <- gbif.cir %>%
  dplyr::select(decimalLongitude, decimalLatitude) %>%
  as.data.frame(.) %>%
  rename(longitude = decimalLongitude,
         latitude = decimalLatitude)
  cir.fold <- kfold(cir.longlat, k = 5)
  cir.test <- cir.longlat[cir.fold == 1,]
  cir.train <- cir.longlat[cir.fold != 1,]
  
  flavcir.longlat <- flavcir %>%
  dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  flavcir.fold <- kfold(flavcir.longlat, k = 5)
  flavcir.test <- flavcir.longlat[flavcir.fold == 1,]
  flavcir.train <- flavcir.longlat[flavcir.fold != 1,]
  
  
  
  # Step 2: Calculate overlaps
  ## Step 2a: Initial models based on just bioclim variables
  flav.maxent <- maxent(x = stack(bioclim),
                       p = flav.train, 
                       a = bg.train)
  flav.predict <- dismo::predict(flav.maxent,
                                stack(bioclim))
  
  cir.maxent <- maxent(x = stack(bioclim), 
                       p = cir.train, 
                       a = bg.train)
  cir.predict <- dismo::predict(cir.maxent,
                                stack(bioclim))
  
  ## Step 2b: Updated models including partner
  flav.by.cir <- maxent(x = stack(stack(bioclim), cir.predict),
                       p = flav.train,
                       a = bg.train)
  cir.by.flav <- maxent(x = stack(stack(bioclim), flav.predict),
                       p = cir.train,
                       a = bg.train)
  
  
  
  # Step 3: Calculate IDM
  flavcir.maxent <- maxent(x = stack(bioclim), 
                          p = flavcir.train, 
                          a = bg.train)
  
  
  
  # Step 4: Evaluate all both overlap models and IDM with the same interaction test data
  ## Step 4a: Use dismo::evaluate to get AUC and TSS scores
  flavbycir.eval <- dismo::evaluate(p = flavcir.test,
                                   a = bg.test,
                                   model = flav.by.cir,
                                   x = stack(stack(bioclim), cir.predict))
  cirbyflav.eval <- dismo::evaluate(p = flavcir.test,
                                   a = bg.test,
                                   model = cir.by.flav,
                                   x = stack(stack(bioclim), flav.predict))
  flavcir.eval <- dismo::evaluate(p = flavcir.test, 
                                 a = bg.test, 
                                 model = flavcir.maxent, 
                                 x = stack(bioclim))
  
  ## Step 4b: Use modEvA::Boyce to get Boyce Index
  fbcir.predict <- as(dismo::predict(flav.by.cir, stack(stack(bioclim), cir.predict)), "SpatRaster")
  fbcir.boyce <- modEvA::Boyce(obs = flavcir.test, pred = fbcir.predict)
  
  cirbf.predict <- as(dismo::predict(cir.by.flav, stack(stack(bioclim), flav.predict)), "SpatRaster")
  cirbf.boyce <- modEvA::Boyce(obs = flavcir.test, pred = cirbf.predict)
  
  flavcir.predict <- as(dismo::predict(flavcir.maxent, stack(bioclim)), "SpatRaster")
  flavcir.boyce <- modEvA::Boyce(obs = flavcir.test, pred = flavcir.predict)
  
  
  
  
  # Step 5: Save Evaluation Scores
  fbcir.eval = data.frame(run = i,
                        model = "fbcir",
                        AUC = flavbycir.eval@auc,
                        cor = flavbycir.eval@cor,
                        TSS = max(flavbycir.eval@TPR - flavbycir.eval@FPR),
                        tstar = which.max(flavbycir.eval@TPR - flavbycir.eval@FPR),
                        boyce = fbcir.boyce$Boyce)
  
  cirbf.eval = data.frame(run = i,
                        model = "cirbf",
                        AUC = cirbyflav.eval@auc,
                        cor = cirbyflav.eval@cor,
                        TSS = max(cirbyflav.eval@TPR - cirbyflav.eval@FPR),
                        tstar = which.max(cirbyflav.eval@TPR - cirbyflav.eval@FPR),
                        boyce = cirbf.boyce$Boyce)

  idm.eval = data.frame(run = i,
                        model = "IDM",
                        AUC = flavcir.eval@auc,
                        cor = flavcir.eval@cor,
                        TSS = max(flavcir.eval@TPR - flavcir.eval@FPR),
                        tstar = which.max(flavcir.eval@TPR - flavcir.eval@FPR),
                        boyce = flavcir.boyce$Boyce)
  
  flavcir.evaldf = bind_rows(flavcir.evaldf, fbcir.eval, cirbf.eval, idm.eval)
  
  
  
  
  # Step 6: Save Variable Importance
  fbcir.vars = data.frame(run = rep(i, 21),
                        model = rep("fbcir", 21),
                        variable = names(flav.by.cir@results[7:27,]),
                        percent = flav.by.cir@results[7:27],
                        permutation = flav.by.cir@results[28:48])
    
  cirbf.vars = data.frame(run = rep(i, 21),
                        model = rep("cirbf", 21),
                        variable = names(cir.by.flav@results[7:27,]),
                        percent = cir.by.flav@results[7:27],
                        permutation = cir.by.flav@results[28:48])
  
  idm.vars = data.frame(run = rep(i, 20),
                        model = rep("IDM", 20),
                        variable = names(flavcir.maxent@results[7:26,]),
                        percent = flavcir.maxent@results[7:26],
                        permutation = flavcir.maxent@results[27:46])
  
  flavcir.varimpdf = bind_rows(flavcir.varimpdf, fbcir.vars, cirbf.vars, idm.vars)
}

#write.csv(flavcir.evaldf, file = "completed-evals/flavcir-eval.csv")
#write.csv(flavcir.varimpdf, file = "completed-evals/flavcir-varimport.csv")
```


## Lupinus

```{r flav lup data, message = F}
gbif.lup <- gbif %>%
  filter(genus == "Lupinus")

flavlup <- bbna %>% 
  filter(species == "flavifrons",
         plant.host.genus == "Lupinus") %>%
  dplyr::select(latitude, longitude, plant.host.genus, date, month, day, year)
```

```{r flavlup maxent for loop, message = F}
flavlup.evaldf <- data.frame()

flavlup.varimpdf <- data.frame()

set.seed(11624)
for(i in 1:100){
  # Step 1: separate all data into training and testing datasets
  bg <- as.data.frame(spatSample(x = bioclim, size = 50000, method = "random", na.rm = T, xy = T)) %>%
    dplyr::select(x, y) %>%
    rename(longitude = x,
           latitude = y)
  bgfold <- kfold(bg, k = 5)
  bg.test <- bg[bgfold == 1,]
  bg.train <- bg[bgfold != 1,]
  
  flav.longlat <- bbna %>%
    filter(species == "flavifrons",
           plant.host.genus != "Lupinus") %>%
    slice_sample(by = BBNA.code, n = 1) %>%
    dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  flav.fold <- kfold(flav.longlat, k = 5)
  flav.test <- flav.longlat[flav.fold == 1,]
  flav.train <- flav.longlat[flav.fold != 1,]
  
  lup.longlat <- gbif.lup %>%
  dplyr::select(decimalLongitude, decimalLatitude) %>%
  as.data.frame(.) %>%
  rename(longitude = decimalLongitude,
         latitude = decimalLatitude)
  lup.fold <- kfold(lup.longlat, k = 5)
  lup.test <- lup.longlat[lup.fold == 1,]
  lup.train <- lup.longlat[lup.fold != 1,]
  
  flavlup.longlat <- flavlup %>%
  dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  flavlup.fold <- kfold(flavlup.longlat, k = 5)
  flavlup.test <- flavlup.longlat[flavlup.fold == 1,]
  flavlup.train <- flavlup.longlat[flavlup.fold != 1,]

  
  
  # Step 2: Calculate overlaps
  ## Step 2a: Initial models based on just bioclim variables
  flav.maxent <- maxent(x = stack(bioclim),
                       p = flav.train, 
                       a = bg.train)
  flav.predict <- dismo::predict(flav.maxent,
                                stack(bioclim))
  
  lup.maxent <- maxent(x = stack(bioclim), 
                       p = lup.train, 
                       a = bg.train)
  lup.predict <- dismo::predict(lup.maxent,
                                stack(bioclim))
  
  ## Step 2b: Updated models including partner
  flav.by.lup <- maxent(x = stack(stack(bioclim), lup.predict),
                       p = flav.train,
                       a = bg.train)
  lup.by.flav <- maxent(x = stack(stack(bioclim), flav.predict),
                       p = lup.train,
                       a = bg.train)
  
  
  
  # Step 3: Calculate IDM
  flavlup.maxent <- maxent(x = stack(bioclim), 
                          p = flavlup.train, 
                          a = bg.train)
  
  
  
  # Step 4: Evaluate all both overlap models and IDM with the same interaction test data
  ## Step 4a: Use dismo::evaluate to get AUC and TSS scores
  flavbylup.eval <- dismo::evaluate(p = flavlup.test,
                                   a = bg.test,
                                   model = flav.by.lup,
                                   x = stack(stack(bioclim), lup.predict))
  lupbyflav.eval <- dismo::evaluate(p = flavlup.test,
                                   a = bg.test,
                                   model = lup.by.flav,
                                   x = stack(stack(bioclim), flav.predict))
  flavlup.eval <- dismo::evaluate(p = flavlup.test, 
                                 a = bg.test, 
                                 model = flavlup.maxent, 
                                 x = stack(bioclim))
  
  ## Step 4b: Use modEvA::Boyce to get Boyce Index
  fblup.predict <- as(dismo::predict(flav.by.lup, stack(stack(bioclim), lup.predict)), "SpatRaster")
  fblup.boyce <- modEvA::Boyce(obs = flavlup.test, pred = fblup.predict)
  
  lupbf.predict <- as(dismo::predict(lup.by.flav, stack(stack(bioclim), flav.predict)), "SpatRaster")
  lupbf.boyce <- modEvA::Boyce(obs = flavlup.test, pred = lupbf.predict)
  
  flavlup.predict <- as(dismo::predict(flavcham.maxent, stack(bioclim)), "SpatRaster")
  flavlup.boyce <- modEvA::Boyce(obs = flavlup.test, pred = flavlup.predict)
  
  
  
  
  # Step 5: Save Evaluation Scores
  fbl.eval = data.frame(run = i,
                        model = "fbl",
                        AUC = flavbylup.eval@auc,
                        cor = flavbylup.eval@cor,
                        TSS = max(flavbylup.eval@TPR - flavbylup.eval@FPR),
                        tstar = which.max(flavbylup.eval@TPR - flavbylup.eval@FPR),
                        boyce = fblup.boyce$Boyce)
  
  lbf.eval = data.frame(run = i,
                        model = "lbf",
                        AUC = lupbyflav.eval@auc,
                        cor = lupbyflav.eval@cor,
                        TSS = max(lupbyflav.eval@TPR - lupbyflav.eval@FPR),
                        tstar = which.max(lupbyflav.eval@TPR - lupbyflav.eval@FPR),
                        boyce = lupbf.boyce$Boyce)

  idm.eval = data.frame(run = i,
                        model = "IDM",
                        AUC = flavlup.eval@auc,
                        cor = flavlup.eval@cor,
                        TSS = max(flavlup.eval@TPR - flavlup.eval@FPR),
                        tstar = which.max(flavlup.eval@TPR - flavlup.eval@FPR),
                        boyce = flavlup.boyce$Boyce)
  
  flavlup.evaldf = bind_rows(flavlup.evaldf, fbl.eval, lbf.eval, idm.eval)
  
  
  
  
  # Step 6: Save Variable Importance
  fbl.vars = data.frame(run = rep(i, 21),
                        model = rep("fbl", 21),
                        variable = names(flav.by.lup@results[7:27,]),
                        percent = flav.by.lup@results[7:27],
                        permutation = flav.by.lup@results[28:48])
    
  lbf.vars = data.frame(run = rep(i, 21),
                        model = rep("lbf", 21),
                        variable = names(lup.by.flav@results[7:27,]),
                        percent = lup.by.flav@results[7:27],
                        permutation = lup.by.flav@results[28:48])
  
  idm.vars = data.frame(run = rep(i, 20),
                        model = rep("IDM", 20),
                        variable = names(flavlup.maxent@results[7:26,]),
                        percent = flavlup.maxent@results[7:26],
                        permutation = flavlup.maxent@results[27:46])
  
  flavlup.varimpdf = bind_rows(flavlup.varimpdf, fbl.vars, lbf.vars, idm.vars)
}

#write.csv(flavlup.evaldf, file = "completed-evals/flavlup-eval.csv")
#write.csv(flavlup.varimpdf, file = "completed-evals/flavlup-varimport.csv")
```

## Penstemon
```{r flav pen data, message = F}
gbif.pen <- gbif %>%
  filter(genus == "Penstemon")

flavpen <- bbna %>% 
  filter(species == "flavifrons",
         plant.host.genus == "Penstemon") %>%
  dplyr::select(latitude, longitude, plant.host.genus, date, month, day, year)
```

```{r flavpen maxent for loop, message = F}
flavpen.evaldf <- data.frame()

flavpen.varimpdf <- data.frame()

set.seed(11124)
for(i in 1:100){
  # Step 1: separate all data into training and testing datasets
  bg <- as.data.frame(spatSample(x = bioclim, size = 50000, method = "random", na.rm = T, xy = T)) %>%
    dplyr::select(x, y) %>%
    rename(longitude = x,
           latitude = y)
  bgfold <- kfold(bg, k = 5)
  bg.test <- bg[bgfold == 1,]
  bg.train <- bg[bgfold != 1,]
  
  flav.longlat <- bbna %>%
    filter(species == "flavifrons",
           plant.host.genus != "Penstemon") %>%
    slice_sample(by = BBNA.code, n = 1) %>%
    dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  flav.fold <- kfold(flav.longlat, k = 5)
  flav.test <- flav.longlat[flav.fold == 1,]
  flav.train <- flav.longlat[flav.fold != 1,]
  
  pen.longlat <- gbif.pen %>%
  dplyr::select(decimalLongitude, decimalLatitude) %>%
  as.data.frame(.) %>%
  rename(longitude = decimalLongitude,
         latitude = decimalLatitude)
  pen.fold <- kfold(pen.longlat, k = 5)
  pen.test <- pen.longlat[pen.fold == 1,]
  pen.train <- pen.longlat[pen.fold != 1,]
  
  flavpen.longlat <- flavpen %>%
  dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  flavpen.fold <- kfold(flavpen.longlat, k = 5)
  flavpen.test <- flavpen.longlat[flavpen.fold == 1,]
  flavpen.train <- flavpen.longlat[flavpen.fold != 1,]

  
  
  # Step 2: Calculate overlaps
  ## Step 2a: Initial models based on just bioclim variables
  flav.maxent <- maxent(x = stack(bioclim),
                       p = flav.train, 
                       a = bg.train)
  flav.predict <- dismo::predict(flav.maxent,
                                stack(bioclim))
  
  pen.maxent <- maxent(x = stack(bioclim), 
                       p = pen.train, 
                       a = bg.train)
  pen.predict <- dismo::predict(pen.maxent,
                                stack(bioclim))
  
  ## Step 2b: Updated models including partner
  flav.by.pen <- maxent(x = stack(stack(bioclim), pen.predict),
                       p = flav.train,
                       a = bg.train)
  pen.by.flav <- maxent(x = stack(stack(bioclim), flav.predict),
                       p = pen.train,
                       a = bg.train)
  
  
  
  # Step 3: Calculate IDM
  flavpen.maxent <- maxent(x = stack(bioclim), 
                          p = flavpen.train, 
                          a = bg.train)
  
  
  
  # Step 4: Evaluate all both overlap models and IDM with the same interaction test data
  ## Step 4a: Use dismo::evaluate to get AUC and TSS scores
  flavbypen.eval <- dismo::evaluate(p = flavpen.test,
                                   a = bg.test,
                                   model = flav.by.pen,
                                   x = stack(stack(bioclim), pen.predict))
  penbyflav.eval <- dismo::evaluate(p = flavpen.test,
                                   a = bg.test,
                                   model = pen.by.flav,
                                   x = stack(stack(bioclim), flav.predict))
  flavpen.eval <- dismo::evaluate(p = flavpen.test, 
                                 a = bg.test, 
                                 model = flavpen.maxent, 
                                 x = stack(bioclim))
  
  ## Step 4b: Use modEvA::Boyce to get Boyce Index
  fbpen.predict <- as(dismo::predict(flav.by.pen, stack(stack(bioclim), pen.predict)), "SpatRaster")
  fbpen.boyce <- modEvA::Boyce(obs = flavpen.test, pred = fbpen.predict)
  
  penbf.predict <- as(dismo::predict(pen.by.flav, stack(stack(bioclim), flav.predict)), "SpatRaster")
  penbf.boyce <- modEvA::Boyce(obs = flavpen.test, pred = penbf.predict)
  
  flavpen.predict <- as(dismo::predict(flavpen.maxent, stack(bioclim)), "SpatRaster")
  flavpen.boyce <- modEvA::Boyce(obs = flavpen.test, pred = flavpen.predict)
  
  
  
  
  # Step 5: Save Evaluation Scores
 fbp.eval = data.frame(run = i,
                        model = "fbp",
                        AUC = flavbypen.eval@auc,
                        cor = flavbypen.eval@cor,
                        TSS = max(flavbypen.eval@TPR - flavbypen.eval@FPR),
                        tstar = which.max(flavbypen.eval@TPR - flavbypen.eval@FPR),
                        boyce = fbpen.boyce$Boyce)
  
  pbf.eval = data.frame(run = i,
                        model = "pbf",
                        AUC = penbyflav.eval@auc,
                        cor = penbyflav.eval@cor,
                        TSS = max(penbyflav.eval@TPR - penbyflav.eval@FPR),
                        tstar = which.max(penbyflav.eval@TPR - penbyflav.eval@FPR),
                        boyce = penbf.boyce$Boyce)

  idm.eval = data.frame(run = i,
                        model = "IDM",
                        AUC = flavpen.eval@auc,
                        cor = flavpen.eval@cor,
                        TSS = max(flavpen.eval@TPR - flavpen.eval@FPR),
                        tstar = which.max(flavpen.eval@TPR - flavpen.eval@FPR),
                        boyce = flavpen.boyce$Boyce)
  
  flavpen.evaldf = bind_rows(flavpen.evaldf, fbp.eval, pbf.eval, idm.eval)
  
  
  
  
  # Step 6: Save Variable Importance
  fbp.vars = data.frame(run = rep(i, 21),
                        model = rep("fbp", 21),
                        variable = names(flav.by.pen@results[7:27,]),
                        percent = flav.by.pen@results[7:27],
                        permutation = flav.by.pen@results[28:48])
    
  pbf.vars = data.frame(run = rep(i, 21),
                        model = rep("pbf", 21),
                        variable = names(pen.by.flav@results[7:27,]),
                        percent = pen.by.flav@results[7:27],
                        permutation = pen.by.flav@results[28:48])
  
  idm.vars = data.frame(run = rep(i, 20),
                        model = rep("IDM", 20),
                        variable = names(flavpen.maxent@results[7:26,]),
                        percent = flavpen.maxent@results[7:26],
                        permutation = flavpen.maxent@results[27:46])
  
  flavpen.varimpdf = bind_rows(flavpen.varimpdf, fbp.vars, pbf.vars, idm.vars)
}

#write.csv(flavpen.evaldf, file = "completed-evals/flavpen-eval.csv")
#write.csv(flavpen.varimpdf, file = "completed-evals/flavpen-varimport.csv")
```


## Rubus
```{r flav rub data, message = F}
gbif.rub <- gbif %>%
  filter(genus == "Rubus")

flavrub <- bbna %>%
  filter(species == "flavifrons",
         plant.host.genus == "Rubus") %>%
  dplyr::select(latitude, longitude, plant.host.genus, date, month, day, year)
```

```{r flavrub maxent for loop, message = F}
flavrub.evaldf <- data.frame()

flavrub.varimpdf <- data.frame()

set.seed(160124)
for(i in 1:100){
  # Step 1: separate all data into training and testing datasets
  bg <- as.data.frame(spatSample(x = bioclim, size = 50000, method = "random", na.rm = T, xy = T)) %>%
    dplyr::select(x, y) %>%
    rename(longitude = x,
           latitude = y)
  bgfold <- kfold(bg, k = 5)
  bg.test <- bg[bgfold == 1,]
  bg.train <- bg[bgfold != 1,]
  
  flav.longlat <- bbna %>%
    filter(species == "flavifrons",
           plant.host.genus != "Rubus") %>%
    slice_sample(by = BBNA.code, n = 1) %>%
    dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  flav.fold <- kfold(flav.longlat, k = 5)
  flav.test <- flav.longlat[flav.fold == 1,]
  flav.train <- flav.longlat[flav.fold != 1,]
  
  rub.longlat <- gbif.rub %>%
  dplyr::select(decimalLongitude, decimalLatitude) %>%
  as.data.frame(.) %>%
  rename(longitude = decimalLongitude,
         latitude = decimalLatitude)
  rub.fold <- kfold(rub.longlat, k = 5)
  rub.test <- rub.longlat[rub.fold == 1,]
  rub.train <- rub.longlat[rub.fold != 1,]
  
  flavrub.longlat <- flavrub %>%
  dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  flavrub.fold <- kfold(flavrub.longlat, k = 5)
  flavrub.test <- flavrub.longlat[flavrub.fold == 1,]
  flavrub.train <- flavrub.longlat[flavrub.fold != 1,]
  
  
  
  # Step 2: Calculate overlaps
  ## Step 2a: Initial models based on just bioclim variables
  flav.maxent <- maxent(x = stack(bioclim),
                       p = flav.train, 
                       a = bg.train)
  flav.predict <- dismo::predict(flav.maxent,
                                stack(bioclim))
  
  rub.maxent <- maxent(x = stack(bioclim), 
                       p = rub.train, 
                       a = bg.train)
  rub.predict <- dismo::predict(rub.maxent,
                                stack(bioclim))
  
  ## Step 2b: Updated models including partner
  flav.by.rub <- maxent(x = stack(stack(bioclim), rub.predict),
                       p = flav.train,
                       a = bg.train)
  rub.by.flav <- maxent(x = stack(stack(bioclim), flav.predict),
                       p = rub.train,
                       a = bg.train)
  
  
  
  # Step 3: Calculate IDM
  flavrub.maxent <- maxent(x = stack(bioclim), 
                          p = flavrub.train, 
                          a = bg.train)
  
  
  
  # Step 4: Evaluate all both overlap models and IDM with the same interaction test data
  ## Step 4a: Use dismo::evaluate to get AUC and TSS scores
  flavbyrub.eval <- dismo::evaluate(p = flavrub.test,
                                   a = bg.test,
                                   model = flav.by.rub,
                                   x = stack(stack(bioclim), rub.predict))
  rubbyflav.eval <- dismo::evaluate(p = flavrub.test,
                                   a = bg.test,
                                   model = rub.by.flav,
                                   x = stack(stack(bioclim), flav.predict))
  flavrub.eval <- dismo::evaluate(p = flavrub.test, 
                                 a = bg.test, 
                                 model = flavrub.maxent, 
                                 x = stack(bioclim))
  
  ## Step 4b: Use modEvA::Boyce to get Boyce Index
  fbrub.predict <- as(dismo::predict(flav.by.rub, stack(stack(bioclim), rub.predict)), "SpatRaster")
  fbrub.boyce <- modEvA::Boyce(obs = flavrub.test, pred = fbrub.predict)
  
  rubbf.predict <- as(dismo::predict(rub.by.flav, stack(stack(bioclim), flav.predict)), "SpatRaster")
  rubbf.boyce <- modEvA::Boyce(obs = flavrub.test, pred = rubbf.predict)
  
  flavrub.predict <- as(dismo::predict(flavrub.maxent, stack(bioclim)), "SpatRaster")
  flavrub.boyce <- modEvA::Boyce(obs = flavrub.test, pred = flavrub.predict)
  
  
  
  
  
  # Step 5: Save Evaluation Scores
  fbrub.eval = data.frame(run = i,
                        model = "fbrub",
                        AUC = flavbyrub.eval@auc,
                        cor = flavbyrub.eval@cor,
                        TSS = max(flavbyrub.eval@TPR - flavbyrub.eval@FPR),
                        tstar = which.max(flavbyrub.eval@TPR - flavbyrub.eval@FPR),
                        boyce = fbrub.boyce$Boyce)
  
  rubbf.eval = data.frame(run = i,
                        model = "rubbf",
                        AUC = rubbyflav.eval@auc,
                        cor = rubbyflav.eval@cor,
                        TSS = max(rubbyflav.eval@TPR - rubbyflav.eval@FPR),
                        tstar = which.max(rubbyflav.eval@TPR - rubbyflav.eval@FPR),
                        boyce = rubbf.boyce$Boyce)

  idm.eval = data.frame(run = i,
                        model = "IDM",
                        AUC = flavrub.eval@auc,
                        cor = flavrub.eval@cor,
                        TSS = max(flavrub.eval@TPR - flavrub.eval@FPR),
                        tstar = which.max(flavrub.eval@TPR - flavrub.eval@FPR),
                        boyce = flavrub.boyce$Boyce)
  
  flavrub.evaldf = bind_rows(flavrub.evaldf, fbrub.eval, rubbf.eval, idm.eval)
  
  
  
  
  # Step 6: Save Variable Importance
  fbrub.vars = data.frame(run = rep(i, 21),
                        model = rep("fbrub", 21),
                        variable = names(flav.by.rub@results[7:27,]),
                        percent = flav.by.rub@results[7:27],
                        permutation = flav.by.rub@results[28:48])
    
  rubbf.vars = data.frame(run = rep(i, 21),
                        model = rep("rubbf", 21),
                        variable = names(rub.by.flav@results[7:27,]),
                        percent = rub.by.flav@results[7:27],
                        permutation = rub.by.flav@results[28:48])
  
  idm.vars = data.frame(run = rep(i, 20),
                        model = rep("IDM", 20),
                        variable = names(flavrub.maxent@results[7:26,]),
                        percent = flavrub.maxent@results[7:26],
                        permutation = flavrub.maxent@results[27:46])
  
  flavrub.varimpdf = bind_rows(flavrub.varimpdf, fbrub.vars, rubbf.vars, idm.vars)
}

#write.csv(flavrub.evaldf, file = "completed-evals/flavrub-eval.csv")
#write.csv(flavrub.varimpdf, file = "completed-evals/flavrub-varimport.csv")
```



# Mixtus
## Chamaenerion

```{r mix cham data, message = F}
gbif.cham <- gbif %>%
  filter(genus == "Chamaenerion")

mixcham <- bbna %>%
  filter(species == "mixtus",
         plant.host.genus == "Chamaenerion") %>%
  dplyr::select(latitude, longitude, plant.host.genus, date, month, day, year)
```

```{r mixcham maxent for loop, message = F}
mixcham.evaldf <- data.frame()

mixcham.varimpdf <- data.frame()

set.seed(51445)
for(i in 1:100){
  # Step 1: separate all data into training and testing datasets
  bg <- as.data.frame(spatSample(x = bioclim, size = 50000, method = "random", na.rm = T, xy = T)) %>%
    dplyr::select(x, y) %>%
    rename(longitude = x,
           latitude = y)
  bgfold <- kfold(bg, k = 5)
  bg.test <- bg[bgfold == 1,]
  bg.train <- bg[bgfold != 1,]
  
  mix.longlat <- bbna %>%
    filter(species == "mixtus",
           plant.host.genus != "Chamaenerion") %>%
    slice_sample(by = BBNA.code, n = 1) %>%
    dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  mix.fold <- kfold(mix.longlat, k = 5)
  mix.test <- mix.longlat[mix.fold == 1,]
  mix.train <- mix.longlat[mix.fold != 1,]
  
  cham.longlat <- gbif.cham %>%
  dplyr::select(decimalLongitude, decimalLatitude) %>%
  as.data.frame(.) %>%
  rename(longitude = decimalLongitude,
         latitude = decimalLatitude)
  cham.fold <- kfold(cham.longlat, k = 5)
  cham.test <- cham.longlat[cham.fold == 1,]
  cham.train <- cham.longlat[cham.fold != 1,]
  
  mixcham.longlat <- mixcham %>%
  dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  mixcham.fold <- kfold(mixcham.longlat, k = 5)
  mixcham.test <- mixcham.longlat[mixcham.fold == 1,]
  mixcham.train <- mixcham.longlat[mixcham.fold != 1,]
  
  
  
  # Step 2: Calculate overlaps
  ## Step 2a: Initial models based on just bioclim variables
  mix.maxent <- maxent(x = stack(bioclim),
                       p = mix.train, 
                       a = bg.train)
  mix.predict <- dismo::predict(mix.maxent,
                                stack(bioclim))
  
  cham.maxent <- maxent(x = stack(bioclim), 
                       p = cham.train, 
                       a = bg.train)
  cham.predict <- dismo::predict(cham.maxent,
                                stack(bioclim))
  
  ## Step 2b: Updated models including partner
  mix.by.cham <- maxent(x = stack(stack(bioclim), cham.predict),
                       p = mix.train,
                       a = bg.train)
  cham.by.mix <- maxent(x = stack(stack(bioclim), mix.predict),
                       p = cham.train,
                       a = bg.train)
  
  
  
  # Step 3: Calculate IDM
  mixcham.maxent <- maxent(x = stack(bioclim), 
                          p = mixcham.train, 
                          a = bg.train)
  
  
  
  # Step 4: Evaluate all both overlap models and IDM with the same interaction test data
  ## Step 4a: Use dismo::evaluate to get AUC and TSS scores
  mixbycham.eval <- dismo::evaluate(p = mixcham.test,
                                   a = bg.test,
                                   model = mix.by.cham,
                                   x = stack(stack(bioclim), cham.predict))
  chambymix.eval <- dismo::evaluate(p = mixcham.test,
                                   a = bg.test,
                                   model = cham.by.mix,
                                   x = stack(stack(bioclim), mix.predict))
  mixcham.eval <- dismo::evaluate(p = mixcham.test, 
                                 a = bg.test, 
                                 model = mixcham.maxent, 
                                 x = stack(bioclim))
  
  ## Step 4b: Use modEvA::Boyce to get Boyce Index
  mbcham.predict <- as(dismo::predict(mix.by.cham, stack(stack(bioclim),cham.predict)), "SpatRaster")
  mbcham.boyce <- modEvA::Boyce(obs = mixcham.test, pred = mbcham.predict)
  
  chambm.predict <- as(dismo::predict(cham.by.mix, stack(stack(bioclim), mix.predict)), "SpatRaster")
  chambm.boyce <- modEvA::Boyce(obs = mixcham.test, pred = chambm.predict)
  
  mixcham.predict <- as(dismo::predict(mixcham.maxent, stack(bioclim)), "SpatRaster")
  mixcham.boyce <- modEvA::Boyce(obs = mixcham.test, pred = mixcham.predict)
  
  
  
  
  
  # Step 5: Save Evaluation Scores
  mbcham.eval = data.frame(run = i,
                        model = "mbcham",
                        AUC = mixbycham.eval@auc,
                        cor = mixbycham.eval@cor,
                        TSS = max(mixbycham.eval@TPR - mixbycham.eval@FPR),
                        tstar = which.max(mixbycham.eval@TPR - mixbycham.eval@FPR),
                        boyce = mbcham.boyce$Boyce)
  
  chambm.eval = data.frame(run = i,
                        model = "chambm",
                        AUC = chambymix.eval@auc,
                        cor = chambymix.eval@cor,
                        TSS = max(chambymix.eval@TPR - chambymix.eval@FPR),
                        tstar = which.max(chambymix.eval@TPR - chambymix.eval@FPR),
                        boyce = chambm.boyce$Boyce)

  idm.eval = data.frame(run = i,
                        model = "IDM",
                        AUC = mixcham.eval@auc,
                        cor = mixcham.eval@cor,
                        TSS = max(mixcham.eval@TPR - mixcham.eval@FPR),
                        tstar = which.max(mixcham.eval@TPR - mixcham.eval@FPR),
                        boyce = mixcham.boyce$Boyce)
  
  mixcham.evaldf = bind_rows(mixcham.evaldf, mbcham.eval, chambm.eval, idm.eval)
  
  
  
  
  # Step 6: Save Variable Importance
  mbcham.vars = data.frame(run = rep(i, 21),
                        model = rep("mbcham", 21),
                        variable = names(mix.by.cham@results[7:27,]),
                        percent = mix.by.cham@results[7:27],
                        permutation = mix.by.cham@results[28:48])
    
  chambm.vars = data.frame(run = rep(i, 21),
                        model = rep("chambm", 21),
                        variable = names(cham.by.mix@results[7:27,]),
                        percent = cham.by.mix@results[7:27],
                        permutation = cham.by.mix@results[28:48])
  
  idm.vars = data.frame(run = rep(i, 20),
                        model = rep("IDM", 20),
                        variable = names(mixcham.maxent@results[7:26,]),
                        percent = mixcham.maxent@results[7:26],
                        permutation = mixcham.maxent@results[27:46])
  
  mixcham.varimpdf = bind_rows(mixcham.varimpdf, mbcham.vars, chambm.vars, idm.vars)
}

# write.csv(mixcham.evaldf, file = "completed-evals/mixcham-eval.csv")
# write.csv(mixcham.varimpdf, file = "completed-evals/mixcham-varimport.csv")
```



## Lupinus

```{r mix lup data, message = F}
gbif.lup <- gbif %>%
  filter(genus == "Lupinus")

mixlup <- bbna %>%
  filter(species == "mixtus",
         plant.host.genus == "Lupinus") %>%
  dplyr::select(latitude, longitude, plant.host.genus, date, month, day, year)
```

```{r mixlup maxent for loop, message = F}
mixlup.evaldf <- data.frame()

mixlup.varimpdf <- data.frame()

set.seed(232024)
for(i in 1:100){
  # Step 1: separate all data into training and testing datasets
  bg <- as.data.frame(spatSample(x = bioclim, size = 50000, method = "random", na.rm = T, xy = T)) %>%
    dplyr::select(x, y) %>%
    rename(longitude = x,
           latitude = y)
  bgfold <- kfold(bg, k = 5)
  bg.test <- bg[bgfold == 1,]
  bg.train <- bg[bgfold != 1,]
  
  mix.longlat <- bbna %>%
    filter(species == "mixtus",
           plant.host.genus != "Lupinus") %>%
    slice_sample(by = BBNA.code, n = 1) %>%
    dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  mix.fold <- kfold(mix.longlat, k = 5)
  mix.test <- mix.longlat[mix.fold == 1,]
  mix.train <- mix.longlat[mix.fold != 1,]
  
  lup.longlat <- gbif.lup %>%
  dplyr::select(decimalLongitude, decimalLatitude) %>%
  as.data.frame(.) %>%
  rename(longitude = decimalLongitude,
         latitude = decimalLatitude)
  lup.fold <- kfold(lup.longlat, k = 5)
  lup.test <- lup.longlat[lup.fold == 1,]
  lup.train <- lup.longlat[lup.fold != 1,]
  
  mixlup.longlat <- mixlup %>%
  dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  mixlup.fold <- kfold(mixlup.longlat, k = 5)
  mixlup.test <- mixlup.longlat[mixlup.fold == 1,]
  mixlup.train <- mixlup.longlat[mixlup.fold != 1,]
  
  
  
  # Step 2: Calculate overlaps
  ## Step 2a: Initial models based on just bioclim variables
  mix.maxent <- maxent(x = stack(bioclim),
                       p = mix.train, 
                       a = bg.train)
  mix.predict <- dismo::predict(mix.maxent,
                                stack(bioclim))
  
  lup.maxent <- maxent(x = stack(bioclim), 
                       p = lup.train, 
                       a = bg.train)
  lup.predict <- dismo::predict(lup.maxent,
                                stack(bioclim))
  
  ## Step 2b: Updated models including partner
  mix.by.lup <- maxent(x = stack(stack(bioclim), lup.predict),
                       p = mix.train,
                       a = bg.train)
  lup.by.mix <- maxent(x = stack(stack(bioclim), mix.predict),
                       p = lup.train,
                       a = bg.train)
  
  
  
  # Step 3: Calculate IDM
  mixlup.maxent <- maxent(x = stack(bioclim), 
                          p = mixlup.train, 
                          a = bg.train)
  
  
  
  # Step 4: Evaluate all both overlap models and IDM with the same interaction test data
  ## Step 4a: Use dismo::evaluate to get AUC and TSS scores
  mixbylup.eval <- dismo::evaluate(p = mixlup.test,
                                   a = bg.test,
                                   model = mix.by.lup,
                                   x = stack(stack(bioclim), lup.predict))
  lupbymix.eval <- dismo::evaluate(p = mixlup.test,
                                   a = bg.test,
                                   model = lup.by.mix,
                                   x = stack(stack(bioclim), mix.predict))
  mixlup.eval <- dismo::evaluate(p = mixlup.test, 
                                 a = bg.test, 
                                 model = mixlup.maxent, 
                                 x = stack(bioclim))
  
  ## Step 4b: Use modEvA::Boyce to get Boyce Index
  mblup.predict <- as(dismo::predict(mix.by.lup, stack(stack(bioclim), lup.predict)), "SpatRaster")
  mblup.boyce <- modEvA::Boyce(obs = mixlup.test, pred = mblup.predict)
  
  lupbm.predict <- as(dismo::predict(lup.by.mix, stack(stack(bioclim), mix.predict)), "SpatRaster")
  lupbm.boyce <- modEvA::Boyce(obs = mixlup.test, pred = lupbm.predict)
  
  mixlup.predict <- as(dismo::predict(mixlup.maxent, stack(bioclim)), "SpatRaster")
  mixlup.boyce <- modEvA::Boyce(obs = mixlup.test, pred = mixlup.predict)
  
  
  
  
  
  # Step 5: Save Evaluation Scores
  mbl.eval = data.frame(run = i,
                        model = "mbl",
                        AUC = mixbylup.eval@auc,
                        cor = mixbylup.eval@cor,
                        TSS = max(mixbylup.eval@TPR - mixbylup.eval@FPR),
                        tstar = which.max(mixbylup.eval@TPR - mixbylup.eval@FPR),
                        boyce = mblup.boyce$Boyce)
  
  lbm.eval = data.frame(run = i,
                        model = "lbm",
                        AUC = lupbymix.eval@auc,
                        cor = lupbymix.eval@cor,
                        TSS = max(lupbymix.eval@TPR - lupbymix.eval@FPR),
                        tstar = which.max(lupbymix.eval@TPR - lupbymix.eval@FPR),
                        boyce = lupbm.boyce$Boyce)

  idm.eval = data.frame(run = i,
                        model = "IDM",
                        AUC = mixlup.eval@auc,
                        cor = mixlup.eval@cor,
                        TSS = max(mixlup.eval@TPR - mixlup.eval@FPR),
                        tstar = which.max(mixlup.eval@TPR - mixlup.eval@FPR),
                        boyce = mixlup.boyce$Boyce)
  
  mixlup.evaldf = bind_rows(mixlup.evaldf, mbl.eval, lbm.eval, idm.eval)
  
  
  
  
  # Step 6: Save Variable Importance
  mbl.vars = data.frame(run = rep(i, 21),
                        model = rep("mbl", 21),
                        variable = names(mix.by.lup@results[7:27,]),
                        percent = mix.by.lup@results[7:27],
                        permutation = mix.by.lup@results[28:48])
    
  lbm.vars = data.frame(run = rep(i, 21),
                        model = rep("lbm", 21),
                        variable = names(lup.by.mix@results[7:27,]),
                        percent = lup.by.mix@results[7:27],
                        permutation = lup.by.mix@results[28:48])
  
  idm.vars = data.frame(run = rep(i, 20),
                        model = rep("IDM", 20),
                        variable = names(mixlup.maxent@results[7:26,]),
                        percent = mixlup.maxent@results[7:26],
                        permutation = mixlup.maxent@results[27:46])
  
  mixlup.varimpdf = bind_rows(mixlup.varimpdf, mbl.vars, lbm.vars, idm.vars)
}

# write.csv(mixlup.evaldf, file = "completed-evals/mixlup-eval.csv")
# write.csv(mixlup.varimpdf, file = "completed-evals/mixlup-varimport.csv")
```


## Rubus

```{r mix rub data, message = F}
gbif.rub <- gbif %>%
  filter(genus == "Rubus")

mixrub <- bbna %>%
  filter(species == "mixtus",
         plant.host.genus == "Rubus") %>%
  dplyr::select(latitude, longitude, plant.host.genus, date, month, day, year)
```

```{r mixrub maxent for loop, message = F}
mixrub.evaldf <- data.frame()

mixrub.varimpdf <- data.frame()

set.seed(121023)
for(i in 1:100){
  # Step 1: separate all data into training and testing datasets
  bg <- as.data.frame(spatSample(x = bioclim, size = 50000, method = "random", na.rm = T, xy = T)) %>%
    dplyr::select(x, y) %>%
    rename(longitude = x,
           latitude = y)
  bgfold <- kfold(bg, k = 5)
  bg.test <- bg[bgfold == 1,]
  bg.train <- bg[bgfold != 1,]
  
  mix.longlat <- bbna %>%
    filter(species == "mixtus",
           plant.host.genus != "Rubus") %>%
    slice_sample(by = BBNA.code, n = 1) %>%
    dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  mix.fold <- kfold(mix.longlat, k = 5)
  mix.test <- mix.longlat[mix.fold == 1,]
  mix.train <- mix.longlat[mix.fold != 1,]
  
  rub.longlat <- gbif.rub %>%
  dplyr::select(decimalLongitude, decimalLatitude) %>%
  as.data.frame(.) %>%
  rename(longitude = decimalLongitude,
         latitude = decimalLatitude)
  rub.fold <- kfold(rub.longlat, k = 5)
  rub.test <- rub.longlat[rub.fold == 1,]
  rub.train <- rub.longlat[rub.fold != 1,]
  
  mixrub.longlat <- mixrub %>%
  dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  mixrub.fold <- kfold(mixrub.longlat, k = 5)
  mixrub.test <- mixrub.longlat[mixrub.fold == 1,]
  mixrub.train <- mixrub.longlat[mixrub.fold != 1,]
  
  
  
  # Step 2: Calculate overlaps
  ## Step 2a: Initial models based on just bioclim variables
  mix.maxent <- maxent(x = stack(bioclim),
                       p = mix.train, 
                       a = bg.train)
  mix.predict <- dismo::predict(mix.maxent,
                                stack(bioclim))
  
  rub.maxent <- maxent(x = stack(bioclim), 
                       p = rub.train, 
                       a = bg.train)
  rub.predict <- dismo::predict(rub.maxent,
                                stack(bioclim))
  
  ## Step 2b: Updated models including partner
  mix.by.rub <- maxent(x = stack(stack(bioclim), rub.predict),
                       p = mix.train,
                       a = bg.train)
  rub.by.mix <- maxent(x = stack(stack(bioclim), mix.predict),
                       p = rub.train,
                       a = bg.train)
  
  
  
  # Step 3: Calculate IDM
  mixrub.maxent <- maxent(x = stack(bioclim), 
                          p = mixrub.train, 
                          a = bg.train)
  
  
  
  # Step 4: Evaluate all both overlap models and IDM with the same interaction test data
  ## Step 4a: Use dismo::evaluate to get AUC and TSS scores
  mixbyrub.eval <- dismo::evaluate(p = mixrub.test,
                                   a = bg.test,
                                   model = mix.by.rub,
                                   x = stack(stack(bioclim), rub.predict))
  rubbymix.eval <- dismo::evaluate(p = mixrub.test,
                                   a = bg.test,
                                   model = rub.by.mix,
                                   x = stack(stack(bioclim), mix.predict))
  mixrub.eval <- dismo::evaluate(p = mixrub.test, 
                                 a = bg.test, 
                                 model = mixrub.maxent, 
                                 x = stack(bioclim))
  
   ## Step 4b: Use modEvA::Boyce to get Boyce Index
  mbrub.predict <- as(dismo::predict(mix.by.rub, stack(stack(bioclim), rub.predict)), "SpatRaster")
  mbrub.boyce <- modEvA::Boyce(obs = mixrub.test, pred = mbrub.predict)
  
  rubbm.predict <- as(dismo::predict(rub.by.mix, stack(stack(bioclim), mix.predict)), "SpatRaster")
  rubbm.boyce <- modEvA::Boyce(obs = mixrub.test, pred = rubbm.predict)
  
  mixrub.predict <- as(dismo::predict(mixrub.maxent, stack(bioclim)), "SpatRaster")
  mixrub.boyce <- modEvA::Boyce(obs = mixrub.test, pred = mixrub.predict)
  
  
  
  
  
  # Step 5: Save Evaluation Scores
  mbrub.eval = data.frame(run = i,
                        model = "mbrub",
                        AUC = mixbyrub.eval@auc,
                        cor = mixbyrub.eval@cor,
                        TSS = max(mixbyrub.eval@TPR - mixbyrub.eval@FPR),
                        tstar = which.max(mixbyrub.eval@TPR - mixbyrub.eval@FPR),
                        boyce = mbrub.boyce$Boyce)
  
  rubbm.eval = data.frame(run = i,
                        model = "rubbm",
                        AUC = rubbymix.eval@auc,
                        cor = rubbymix.eval@cor,
                        TSS = max(rubbymix.eval@TPR - rubbymix.eval@FPR),
                        tstar = which.max(rubbymix.eval@TPR - rubbymix.eval@FPR),
                        boyce = rubbm.boyce$Boyce)

  idm.eval = data.frame(run = i,
                        model = "IDM",
                        AUC = mixrub.eval@auc,
                        cor = mixrub.eval@cor,
                        TSS = max(mixrub.eval@TPR - mixrub.eval@FPR),
                        tstar = which.max(mixrub.eval@TPR - mixrub.eval@FPR),
                        boyce = mixrub.boyce$Boyce)
  
  mixrub.evaldf = bind_rows(mixrub.evaldf, mbrub.eval, rubbm.eval, idm.eval)
  
  
  
  
  # Step 6: Save Variable Importance
  mbrub.vars = data.frame(run = rep(i, 21),
                        model = rep("mbrub", 21),
                        variable = names(mix.by.rub@results[7:27,]),
                        percent = mix.by.rub@results[7:27],
                        permutation = mix.by.rub@results[28:48])
    
  rubbm.vars = data.frame(run = rep(i, 21),
                        model = rep("rubbm", 21),
                        variable = names(rub.by.mix@results[7:27,]),
                        percent = rub.by.mix@results[7:27],
                        permutation = rub.by.mix@results[28:48])
  
  idm.vars = data.frame(run = rep(i, 20),
                        model = rep("IDM", 20),
                        variable = names(mixrub.maxent@results[7:26,]),
                        percent = mixrub.maxent@results[7:26],
                        permutation = mixrub.maxent@results[27:46])
  
  mixrub.varimpdf = bind_rows(mixrub.varimpdf, mbrub.vars, rubbm.vars, idm.vars)
}

#write.csv(mixrub.evaldf, file = "completed-evals/mixrub-eval.csv")
#write.csv(mixrub.varimpdf, file = "completed-evals/mixrub-varimport.csv")
```

### Rubus spectabilis

```{r mixtus rubus spectabilis}
gbif.rubspec <- gbif %>%
  filter(species == "Rubus spectabilis")

mixrubspec.evaldf <- data.frame()

mixrubspec.varimpdf <- data.frame()

set.seed(240419)
for(i in 1:100){
  # Step 1: separate all data into training and testing datasets
  bg <- as.data.frame(spatSample(x = bioclim, size = 50000, method = "random", na.rm = T, xy = T)) %>%
    dplyr::select(x, y) %>%
    rename(longitude = x,
           latitude = y)
  bgfold <- kfold(bg, k = 5)
  bg.test <- bg[bgfold == 1,]
  bg.train <- bg[bgfold != 1,]
  
  mix.longlat <- bbna %>%
    filter(species == "mixtus",
           plant.host.genus != "Rubus") %>%
    slice_sample(by = BBNA.code, n = 1) %>%
    dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  mix.fold <- kfold(mix.longlat, k = 5)
  mix.test <- mix.longlat[mix.fold == 1,]
  mix.train <- mix.longlat[mix.fold != 1,]
  
  rubspec.longlat <- gbif.rubspec %>%
  dplyr::select(decimalLongitude, decimalLatitude) %>%
  as.data.frame(.) %>%
  rename(longitude = decimalLongitude,
         latitude = decimalLatitude)
  rubspec.fold <- kfold(rubspec.longlat, k = 5)
  rubspec.test <- rubspec.longlat[rubspec.fold == 1,]
  rubspec.train <- rubspec.longlat[rubspec.fold != 1,]
  
  mixrubspec.longlat <- mixrub %>%
  dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  mixrubspec.fold <- kfold(mixrubspec.longlat, k = 5)
  mixrubspec.test <- mixrubspec.longlat[mixrubspec.fold == 1,]
  mixrubspec.train <- mixrubspec.longlat[mixrubspec.fold != 1,]
  
  
  
  # Step 2: Calculate overlaps
  ## Step 2a: Initial models based on just bioclim variables
  mix.maxent <- maxent(x = stack(bioclim),
                       p = mix.train, 
                       a = bg.train)
  mix.predict <- dismo::predict(mix.maxent,
                                stack(bioclim))
  
  rubspec.maxent <- maxent(x = stack(bioclim), 
                       p = rubspec.train, 
                       a = bg.train)
  rubspec.predict <- dismo::predict(rubspec.maxent,
                                stack(bioclim))
  
  ## Step 2b: Updated models including partner
  mix.by.rubspec <- maxent(x = stack(stack(bioclim), rubspec.predict),
                       p = mix.train,
                       a = bg.train)
  rubspec.by.mix <- maxent(x = stack(stack(bioclim), mix.predict),
                       p = rubspec.train,
                       a = bg.train)
  
  

  
  
  # Step 4: Evaluate all both overlap models and IDM with the same interaction test data
  ## Step 4a: Use dismo::evaluate to get AUC and TSS scores
  mixbyrubspec.eval <- dismo::evaluate(p = mixrub.test,
                                   a = bg.test,
                                   model = mix.by.rubspec,
                                   x = stack(stack(bioclim), rubspec.predict))
  rubspecbymix.eval <- dismo::evaluate(p = mixrub.test,
                                   a = bg.test,
                                   model = rubspec.by.mix,
                                   x = stack(stack(bioclim), mix.predict))

  
  
  
  
  
  # Step 5: Save Evaluation Scores
  mbrubspec.eval = data.frame(run = i,
                        model = "mbrubspec",
                        AUC = mixbyrubspec.eval@auc,
                        cor = mixbyrubspec.eval@cor,
                        TSS = max(mixbyrubspec.eval@TPR - mixbyrubspec.eval@FPR),
                        tstar = which.max(mixbyrubspec.eval@TPR - mixbyrubspec.eval@FPR))
  
  rubspecbm.eval = data.frame(run = i,
                        model = "rubspecbm",
                        AUC = rubspecbymix.eval@auc,
                        cor = rubspecbymix.eval@cor,
                        TSS = max(rubspecbymix.eval@TPR - rubspecbymix.eval@FPR),
                        tstar = which.max(rubspecbymix.eval@TPR - rubspecbymix.eval@FPR),
                        boyce = rubspecbm.boyce$Boyce)


  
  mixrubspec.evaldf = bind_rows(mixrubspec.evaldf, mbrubspec.eval, rubspecbm.eval)
  
  
  
  
  # Step 6: Save Variable Importance
  mbrubspec.vars = data.frame(run = rep(i, 21),
                        model = rep("mbrubspec", 21),
                        variable = names(mix.by.rubspec@results[7:27,]),
                        percent = mix.by.rubspec@results[7:27],
                        permutation = mix.by.rubspec@results[28:48])
    
  rubspecbm.vars = data.frame(run = rep(i, 21),
                        model = rep("rubspecbm", 21),
                        variable = names(rubspec.by.mix@results[7:27,]),
                        percent = rubspec.by.mix@results[7:27],
                        permutation = rubspec.by.mix@results[28:48])
  

  
  mixrubspec.varimpdf = bind_rows(mixrubspec.varimpdf, mbrubspec.vars, rubspecbm.vars)
}
```


### Rubus parviflorus

```{r mixtus rubus parviflorus}
gbif.rubparv <- gbif %>%
  filter(species == "Rubus parviflorus")

mixrubparv.evaldf <- data.frame()

mixrubparv.varimpdf <- data.frame()

set.seed(2024419)
for(i in 1:100){
  # Step 1: separate all data into training and testing datasets
  bg <- as.data.frame(spatSample(x = bioclim, size = 50000, method = "random", na.rm = T, xy = T)) %>%
    dplyr::select(x, y) %>%
    rename(longitude = x,
           latitude = y)
  bgfold <- kfold(bg, k = 5)
  bg.test <- bg[bgfold == 1,]
  bg.train <- bg[bgfold != 1,]
  
  mix.longlat <- bbna %>%
    filter(species == "mixtus",
           plant.host.genus != "Rubus") %>%
    slice_sample(by = BBNA.code, n = 1) %>%
    dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  mix.fold <- kfold(mix.longlat, k = 5)
  mix.test <- mix.longlat[mix.fold == 1,]
  mix.train <- mix.longlat[mix.fold != 1,]
  
  rubparv.longlat <- gbif.rubparv %>%
  dplyr::select(decimalLongitude, decimalLatitude) %>%
  as.data.frame(.) %>%
  rename(longitude = decimalLongitude,
         latitude = decimalLatitude)
  rubparv.fold <- kfold(rubparv.longlat, k = 5)
  rubparv.test <- rubparv.longlat[rubparv.fold == 1,]
  rubparv.train <- rubparv.longlat[rubparv.fold != 1,]
  
  mixrubparv.longlat <- mixrub %>%
  dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  mixrubparv.fold <- kfold(mixrubparv.longlat, k = 5)
  mixrubparv.test <- mixrubparv.longlat[mixrubparv.fold == 1,]
  mixrubparv.train <- mixrubparv.longlat[mixrubparv.fold != 1,]
  
  
  
  # Step 2: Calculate overlaps
  ## Step 2a: Initial models based on just bioclim variables
  mix.maxent <- maxent(x = stack(bioclim),
                       p = mix.train, 
                       a = bg.train)
  mix.predict <- dismo::predict(mix.maxent,
                                stack(bioclim))
  
  rubparv.maxent <- maxent(x = stack(bioclim), 
                       p = rubparv.train, 
                       a = bg.train)
  rubparv.predict <- dismo::predict(rubparv.maxent,
                                stack(bioclim))
  
  ## Step 2b: Updated models including partner
  mix.by.rubparv <- maxent(x = stack(stack(bioclim), rubparv.predict),
                       p = mix.train,
                       a = bg.train)
  rubparv.by.mix <- maxent(x = stack(stack(bioclim), mix.predict),
                       p = rubparv.train,
                       a = bg.train)
  
  

  
  
  # Step 4: Evaluate all both overlap models and IDM with the same interaction test data
  ## Step 4a: Use dismo::evaluate to get AUC and TSS scores
  mixbyrubparv.eval <- dismo::evaluate(p = mixrub.test,
                                   a = bg.test,
                                   model = mix.by.rubparv,
                                   x = stack(stack(bioclim), rubparv.predict))
  rubparvbymix.eval <- dismo::evaluate(p = mixrub.test,
                                   a = bg.test,
                                   model = rubparv.by.mix,
                                   x = stack(stack(bioclim), mix.predict))

  
  
  
  
  
  # Step 5: Save Evaluation Scores
  mbrubparv.eval = data.frame(run = i,
                        model = "mbrubparv",
                        AUC = mixbyrubparv.eval@auc,
                        cor = mixbyrubparv.eval@cor,
                        TSS = max(mixbyrubparv.eval@TPR - mixbyrubparv.eval@FPR),
                        tstar = which.max(mixbyrubparv.eval@TPR - mixbyrubparv.eval@FPR))
  
  rubparvbm.eval = data.frame(run = i,
                        model = "rubparvbm",
                        AUC = rubparvbymix.eval@auc,
                        cor = rubparvbymix.eval@cor,
                        TSS = max(rubparvbymix.eval@TPR - rubparvbymix.eval@FPR),
                        tstar = which.max(rubparvbymix.eval@TPR - rubparvbymix.eval@FPR),
                        boyce = rubparvbm.boyce$Boyce)


  
  mixrubparv.evaldf = bind_rows(mixrubparv.evaldf, mbrubparv.eval, rubparvbm.eval)
  
  
  
  
  # Step 6: Save Variable Importance
  mbrubparv.vars = data.frame(run = rep(i, 21),
                        model = rep("mbrubparv", 21),
                        variable = names(mix.by.rubparv@results[7:27,]),
                        percent = mix.by.rubparv@results[7:27],
                        permutation = mix.by.rubparv@results[28:48])
    
  rubparvbm.vars = data.frame(run = rep(i, 21),
                        model = rep("rubparvbm", 21),
                        variable = names(rubparv.by.mix@results[7:27,]),
                        percent = rubparv.by.mix@results[7:27],
                        permutation = rubparv.by.mix@results[28:48])
  

  
  mixrubparv.varimpdf = bind_rows(mixrubparv.varimpdf, mbrubparv.vars, rubparvbm.vars)
}
```


# Vosnesenskii
## Chamaenerion

```{r vos cham data, message = F}
gbif.cham <- gbif %>%
  filter(genus == "Chamaenerion")

voscham <- bbna %>% 
  filter(species == "vosnesenskii",
         plant.host.genus == "Chamaenerion") %>%
  dplyr::select(latitude, longitude, plant.host.genus, date, month, day, year)
```

```{r voscham maxent for loop, message = F}
voscham.evaldf <- data.frame()

voscham.varimpdf <- data.frame()

set.seed(1301143)
for(i in 1:100){
  # Step 1: separate all data into training and testing datasets
  bg <- as.data.frame(spatSample(x = bioclim, size = 50000, method = "random", na.rm = T, xy = T)) %>%
    dplyr::select(x, y) %>%
    rename(longitude = x,
           latitude = y)
  bgfold <- kfold(bg, k = 5)
  bg.test <- bg[bgfold == 1,]
  bg.train <- bg[bgfold != 1,]
  
  vos.longlat <- bbna %>%
    filter(species == "vosnesenskii",
           plant.host.genus != "Chamaenerion") %>%
    slice_sample(by = BBNA.code, n = 1) %>%
    dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  vos.fold <- kfold(vos.longlat, k = 5)
  vos.test <- vos.longlat[vos.fold == 1,]
  vos.train <- vos.longlat[vos.fold != 1,]
  
  cham.longlat <- gbif.cham %>%
  dplyr::select(decimalLongitude, decimalLatitude) %>%
  as.data.frame(.) %>%
  rename(longitude = decimalLongitude,
         latitude = decimalLatitude)
  cham.fold <- kfold(cham.longlat, k = 5)
  cham.test <- cham.longlat[cham.fold == 1,]
  cham.train <- cham.longlat[cham.fold != 1,]
  
  voscham.longlat <- voscham %>%
  dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  voscham.fold <- kfold(voscham.longlat, k = 5)
  voscham.test <- voscham.longlat[voscham.fold == 1,]
  voscham.train <- voscham.longlat[voscham.fold != 1,]

  
  
  # Step 2: Calculate overlaps
  ## Step 2a: Initial models based on just bioclim variables
  vos.maxent <- maxent(x = stack(bioclim),
                       p = vos.train, 
                       a = bg.train)
  vos.predict <- dismo::predict(vos.maxent,
                                stack(bioclim))
  
  cham.maxent <- maxent(x = stack(bioclim), 
                       p = cham.train, 
                       a = bg.train)
  cham.predict <- dismo::predict(cham.maxent,
                                stack(bioclim))
  
  ## Step 2b: Updated models including partner
  vos.by.cham <- maxent(x = stack(stack(bioclim), cham.predict),
                       p = vos.train,
                       a = bg.train)
  cham.by.vos <- maxent(x = stack(stack(bioclim), vos.predict),
                       p = cham.train,
                       a = bg.train)
  
  
  
  # Step 3: Calculate IDM
  voscham.maxent <- maxent(x = stack(bioclim), 
                          p = voscham.train, 
                          a = bg.train)
  
  
  
  # Step 4: Evaluate all both overlap models and IDM with the same interaction test data
  ## Step 4a: Use dismo::evaluate to get AUC and TSS scores
  vosbycham.eval <- dismo::evaluate(p = voscham.test,
                                   a = bg.test,
                                   model = vos.by.cham,
                                   x = stack(stack(bioclim), cham.predict))
  chambyvos.eval <- dismo::evaluate(p = voscham.test,
                                   a = bg.test,
                                   model = cham.by.vos,
                                   x = stack(stack(bioclim), vos.predict))
  voscham.eval <- dismo::evaluate(p = voscham.test, 
                                 a = bg.test, 
                                 model = voscham.maxent, 
                                 x = stack(bioclim))
  
  ## Step 4b: Use modEvA::Boyce to get Boyce Index
  vbcham.predict <- as(dismo::predict(vos.by.cham, stack(stack(bioclim), cham.predict)), "SpatRaster")
  vbcham.boyce <- modEvA::Boyce(obs = voscham.test, pred = vbcham.predict)
  
  chambv.predict <- as(dismo::predict(cham.by.vos, stack(stack(bioclim), vos.predict)), "SpatRaster")
  chambv.boyce <- modEvA::Boyce(obs = voscham.test, pred = chambv.predict)
  
  voscham.predict <- as(dismo::predict(voscham.maxent, stack(bioclim)), "SpatRaster")
  voscham.boyce <- modEvA::Boyce(obs = voscham.test, pred = voscham.predict)
  
  
  
  
  
  
  # Step 5: Save Evaluation Scores
  vbcham.eval = data.frame(run = i,
                        model = "vbcham",
                        AUC = vosbycham.eval@auc,
                        cor = vosbycham.eval@cor,
                        TSS = max(vosbycham.eval@TPR - vosbycham.eval@FPR),
                        tstar = which.max(vosbycham.eval@TPR - vosbycham.eval@FPR),
                        boyce = vbcham.boyce$Boyce)
  
  chambv.eval = data.frame(run = i,
                        model = "chambv",
                        AUC = chambyvos.eval@auc,
                        cor = chambyvos.eval@cor,
                        TSS = max(chambyvos.eval@TPR - chambyvos.eval@FPR),
                        tstar = which.max(chambyvos.eval@TPR - chambyvos.eval@FPR),
                        boyce = chambv.boyce$Boyce)

  idm.eval = data.frame(run = i,
                        model = "IDM",
                        AUC = voscham.eval@auc,
                        cor = voscham.eval@cor,
                        TSS = max(voscham.eval@TPR - voscham.eval@FPR),
                        tstar = which.max(voscham.eval@TPR - voscham.eval@FPR),
                        boyce = voscham.boyce$Boyce)
  
  voscham.evaldf = bind_rows(voscham.evaldf, vbcham.eval, chambv.eval, idm.eval)
  
  
  
  
  # Step 6: Save Variable Importance
  vbcham.vars = data.frame(run = rep(i, 21),
                        model = rep("vbcham", 21),
                        variable = names(vos.by.cham@results[7:27,]),
                        percent = vos.by.cham@results[7:27],
                        permutation = vos.by.cham@results[28:48])
    
  chambv.vars = data.frame(run = rep(i, 21),
                        model = rep("chambv", 21),
                        variable = names(cham.by.vos@results[7:27,]),
                        percent = cham.by.vos@results[7:27],
                        permutation = cham.by.vos@results[28:48])
  
  idm.vars = data.frame(run = rep(i, 20),
                        model = rep("IDM", 20),
                        variable = names(voscham.maxent@results[7:26,]),
                        percent = voscham.maxent@results[7:26],
                        permutation = voscham.maxent@results[27:46])
  
  voscham.varimpdf = bind_rows(voscham.varimpdf, vbcham.vars, chambv.vars, idm.vars)
}

#write.csv(voscham.evaldf, file = "completed-evals/voscham-eval.csv")
#write.csv(voscham.varimpdf, file = "completed-evals/voscham-varimport.csv")
```



## Cirsium

```{r vos cir data, message = F}
gbif.cir <- gbif %>%
  filter(genus == "Cirsium")

voscir <- bbna %>% 
  filter(species == "vosnesenskii",
         plant.host.genus == "Cirsium") %>%
  dplyr::select(latitude, longitude, plant.host.genus, date, month, day, year)
```

```{r voscir maxent for loop, message = F}
voscir.evaldf <- data.frame()

voscir.varimpdf <- data.frame()

set.seed(261402)
for(i in 1:100){
  # Step 1: separate all data into training and testing datasets
  bg <- as.data.frame(spatSample(x = bioclim, size = 50000, method = "random", na.rm = T, xy = T)) %>%
    dplyr::select(x, y) %>%
    rename(longitude = x,
           latitude = y)
  bgfold <- kfold(bg, k = 5)
  bg.test <- bg[bgfold == 1,]
  bg.train <- bg[bgfold != 1,]
  
  vos.longlat <- bbna %>%
    filter(species == "vosnesenskii",
           plant.host.genus != "Cirsium") %>%
    slice_sample(by = BBNA.code, n = 1) %>%
    dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  vos.fold <- kfold(vos.longlat, k = 5)
  vos.test <- vos.longlat[vos.fold == 1,]
  vos.train <- vos.longlat[vos.fold != 1,]
  
  cir.longlat <- gbif.cir %>%
  dplyr::select(decimalLongitude, decimalLatitude) %>%
  as.data.frame(.) %>%
  rename(longitude = decimalLongitude,
         latitude = decimalLatitude)
  cir.fold <- kfold(cir.longlat, k = 5)
  cir.test <- cir.longlat[cir.fold == 1,]
  cir.train <- cir.longlat[cir.fold != 1,]
  
  voscir.longlat <- voscir %>%
  dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  voscir.fold <- kfold(voscir.longlat, k = 5)
  voscir.test <- voscir.longlat[voscir.fold == 1,]
  voscir.train <- voscir.longlat[voscir.fold != 1,]

  
  
  # Step 2: Calculate overlaps
  ## Step 2a: Initial models based on just bioclim variables
  vos.maxent <- maxent(x = stack(bioclim),
                       p = vos.train, 
                       a = bg.train)
  vos.predict <- dismo::predict(vos.maxent,
                                stack(bioclim))
  
  cir.maxent <- maxent(x = stack(bioclim), 
                       p = cir.train, 
                       a = bg.train)
  cir.predict <- dismo::predict(cir.maxent,
                                stack(bioclim))
  
  ## Step 2b: Updated models including partner
  vos.by.cir <- maxent(x = stack(stack(bioclim), cir.predict),
                       p = vos.train,
                       a = bg.train)
  cir.by.vos <- maxent(x = stack(stack(bioclim), vos.predict),
                       p = cir.train,
                       a = bg.train)
  
  
  
  # Step 3: Calculate IDM
  voscir.maxent <- maxent(x = stack(bioclim), 
                          p = voscir.train, 
                          a = bg.train)
  
  
  
  # Step 4: Evaluate all both overlap models and IDM with the same interaction test data
  ## Step 4a: Use dismo::evaluate to get AUC and TSS scores
  vosbycir.eval <- dismo::evaluate(p = voscir.test,
                                   a = bg.test,
                                   model = vos.by.cir,
                                   x = stack(stack(bioclim), cir.predict))
  cirbyvos.eval <- dismo::evaluate(p = voscir.test,
                                   a = bg.test,
                                   model = cir.by.vos,
                                   x = stack(stack(bioclim), vos.predict))
  voscir.eval <- dismo::evaluate(p = voscir.test, 
                                 a = bg.test, 
                                 model = voscir.maxent, 
                                 x = stack(bioclim))
  
  ## Step 4b: Use modEvA::Boyce to get Boyce Index
  vbcir.predict <- as(dismo::predict(vos.by.cir, stack(stack(bioclim), cir.predict)), "SpatRaster")
  vbcir.boyce <- modEvA::Boyce(obs = voscir.test, pred = vbcir.predict)
  
  cirbv.predict <- as(dismo::predict(cir.by.vos, stack(stack(bioclim), vos.predict)), "SpatRaster")
  cirbv.boyce <- modEvA::Boyce(obs = voscir.test, pred = cirbv.predict)
  
  voscir.predict <- as(dismo::predict(voscir.maxent, stack(bioclim)), "SpatRaster")
  voscir.boyce <- modEvA::Boyce(obs = voscir.test, pred = voscir.predict)
  
  
  
  
  
  # Step 5: Save Evaluation Scores
  vbcir.eval = data.frame(run = i,
                        model = "vbcir",
                        AUC = vosbycir.eval@auc,
                        cor = vosbycir.eval@cor,
                        TSS = max(vosbycir.eval@TPR - vosbycir.eval@FPR),
                        tstar = which.max(vosbycir.eval@TPR - vosbycir.eval@FPR),
                        boyce = vbcir.boyce$Boyce)
  
  cirbv.eval = data.frame(run = i,
                        model = "cirbv",
                        AUC = cirbyvos.eval@auc,
                        cor = cirbyvos.eval@cor,
                        TSS = max(cirbyvos.eval@TPR - cirbyvos.eval@FPR),
                        tstar = which.max(cirbyvos.eval@TPR - cirbyvos.eval@FPR),
                        boyce = cirbv.boyce$Boyce)

  idm.eval = data.frame(run = i,
                        model = "IDM",
                        AUC = voscir.eval@auc,
                        cor = voscir.eval@cor,
                        TSS = max(voscir.eval@TPR - voscir.eval@FPR),
                        tstar = which.max(voscir.eval@TPR - voscir.eval@FPR),
                        boyce = voscir.boyce$Boyce)
  
  voscir.evaldf = bind_rows(voscir.evaldf, vbcir.eval, cirbv.eval, idm.eval)
  
  
  
  
  
  # Step 6: Save Variable Importance
  vbcir.vars = data.frame(run = rep(i, 21),
                        model = rep("vbcir", 21),
                        variable = names(vos.by.cir@results[7:27,]),
                        percent = vos.by.cir@results[7:27],
                        permutation = vos.by.cir@results[28:48])
    
  cirbv.vars = data.frame(run = rep(i, 21),
                        model = rep("cirbv", 21),
                        variable = names(cir.by.vos@results[7:27,]),
                        percent = cir.by.vos@results[7:27],
                        permutation = cir.by.vos@results[28:48])
  
  idm.vars = data.frame(run = rep(i, 20),
                        model = rep("IDM", 20),
                        variable = names(voscir.maxent@results[7:26,]),
                        percent = voscir.maxent@results[7:26],
                        permutation = voscir.maxent@results[27:46])
  
  voscir.varimpdf = bind_rows(voscir.varimpdf, vbcir.vars, cirbv.vars, idm.vars)
}

#write.csv(voscir.evaldf, file = "completed-evals/voscir-eval.csv")
#write.csv(voscir.varimpdf, file = "completed-evals/voscir-varimport.csv")
```

## Lupinus

```{r vos lup data, message = F}
gbif.lup <- gbif %>%
  filter(genus == "Lupinus")

voslup <- bbna %>% 
  filter(species == "vosnesenskii",
         plant.host.genus == "Lupinus") %>%
  dplyr::select(latitude, longitude, plant.host.genus, date, month, day, year)
```

```{r voslup maxent for loop, message = F}
voslup.evaldf <- data.frame()

voslup.varimpdf <- data.frame()

set.seed(122323)
for(i in 1:100){
  # Step 1: separate all data into training and testing datasets
  bg <- as.data.frame(spatSample(x = bioclim, size = 50000, method = "random", na.rm = T, xy = T)) %>%
    dplyr::select(x, y) %>%
    rename(longitude = x,
           latitude = y)
  bgfold <- kfold(bg, k = 5)
  bg.test <- bg[bgfold == 1,]
  bg.train <- bg[bgfold != 1,]
  
  vos.longlat <- bbna %>%
    filter(species == "vosnesenskii",
           plant.host.genus != "Lupinus") %>%
    slice_sample(by = BBNA.code, n = 1) %>%
    dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  vos.fold <- kfold(vos.longlat, k = 5)
  vos.test <- vos.longlat[vos.fold == 1,]
  vos.train <- vos.longlat[vos.fold != 1,]
  
  lup.longlat <- gbif.lup %>%
  dplyr::select(decimalLongitude, decimalLatitude) %>%
  as.data.frame(.) %>%
  rename(longitude = decimalLongitude,
         latitude = decimalLatitude)
  lup.fold <- kfold(lup.longlat, k = 5)
  lup.test <- lup.longlat[lup.fold == 1,]
  lup.train <- lup.longlat[lup.fold != 1,]
  
  voslup.longlat <- voslup %>%
  dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  voslup.fold <- kfold(voslup.longlat, k = 5)
  voslup.test <- voslup.longlat[voslup.fold == 1,]
  voslup.train <- voslup.longlat[voslup.fold != 1,]

  
  
  # Step 2: Calculate overlaps
  ## Step 2a: Initial models based on just bioclim variables
  vos.maxent <- maxent(x = stack(bioclim),
                       p = vos.train, 
                       a = bg.train)
  vos.predict <- dismo::predict(vos.maxent,
                                stack(bioclim))
  
  lup.maxent <- maxent(x = stack(bioclim), 
                       p = lup.train, 
                       a = bg.train)
  lup.predict <- dismo::predict(lup.maxent,
                                stack(bioclim))
  
  ## Step 2b: Updated models including partner
  vos.by.lup <- maxent(x = stack(stack(bioclim), lup.predict),
                       p = vos.train,
                       a = bg.train)
  lup.by.vos <- maxent(x = stack(stack(bioclim), vos.predict),
                       p = lup.train,
                       a = bg.train)
  
  
  
  # Step 3: Calculate IDM
  voslup.maxent <- maxent(x = stack(bioclim), 
                          p = voslup.train, 
                          a = bg.train)
  
  
  
  # Step 4: Evaluate all both overlap models and IDM with the same interaction test data
  ## Step 4a: Use dismo::evaluate to get AUC and TSS scores
  vosbylup.eval <- dismo::evaluate(p = voslup.test,
                                   a = bg.test,
                                   model = vos.by.lup,
                                   x = stack(stack(bioclim), lup.predict))
  lupbyvos.eval <- dismo::evaluate(p = voslup.test,
                                   a = bg.test,
                                   model = lup.by.vos,
                                   x = stack(stack(bioclim), vos.predict))
  voslup.eval <- dismo::evaluate(p = voslup.test, 
                                 a = bg.test, 
                                 model = voslup.maxent, 
                                 x = stack(bioclim))
  
  
  ## Step 4b: Use modEvA::Boyce to get Boyce Index
  vblup.predict <- as(dismo::predict(vos.by.lup, stack(stack(bioclim), lup.predict)), "SpatRaster")
  vblup.boyce <- modEvA::Boyce(obs = voslup.test, pred = vblup.predict)
  
  lupbv.predict <- as(dismo::predict(lup.by.vos, stack(stack(bioclim), vos.predict)), "SpatRaster")
  lupbv.boyce <- modEvA::Boyce(obs = voslup.test, pred = lupbv.predict)
  
  voslup.predict <- as(dismo::predict(voslup.maxent, stack(bioclim)), "SpatRaster")
  voslup.boyce <- modEvA::Boyce(obs = voslup.test, pred = voslup.predict)
  
  
  
  
  
  
  # Step 5: Save Evaluation Scores
  vbl.eval = data.frame(run = i,
                        model = "vbl",
                        AUC = vosbylup.eval@auc,
                        cor = vosbylup.eval@cor,
                        TSS = max(vosbylup.eval@TPR - vosbylup.eval@FPR),
                        tstar = which.max(vosbylup.eval@TPR - vosbylup.eval@FPR),
                        boyce = vblup.boyce$Boyce)
  
  lbv.eval = data.frame(run = i,
                        model = "lbv",
                        AUC = lupbyvos.eval@auc,
                        cor = lupbyvos.eval@cor,
                        TSS = max(lupbyvos.eval@TPR - lupbyvos.eval@FPR),
                        tstar = which.max(lupbyvos.eval@TPR - lupbyvos.eval@FPR),
                        boyce = lupbv.boyce$Boyce)

  idm.eval = data.frame(run = i,
                        model = "IDM",
                        AUC = voslup.eval@auc,
                        cor = voslup.eval@cor,
                        TSS = max(voslup.eval@TPR - voslup.eval@FPR),
                        tstar = which.max(voslup.eval@TPR - voslup.eval@FPR),
                        boyce = voslup.boyce$Boyce)
  
  voslup.evaldf = bind_rows(voslup.evaldf, vbl.eval, lbv.eval, idm.eval)
  
  
  
  
  # Step 6: Save Variable Importance
  vbl.vars = data.frame(run = rep(i, 21),
                        model = rep("vbl", 21),
                        variable = names(vos.by.lup@results[7:27,]),
                        percent = vos.by.lup@results[7:27],
                        permutation = vos.by.lup@results[28:48])
    
  lbv.vars = data.frame(run = rep(i, 21),
                        model = rep("lbv", 21),
                        variable = names(lup.by.vos@results[7:27,]),
                        percent = lup.by.vos@results[7:27],
                        permutation = lup.by.vos@results[28:48])
  
  idm.vars = data.frame(run = rep(i, 20),
                        model = rep("IDM", 20),
                        variable = names(voslup.maxent@results[7:26,]),
                        percent = voslup.maxent@results[7:26],
                        permutation = voslup.maxent@results[27:46])
  
  voslup.varimpdf = bind_rows(voslup.varimpdf, vbl.vars, lbv.vars, idm.vars)
}

# write.csv(voslup.evaldf, file = "completed-evals/voslup-eval.csv")
# write.csv(voslup.varimpdf, file = "completed-evals/voslup-varimport.csv")
```




## Penstemon

```{r vos pen data, message = F}
gbif.pen <- gbif %>%
  filter(genus == "Penstemon")

vospen <- bbna %>% 
  filter(species == "vosnesenskii",
         plant.host.genus == "Penstemon") %>%
  dplyr::select(latitude, longitude, plant.host.genus, date, month, day, year)
```

```{r vospen maxent for loop, message = F}
vospen.evaldf <- data.frame()

vospen.varimpdf <- data.frame()

set.seed(65784)
for(i in 1:100){
  # Step 1: separate all data into training and testing datasets
  bg <- as.data.frame(spatSample(x = bioclim, size = 50000, method = "random", na.rm = T, xy = T)) %>%
    dplyr::select(x, y) %>%
    rename(longitude = x,
           latitude = y)
  bgfold <- kfold(bg, k = 5)
  bg.test <- bg[bgfold == 1,]
  bg.train <- bg[bgfold != 1,]
  
  vos.longlat <- bbna %>%
    filter(species == "vosnesenskii",
           plant.host.genus != "Penstemon") %>%
    slice_sample(by = BBNA.code, n = 1) %>%
    dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  vos.fold <- kfold(vos.longlat, k = 5)
  vos.test <- vos.longlat[vos.fold == 1,]
  vos.train <- vos.longlat[vos.fold != 1,]
  
  pen.longlat <- gbif.pen %>%
  dplyr::select(decimalLongitude, decimalLatitude) %>%
  as.data.frame(.) %>%
  rename(longitude = decimalLongitude,
         latitude = decimalLatitude)
  pen.fold <- kfold(pen.longlat, k = 5)
  pen.test <- pen.longlat[pen.fold == 1,]
  pen.train <- pen.longlat[pen.fold != 1,]
  
  vospen.longlat <- vospen %>%
  dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  vospen.fold <- kfold(vospen.longlat, k = 5)
  vospen.test <- vospen.longlat[vospen.fold == 1,]
  vospen.train <- vospen.longlat[vospen.fold != 1,]

  
  
  # Step 2: Calculate overlaps
  ## Step 2a: Initial models based on just bioclim variables
  vos.maxent <- maxent(x = stack(bioclim),
                       p = vos.train, 
                       a = bg.train)
  vos.predict <- dismo::predict(vos.maxent,
                                stack(bioclim))
  
  pen.maxent <- maxent(x = stack(bioclim), 
                       p = pen.train, 
                       a = bg.train)
  pen.predict <- dismo::predict(pen.maxent,
                                stack(bioclim))
  
  ## Step 2b: Updated models including partner
  vos.by.pen <- maxent(x = stack(stack(bioclim), pen.predict),
                       p = vos.train,
                       a = bg.train)
  pen.by.vos <- maxent(x = stack(stack(bioclim), vos.predict),
                       p = pen.train,
                       a = bg.train)
  
  
  
  # Step 3: Calculate IDM
  vospen.maxent <- maxent(x = stack(bioclim), 
                          p = vospen.train, 
                          a = bg.train)
  
  
  
  # Step 4: Evaluate all both overlap models and IDM with the same interaction test data
  ## Step 4a: Use dismo::evaluate to get AUC and TSS scores
  vosbypen.eval <- dismo::evaluate(p = vospen.test,
                                   a = bg.test,
                                   model = vos.by.pen,
                                   x = stack(stack(bioclim), pen.predict))
  penbyvos.eval <- dismo::evaluate(p = vospen.test,
                                   a = bg.test,
                                   model = pen.by.vos,
                                   x = stack(stack(bioclim), vos.predict))
  vospen.eval <- dismo::evaluate(p = vospen.test, 
                                 a = bg.test, 
                                 model = vospen.maxent, 
                                 x = stack(bioclim))
  
  
  ## Step 4b: Use modEvA::Boyce to get Boyce Index
  vbpen.predict <- as(dismo::predict(vos.by.pen, stack(stack(bioclim), pen.predict)), "SpatRaster")
  vbpen.boyce <- modEvA::Boyce(obs = vospen.test, pred = vbpen.predict)
  
  penbv.predict <- as(dismo::predict(pen.by.vos, stack(stack(bioclim), vos.predict)), "SpatRaster")
  penbv.boyce <- modEvA::Boyce(obs = vospen.test, pred = penbv.predict)
  
  vospen.predict <- as(dismo::predict(vospen.maxent, stack(bioclim)), "SpatRaster")
  vospen.boyce <- modEvA::Boyce(obs = vospen.test, pred = vospen.predict)
  
  
  
  
  
  
  # Step 5: Save Evaluation Scores
  vbp.eval = data.frame(run = i,
                        model = "vbp",
                        AUC = vosbypen.eval@auc,
                        cor = vosbypen.eval@cor,
                        TSS = max(vosbypen.eval@TPR - vosbypen.eval@FPR),
                        tstar = which.max(vosbypen.eval@TPR - vosbypen.eval@FPR),
                        boyce = vbpen.boyce$Boyce)
  
  pbv.eval = data.frame(run = i,
                        model = "pbv",
                        AUC = penbyvos.eval@auc,
                        cor = penbyvos.eval@cor,
                        TSS = max(penbyvos.eval@TPR - penbyvos.eval@FPR),
                        tstar = which.max(penbyvos.eval@TPR - penbyvos.eval@FPR),
                        boyce = penbv.boyce$Boyce)

  idm.eval = data.frame(run = i,
                        model = "IDM",
                        AUC = vospen.eval@auc,
                        cor = vospen.eval@cor,
                        TSS = max(vospen.eval@TPR - vospen.eval@FPR),
                        tstar = which.max(vospen.eval@TPR - vospen.eval@FPR),
                        boyce = vospen.boyce$Boyce)
  
  vospen.evaldf = bind_rows(vospen.evaldf, vbp.eval, pbv.eval, idm.eval)
  
  
  
  
  # Step 6: Save Variable Importance
  vbp.vars = data.frame(run = rep(i, 21),
                        model = rep("vbp", 21),
                        variable = names(vos.by.pen@results[7:27,]),
                        percent = vos.by.pen@results[7:27],
                        permutation = vos.by.pen@results[28:48])
    
  pbv.vars = data.frame(run = rep(i, 21),
                        model = rep("pbv", 21),
                        variable = names(pen.by.vos@results[7:27,]),
                        percent = pen.by.vos@results[7:27],
                        permutation = pen.by.vos@results[28:48])
  
  idm.vars = data.frame(run = rep(i, 20),
                        model = rep("IDM", 20),
                        variable = names(vospen.maxent@results[7:26,]),
                        percent = vospen.maxent@results[7:26],
                        permutation = vospen.maxent@results[27:46])
  
  vospen.varimpdf = bind_rows(vospen.varimpdf, vbp.vars, pbv.vars, idm.vars)
}

#write.csv(vospen.evaldf, file = "completed-evals/vospen-eval.csv")
#write.csv(vospen.varimpdf, file = "completed-evals/vospen-varimport.csv")
```


## Rubus

```{r vos rub data, message = F}
gbif.rub <- gbif %>%
  filter(genus == "Rubus")

vosrub <- bbna %>% 
  filter(species == "vosnesenskii",
         plant.host.genus == "Rubus") %>%
  dplyr::select(latitude, longitude, plant.host.genus, date, month, day, year)
```

```{r vosrub maxent for loop, message = F}
vosrub.evaldf <- data.frame()

vosrub.varimpdf <- data.frame()

set.seed(11424)
for(i in 1:100){
  # Step 1: separate all data into training and testing datasets
  bg <- as.data.frame(spatSample(x = bioclim, size = 50000, method = "random", na.rm = T, xy = T)) %>%
    dplyr::select(x, y) %>%
    rename(longitude = x,
           latitude = y)
  bgfold <- kfold(bg, k = 5)
  bg.test <- bg[bgfold == 1,]
  bg.train <- bg[bgfold != 1,]
  
  vos.longlat <- bbna %>%
    filter(species == "vosnesenskii",
           plant.host.genus != "Rubus") %>%
    slice_sample(by = BBNA.code, n = 1) %>%
    dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  vos.fold <- kfold(vos.longlat, k = 5)
  vos.test <- vos.longlat[vos.fold == 1,]
  vos.train <- vos.longlat[vos.fold != 1,]
  
  rub.longlat <- gbif.rub %>%
  dplyr::select(decimalLongitude, decimalLatitude) %>%
  as.data.frame(.) %>%
  rename(longitude = decimalLongitude,
         latitude = decimalLatitude)
  rub.fold <- kfold(rub.longlat, k = 5)
  rub.test <- rub.longlat[rub.fold == 1,]
  rub.train <- rub.longlat[rub.fold != 1,]
  
  vosrub.longlat <- vosrub %>%
  dplyr::select(longitude, latitude) %>%
  as.data.frame(.)
  vosrub.fold <- kfold(vosrub.longlat, k = 5)
  vosrub.test <- vosrub.longlat[vosrub.fold == 1,]
  vosrub.train <- vosrub.longlat[vosrub.fold != 1,]

  
  
  # Step 2: Calculate overlaps
  ## Step 2a: Initial models based on just bioclim variables
  vos.maxent <- maxent(x = stack(bioclim),
                       p = vos.train, 
                       a = bg.train)
  vos.predict <- dismo::predict(vos.maxent,
                                stack(bioclim))
  
  rub.maxent <- maxent(x = stack(bioclim), 
                       p = rub.train, 
                       a = bg.train)
  rub.predict <- dismo::predict(rub.maxent,
                                stack(bioclim))
  
  ## Step 2b: Updated models including partner
  vos.by.rub <- maxent(x = stack(stack(bioclim), rub.predict),
                       p = vos.train,
                       a = bg.train)
  rub.by.vos <- maxent(x = stack(stack(bioclim), vos.predict),
                       p = rub.train,
                       a = bg.train)
  
  
  
  # Step 3: Calculate IDM
  vosrub.maxent <- maxent(x = stack(bioclim), 
                          p = vosrub.train, 
                          a = bg.train)
  
  
  
  # Step 4: Evaluate all both overlap models and IDM with the same interaction test data
  ## Step 4a: Use dismo::evaluate to get AUC and TSS scores
  vosbyrub.eval <- dismo::evaluate(p = vosrub.test,
                                   a = bg.test,
                                   model = vos.by.rub,
                                   x = stack(stack(bioclim), rub.predict))
  rubbyvos.eval <- dismo::evaluate(p = vosrub.test,
                                   a = bg.test,
                                   model = rub.by.vos,
                                   x = stack(stack(bioclim), vos.predict))
  vosrub.eval <- dismo::evaluate(p = vosrub.test, 
                                 a = bg.test, 
                                 model = vosrub.maxent, 
                                 x = stack(bioclim))
  
  
  ## Step 4b: Use modEvA::Boyce to get Boyce Index
  vbrub.predict <- as(dismo::predict(vos.by.rub, stack(stack(bioclim), rub.predict)), "SpatRaster")
  vbrub.boyce <- modEvA::Boyce(obs = vosrub.test, pred = vbrub.predict)
  
  rubbv.predict <- as(dismo::predict(rub.by.vos, stack(stack(bioclim), vos.predict)), "SpatRaster")
  rubbv.boyce <- modEvA::Boyce(obs = vosrub.test, pred = rubbv.predict)
  
  vosrub.predict <- as(dismo::predict(vosrub.maxent, stack(bioclim)), "SpatRaster")
  vosrub.boyce <- modEvA::Boyce(obs = vosrub.test, pred = vosrub.predict)
  
  
  
  
  
  
  # Step 5: Save Evaluation Scores
  vbr.eval = data.frame(run = i,
                        model = "vbr",
                        AUC = vosbyrub.eval@auc,
                        cor = vosbyrub.eval@cor,
                        TSS = max(vosbyrub.eval@TPR - vosbyrub.eval@FPR),
                        tstar = which.max(vosbyrub.eval@TPR - vosbyrub.eval@FPR),
                        boyce = vbrub.boyce$Boyce)
  
  rbv.eval = data.frame(run = i,
                        model = "rbv",
                        AUC = rubbyvos.eval@auc,
                        cor = rubbyvos.eval@cor,
                        TSS = max(rubbyvos.eval@TPR - rubbyvos.eval@FPR),
                        tstar = which.max(rubbyvos.eval@TPR - rubbyvos.eval@FPR),
                        boyce = rubbv.boyce$Boyce)

  idm.eval = data.frame(run = i,
                        model = "IDM",
                        AUC = vosrub.eval@auc,
                        cor = vosrub.eval@cor,
                        TSS = max(vosrub.eval@TPR - vosrub.eval@FPR),
                        tstar = which.max(vosrub.eval@TPR - vosrub.eval@FPR),
                        boyce = vosrub.boyce$Boyce)
  
  vosrub.evaldf = bind_rows(vosrub.evaldf, vbr.eval, rbv.eval, idm.eval)
  
  
  
  
  # Step 6: Save Variable Importance
  vbr.vars = data.frame(run = rep(i, 21),
                        model = rep("vbr", 21),
                        variable = names(vos.by.rub@results[7:27,]),
                        percent = vos.by.rub@results[7:27],
                        permutation = vos.by.rub@results[28:48])
    
  rbv.vars = data.frame(run = rep(i, 21),
                        model = rep("rbv", 21),
                        variable = names(rub.by.vos@results[7:27,]),
                        percent = rub.by.vos@results[7:27],
                        permutation = rub.by.vos@results[28:48])
  
  idm.vars = data.frame(run = rep(i, 20),
                        model = rep("IDM", 20),
                        variable = names(vosrub.maxent@results[7:26,]),
                        percent = vosrub.maxent@results[7:26],
                        permutation = vosrub.maxent@results[27:46])
  
  vosrub.varimpdf = bind_rows(vosrub.varimpdf, vbr.vars, rbv.vars, idm.vars)
}

# write.csv(vosrub.evaldf, file = "completed-evals/vosrub-eval.csv")
# write.csv(vosrub.varimpdf, file = "completed-evals/vosrub-varimport.csv")
```

# Session Info
```{r sessioninfo}
sessionInfo()
```

